(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = require("three");
// Interfaces
var IndexController = /** @class */ (function () {
    function IndexController() {
    }
    IndexController.prototype.init = function () {
        this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 10);
        this.camera.position.z = 1;
        this.scene = new THREE.Scene();
        this.geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        this.material = new THREE.MeshNormalMaterial();
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.scene.add(this.mesh);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        this.animate();
    };
    IndexController.prototype.animate = function () {
        var self = this;
        requestAnimationFrame(self.animate);
        this.mesh.rotation.x += 0.01;
        this.mesh.rotation.y += 0.02;
        this.renderer.render(this.scene, this.camera);
    };
    return IndexController;
}());
exports.IndexController = IndexController;

},{"three":3}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Controllers
var IndexController_1 = require("./Controllers/IndexController");
// Services
// Instantiate Services with dependency injection
// Controllers
var indexController = new IndexController_1.IndexController();
indexController.init();

},{"./Controllers/IndexController":1}],3:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.THREE = {})));
}(this, (function (exports) { 'use strict';

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		( function () {

			Object.assign = function ( target ) {

				if ( target === undefined || target === null ) {

					throw new TypeError( 'Cannot convert undefined or null to object' );

				}

				var output = Object( target );

				for ( var index = 1; index < arguments.length; index ++ ) {

					var source = arguments[ index ];

					if ( source !== undefined && source !== null ) {

						for ( var nextKey in source ) {

							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

								output[ nextKey ] = source[ nextKey ];

							}

						}

					}

				}

				return output;

			};

		} )();

	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	var REVISION = '90';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: ( function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var lut = [];

			for ( var i = 0; i < 256; i ++ ) {

				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();

			}

			return function generateUUID() {

				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				return lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

			};

		} )(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * _Math.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * _Math.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	}

	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );

	Object.assign( Vector2.prototype, {

		isVector2: true,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector2();
			var max = new Vector2();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( this.y, this.x );

			if ( angle < 0 ) angle += 2 * Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix4.prototype, {

		isMatrix4: true,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new Vector3();

			return function extractRotation( m ) {

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q._x, y = q._y, z = q._z, w = q._w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();

			return function lookAt( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target );

				if ( z.lengthSq() === 0 ) {

					// eye and target are in the same position

					z.z = 1;

				}

				z.normalize();
				x.crossVectors( up, z );

				if ( x.lengthSq() === 0 ) {

					// up and z are parallel

					if ( Math.abs( up.z ) === 1 ) {

						z.x += 0.0001;

					} else {

						z.z += 0.0001;

					}

					z.normalize();
					x.crossVectors( up, z );

				}

				x.normalize();
				y.crossVectors( z, x );

				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix4( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) {

				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector = new Vector3();
			var matrix = new Matrix4();

			return function decompose( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part
				matrix.copy( this );

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.defineProperties( Quaternion.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Quaternion.prototype, {

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// assumes direction vectors vFrom and vTo are normalized

			var v1 = new Vector3();
			var r;

			var EPS = 0.000001;

			return function setFromUnitVectors( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				return this.normalize();

			};

		}(),

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion = new Quaternion();

			return function applyEuler( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

			};

		}(),

		applyAxisAngle: function () {

			var quaternion = new Quaternion();

			return function applyAxisAngle( axis, angle ) {

				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix = new Matrix4();

			return function project( camera ) {

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		unproject: function () {

			var matrix = new Matrix4();

			return function unproject( camera ) {

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector3();
			var max = new Vector3();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( vector ) {

			var scalar = vector.dot( this ) / vector.lengthSq();

			return this.copy( vector ).multiplyScalar( scalar );

		},

		projectOnPlane: function () {

			var v1 = new Vector3();

			return function projectOnPlane( planeNormal ) {

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1 = new Vector3();

			return function reflect( normal ) {

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			};

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

			// clamp, to handle numerical problems

			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			var sinPhiRadius = Math.sin( s.phi ) * s.radius;

			this.x = sinPhiRadius * Math.sin( s.theta );
			this.y = Math.cos( s.phi ) * s.radius;
			this.z = sinPhiRadius * Math.cos( s.theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			this.x = c.radius * Math.sin( c.theta );
			this.y = c.y;
			this.z = c.radius * Math.cos( c.theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix3.prototype, {

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix3( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( matrix && matrix.isMatrix4 ) {

				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) {

				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var textureId = 0;

	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			function getDataURL( image ) {

				var canvas;

				if ( image instanceof HTMLCanvasElement ) {

					canvas = image;

				} else {

					canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;

					var context = canvas.getContext( '2d' );

					if ( image instanceof ImageData ) {

						context.putImageData( image, 0, 0 );

					} else {

						context.drawImage( image, 0, 0, image.width, image.height );

					}

				}

				if ( canvas.width > 2048 || canvas.height > 2048 ) {

					return canvas.toDataURL( 'image/jpeg', 0.6 );

				} else {

					return canvas.toDataURL( 'image/png' );

				}

			}

			var output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY
			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = _Math.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

		}

	} );

	Object.defineProperty( Texture.prototype, "needsUpdate", {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Vector4.prototype, {

		isVector4: true,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new Vector4();
					max = new Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

	} );

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.uuid = _Math.generateUUID();

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	function WebGLRenderTargetCube( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;

	}

	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	/**
	 * @author tschw
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyCubeTexture = new CubeTexture();

	// --- Base for inner nodes (including the root) ---

	function UniformContainer() {

		this.seq = [];
		this.map = {};

	}

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	// Texture unit allocation

	function allocTexUnits( renderer, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i )
			r[ i ] = renderer.allocTextureUnit();

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValue1f( gl, v ) {

		gl.uniform1f( this.addr, v );

	}

	function setValue1i( gl, v ) {

		gl.uniform1i( this.addr, v );

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValue2fv( gl, v ) {

		if ( v.x === undefined ) {

			gl.uniform2fv( this.addr, v );

		} else {

			gl.uniform2f( this.addr, v.x, v.y );

		}

	}

	function setValue3fv( gl, v ) {

		if ( v.x !== undefined ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

		} else if ( v.r !== undefined ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

		} else {

			gl.uniform3fv( this.addr, v );

		}

	}

	function setValue4fv( gl, v ) {

		if ( v.x === undefined ) {

			gl.uniform4fv( this.addr, v );

		} else {

			 gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValue2fm( gl, v ) {

		gl.uniformMatrix2fv( this.addr, false, v.elements || v );

	}

	function setValue3fm( gl, v ) {

		if ( v.elements === undefined ) {

			gl.uniformMatrix3fv( this.addr, false, v );

		} else {

			mat3array.set( v.elements );
			gl.uniformMatrix3fv( this.addr, false, mat3array );

		}

	}

	function setValue4fm( gl, v ) {

		if ( v.elements === undefined ) {

			gl.uniformMatrix4fv( this.addr, false, v );

		} else {

			mat4array.set( v.elements );
			gl.uniformMatrix4fv( this.addr, false, mat4array );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, renderer ) {

		var unit = renderer.allocTextureUnit();
		gl.uniform1i( this.addr, unit );
		renderer.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT6( gl, v, renderer ) {

		var unit = renderer.allocTextureUnit();
		gl.uniform1i( this.addr, unit );
		renderer.setTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValue2iv( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValue3iv( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValue4iv( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4

			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4

			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8b60: return setValueT6; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// Array of scalars

	function setValue1fv( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}
	function setValue1iv( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of vectors (flat or from THREE classes)

	function setValueV2a( gl, v ) {

		gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

	}

	function setValueV3a( gl, v ) {

		gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

	}

	function setValueV4a( gl, v ) {

		gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2a( gl, v ) {

		gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

	}

	function setValueM3a( gl, v ) {

		gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

	}

	function setValueM4a( gl, v ) {

		gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

	}

	// Array of textures (2D / Cube)

	function setValueT1a( gl, v, renderer ) {

		var n = v.length,
			units = allocTexUnits( renderer, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6a( gl, v, renderer ) {

		var n = v.length,
			units = allocTexUnits( renderer, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4

			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4

			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function StructuredUniform( id ) {

		this.id = id;

		UniformContainer.call( this ); // mix-in

	}

	StructuredUniform.prototype.setValue = function ( gl, value ) {

		// Note: Don't need an extra 'renderer' parameter, since samplers
		// are not allowed in structured uniforms.

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ] );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		for ( ; ; ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,

				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map, next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program, renderer ) {

		UniformContainer.call( this );

		this.renderer = renderer;

		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				path = info.name,
				addr = gl.getUniformLocation( program, path );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, this.renderer );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, renderer );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	Object.assign( Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setScalar: function ( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function setHSL( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		sub: function ( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		},

		toJSON: function () {

			return this.getHex();

		}

	} );

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	/**
	 * Uniform Utilities
	 */

	var UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src && ( parameter_src.isColor ||
						parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
						parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
						parameter_src.isTexture ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( Array.isArray( parameter_src ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\r\n\r\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\r\n\r\n#endif\r\n";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\r\n\r\n\tuniform sampler2D alphaMap;\r\n\r\n#endif\r\n";

	var alphatest_fragment = "#ifdef ALPHATEST\r\n\r\n\tif ( diffuseColor.a < ALPHATEST ) discard;\r\n\r\n#endif\r\n";

	var aomap_fragment = "#ifdef USE_AOMAP\r\n\r\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\r\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\r\n\r\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\r\n\r\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\r\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\r\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\r\n\r\n\tuniform sampler2D aoMap;\r\n\tuniform float aoMapIntensity;\r\n\r\n#endif";

	var begin_vertex = "\r\nvec3 transformed = vec3( position );\r\n";

	var beginnormal_vertex = "\r\nvec3 objectNormal = vec3( normal );\r\n";

	var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\r\n\tif( decayExponent > 0.0 ) {\r\n\r\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\r\n\r\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t\t// page 32, equation 26: E[window1]\r\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\t// this is intended to be used on spot and point lights who are represented as luminous intensity\r\n\t\t// but who must be converted to luminous irradiance for surface lighting calculation\r\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\r\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\r\n\r\n#else\r\n\r\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\r\n\r\n#endif\r\n\r\n\t}\r\n\r\n\treturn 1.0;\r\n\r\n}\r\n\r\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n\r\n\treturn RECIPROCAL_PI * diffuseColor;\r\n\r\n} // validated\r\n\r\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n\r\n\t// Original approximation by Christophe Schlick '94\r\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n\r\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\r\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\r\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n\r\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\r\n\r\n} // validated\r\n\r\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// alpha is \"roughness squared\" in Disney’s reparameterization\r\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\r\n\t// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\r\n\t// also see #12151\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\r\n\treturn 1.0 / ( gl * gv );\r\n\r\n} // validated\r\n\r\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\r\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\r\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\r\n\treturn 0.5 / max( gv + gl, EPSILON );\r\n\r\n}\r\n\r\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// alpha is \"roughness squared\" in Disney’s reparameterization\r\nfloat D_GGX( const in float alpha, const in float dotNH ) {\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\r\n\r\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\r\n\r\n}\r\n\r\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\r\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\r\n\tfloat alpha = pow2( roughness ); // UE4's roughness\r\n\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\r\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\r\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\r\n\r\n\tfloat D = D_GGX( alpha, dotNH );\r\n\r\n\treturn F * ( G * D );\r\n\r\n} // validated\r\n\r\n// Rect Area Light\r\n\r\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\r\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\r\n// code: https://github.com/selfshadow/ltc_code/\r\n\r\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\r\n\r\n\tconst float LUT_SIZE  = 64.0;\r\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\r\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\r\n\r\n\tfloat dotNV = saturate( dot( N, V ) );\r\n\r\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\r\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\r\n\r\n\tuv = uv * LUT_SCALE + LUT_BIAS;\r\n\r\n\treturn uv;\r\n\r\n}\r\n\r\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\r\n\r\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\r\n\t// An approximation of the form factor of a horizon-clipped rectangle.\r\n\r\n\tfloat l = length( f );\r\n\r\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\r\n\r\n}\r\n\r\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\r\n\r\n\tfloat x = dot( v1, v2 );\r\n\r\n\tfloat y = abs( x );\r\n\r\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\r\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\r\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\r\n\tfloat v = a / b;\r\n\r\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\r\n\r\n\treturn cross( v1, v2 ) * theta_sintheta;\r\n\r\n}\r\n\r\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\r\n\r\n\t// bail if point is on back side of plane of light\r\n\t// assumes ccw winding order of light vertices\r\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\r\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\r\n\tvec3 lightNormal = cross( v1, v2 );\r\n\r\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\r\n\r\n\t// construct orthonormal basis around N\r\n\tvec3 T1, T2;\r\n\tT1 = normalize( V - N * dot( V, N ) );\r\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\r\n\r\n\t// compute transform\r\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\r\n\r\n\t// transform rect\r\n\tvec3 coords[ 4 ];\r\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\r\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\r\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\r\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\r\n\r\n\t// project rect onto sphere\r\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\r\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\r\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\r\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\r\n\r\n\t// calculate vector form factor\r\n\tvec3 vectorFormFactor = vec3( 0.0 );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\r\n\r\n\t// adjust for horizon clipping\r\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\r\n\r\n\r\n\r\n\treturn vec3( result );\r\n\r\n}\r\n\r\n// End Rect Area Light\r\n\r\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\r\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\r\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n\r\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n\r\n\tvec4 r = roughness * c0 + c1;\r\n\r\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n\r\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\r\n\r\n\treturn specularColor * AB.x + AB.y;\r\n\r\n} // validated\r\n\r\n\r\nfloat G_BlinnPhong_Implicit( ) {\r\n\r\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n\treturn 0.25;\r\n\r\n}\r\n\r\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n\r\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n\r\n}\r\n\r\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\r\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\r\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\r\n\tfloat G = G_BlinnPhong_Implicit( );\r\n\r\n\tfloat D = D_BlinnPhong( shininess, dotNH );\r\n\r\n\treturn F * ( G * D );\r\n\r\n} // validated\r\n\r\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\r\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\r\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\r\n}\r\n\r\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\r\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\r\n}\r\n";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\r\n\r\n\tuniform sampler2D bumpMap;\r\n\tuniform float bumpScale;\r\n\r\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\r\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\r\n\r\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\r\n\r\n\tvec2 dHdxy_fwd() {\r\n\r\n\t\tvec2 dSTdx = dFdx( vUv );\r\n\t\tvec2 dSTdy = dFdy( vUv );\r\n\r\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\r\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\r\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\r\n\r\n\t\treturn vec2( dBx, dBy );\r\n\r\n\t}\r\n\r\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\r\n\r\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\r\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\r\n\t\tvec3 vN = surf_norm;\t\t// normalized\r\n\r\n\t\tvec3 R1 = cross( vSigmaY, vN );\r\n\t\tvec3 R2 = cross( vN, vSigmaX );\r\n\r\n\t\tfloat fDet = dot( vSigmaX, R1 );\r\n\r\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\r\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\r\n\r\n\t}\r\n\r\n#endif\r\n";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\r\n\r\n\tvec4 plane;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\r\n\r\n\t\tplane = clippingPlanes[ i ];\r\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\r\n\r\n\t}\r\n\r\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\r\n\r\n\t\tbool clipped = true;\r\n\r\n\t\t#pragma unroll_loop\r\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\r\n\r\n\t\t\tplane = clippingPlanes[ i ];\r\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\r\n\r\n\t\t}\r\n\r\n\t\tif ( clipped ) discard;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\r\n\r\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\t\tvarying vec3 vViewPosition;\r\n\t#endif\r\n\r\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\r\n\r\n#endif\r\n";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\tvarying vec3 vViewPosition;\r\n#endif\r\n";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\tvViewPosition = - mvPosition.xyz;\r\n#endif\r\n\r\n";

	var color_fragment = "#ifdef USE_COLOR\r\n\r\n\tdiffuseColor.rgb *= vColor;\r\n\r\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\r\n\r\n\tvarying vec3 vColor;\r\n\r\n#endif\r\n";

	var color_pars_vertex = "#ifdef USE_COLOR\r\n\r\n\tvarying vec3 vColor;\r\n\r\n#endif";

	var color_vertex = "#ifdef USE_COLOR\r\n\r\n\tvColor.xyz = color.xyz;\r\n\r\n#endif";

	var common = "#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\r\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\r\nhighp float rand( const in vec2 uv ) {\r\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nstruct IncidentLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n\tbool visible;\r\n};\r\n\r\nstruct ReflectedLight {\r\n\tvec3 directDiffuse;\r\n\tvec3 directSpecular;\r\n\tvec3 indirectDiffuse;\r\n\tvec3 indirectSpecular;\r\n};\r\n\r\nstruct GeometricContext {\r\n\tvec3 position;\r\n\tvec3 normal;\r\n\tvec3 viewDir;\r\n};\r\n\r\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\r\n\r\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\r\n\r\n}\r\n\r\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\r\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n\r\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n\r\n}\r\n\r\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\r\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\r\n\r\n\treturn - distance * planeNormal + point;\r\n\r\n}\r\n\r\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\r\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\r\n\r\n}\r\n\r\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\r\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\r\n\r\n}\r\n\r\nmat3 transposeMat3( const in mat3 m ) {\r\n\r\n\tmat3 tmp;\r\n\r\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\r\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\r\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\r\n\r\n\treturn tmp;\r\n\r\n}\r\n\r\n// https://en.wikipedia.org/wiki/Relative_luminance\r\nfloat linearToRelativeLuminance( const in vec3 color ) {\r\n\r\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\r\n\r\n\treturn dot( weights, color.rgb );\r\n\r\n}\r\n";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\r\n\r\n#define cubeUV_textureSize (1024.0)\r\n\r\nint getFaceFromDirection(vec3 direction) {\r\n\tvec3 absDirection = abs(direction);\r\n\tint face = -1;\r\n\tif( absDirection.x > absDirection.z ) {\r\n\t\tif(absDirection.x > absDirection.y )\r\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\r\n\t\telse\r\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n\t}\r\n\telse {\r\n\t\tif(absDirection.z > absDirection.y )\r\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\r\n\t\telse\r\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n\t}\r\n\treturn face;\r\n}\r\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\r\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\r\n\r\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\r\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\r\n\tfloat dxRoughness = dFdx(roughness);\r\n\tfloat dyRoughness = dFdy(roughness);\r\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\r\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\r\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\r\n\t// Clamp the value to the max mip level counts. hard coded to 6 mips\r\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\r\n\tfloat mipLevel = 0.5 * log2(d);\r\n\treturn vec2(floor(mipLevel), fract(mipLevel));\r\n}\r\n\r\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\r\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\r\n\r\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\r\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\r\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\r\n\r\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\r\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\r\n\t// float powScale = exp2(roughnessLevel + mipLevel);\r\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\r\n\t// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\r\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\r\n\t// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\r\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\r\n\r\n\tbool bRes = mipLevel == 0.0;\r\n\tscale =  bRes && (scale < a) ? a : scale;\r\n\r\n\tvec3 r;\r\n\tvec2 offset;\r\n\tint face = getFaceFromDirection(direction);\r\n\r\n\tfloat rcpPowScale = 1.0 / powScale;\r\n\r\n\tif( face == 0) {\r\n\t\tr = vec3(direction.x, -direction.z, direction.y);\r\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n\t}\r\n\telse if( face == 1) {\r\n\t\tr = vec3(direction.y, direction.x, direction.z);\r\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n\t}\r\n\telse if( face == 2) {\r\n\t\tr = vec3(direction.z, direction.x, direction.y);\r\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n\t}\r\n\telse if( face == 3) {\r\n\t\tr = vec3(direction.x, direction.z, direction.y);\r\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n\t}\r\n\telse if( face == 4) {\r\n\t\tr = vec3(direction.y, direction.x, -direction.z);\r\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n\t}\r\n\telse {\r\n\t\tr = vec3(direction.z, -direction.x, direction.y);\r\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\r\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n\t}\r\n\tr = normalize(r);\r\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\r\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\r\n\tvec2 base = offset + vec2( texelOffset );\r\n\treturn base + s * ( scale - 2.0 * texelOffset );\r\n}\r\n\r\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\r\n\r\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\r\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\r\n\tfloat r1 = floor(roughnessVal);\r\n\tfloat r2 = r1 + 1.0;\r\n\tfloat t = fract(roughnessVal);\r\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\r\n\tfloat s = mipInfo.y;\r\n\tfloat level0 = mipInfo.x;\r\n\tfloat level1 = level0 + 1.0;\r\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\r\n\r\n\t// round to nearest mipmap if we are not interpolating.\r\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\r\n\r\n\t// Tri linear interpolation.\r\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\r\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\r\n\r\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\r\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\r\n\r\n\tvec4 result = mix(color10, color20, t);\r\n\r\n\treturn vec4(result.rgb, 1.0);\r\n}\r\n\r\n#endif\r\n";

	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\r\n\r\n#ifdef FLIP_SIDED\r\n\r\n\ttransformedNormal = - transformedNormal;\r\n\r\n#endif\r\n";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\r\n\r\n\tuniform sampler2D displacementMap;\r\n\tuniform float displacementScale;\r\n\tuniform float displacementBias;\r\n\r\n#endif\r\n";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\r\n\r\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\r\n\r\n#endif\r\n";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\r\n\r\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\r\n\r\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\r\n\r\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\r\n\r\n#endif\r\n";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\r\n\r\n\tuniform sampler2D emissiveMap;\r\n\r\n#endif\r\n";

	var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n";

	var encodings_pars_fragment = "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\r\n\r\nvec4 LinearToLinear( in vec4 value ) {\r\n\treturn value;\r\n}\r\n\r\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\r\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\r\n}\r\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\r\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\r\n}\r\n\r\nvec4 sRGBToLinear( in vec4 value ) {\r\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\r\n}\r\nvec4 LinearTosRGB( in vec4 value ) {\r\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\r\n}\r\n\r\nvec4 RGBEToLinear( in vec4 value ) {\r\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\r\n}\r\nvec4 LinearToRGBE( in vec4 value ) {\r\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\r\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\r\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\r\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\r\n}\r\n\r\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\r\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\r\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\r\n}\r\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\r\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\r\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\r\n\tM            = ceil( M * 255.0 ) / 255.0;\r\n\treturn vec4( value.rgb / ( M * maxRange ), M );\r\n}\r\n\r\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\r\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\r\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\r\n}\r\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\r\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\r\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\r\n\tD            = min( floor( D ) / 255.0, 1.0 );\r\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\r\n}\r\n\r\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\r\n\r\n// M matrix, for encoding\r\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\r\nvec4 LinearToLogLuv( in vec4 value )  {\r\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\r\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\r\n\tvec4 vResult;\r\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\r\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\r\n\tvResult.w = fract(Le);\r\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\r\n\treturn vResult;\r\n}\r\n\r\n// Inverse M matrix, for decoding\r\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\r\nvec4 LogLuvToLinear( in vec4 value ) {\r\n\tfloat Le = value.z * 255.0 + value.w;\r\n\tvec3 Xp_Y_XYZp;\r\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\r\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\r\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\r\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\r\n\treturn vec4( max(vRGB, 0.0), 1.0 );\r\n}\r\n";

	var envmap_fragment = "#ifdef USE_ENVMAP\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\r\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\r\n\r\n\t\t// Transforming Normal Vectors with the Inverse Transformation\r\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\r\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\r\n\r\n\t\t#endif\r\n\r\n\t#else\r\n\r\n\t\tvec3 reflectVec = vReflect;\r\n\r\n\t#endif\r\n\r\n\t#ifdef ENVMAP_TYPE_CUBE\r\n\r\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\r\n\r\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\r\n\t\tvec2 sampleUV;\r\n\r\n\t\treflectVec = normalize( reflectVec );\r\n\r\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\r\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\r\n\r\n\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\r\n\t\treflectVec = normalize( reflectVec );\r\n\r\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\r\n\r\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\r\n\r\n\t#else\r\n\r\n\t\tvec4 envColor = vec4( 0.0 );\r\n\r\n\t#endif\r\n\r\n\tenvColor = envMapTexelToLinear( envColor );\r\n\r\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\r\n\r\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\r\n\r\n\t#elif defined( ENVMAP_BLENDING_MIX )\r\n\r\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\r\n\r\n\t#elif defined( ENVMAP_BLENDING_ADD )\r\n\r\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\r\n\tuniform float reflectivity;\r\n\tuniform float envMapIntensity;\r\n#endif\r\n\r\n#ifdef USE_ENVMAP\r\n\r\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\r\n\t\tvarying vec3 vWorldPosition;\r\n\t#endif\r\n\r\n\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\tuniform samplerCube envMap;\r\n\t#else\r\n\t\tuniform sampler2D envMap;\r\n\t#endif\r\n\tuniform float flipEnvMap;\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\r\n\t\tuniform float refractionRatio;\r\n\t#else\r\n\t\tvarying vec3 vReflect;\r\n\t#endif\r\n\r\n#endif\r\n";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\t\tvarying vec3 vWorldPosition;\r\n\r\n\t#else\r\n\r\n\t\tvarying vec3 vReflect;\r\n\t\tuniform float refractionRatio;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var envmap_vertex = "#ifdef USE_ENVMAP\r\n\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\r\n\t\tvWorldPosition = worldPosition.xyz;\r\n\r\n\t#else\r\n\r\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\r\n\r\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\r\n\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\r\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var fog_vertex = "\r\n#ifdef USE_FOG\r\nfogDepth = -mvPosition.z;\r\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\r\n\r\n  varying float fogDepth;\r\n\r\n#endif\r\n";

	var fog_fragment = "#ifdef USE_FOG\r\n\r\n\t#ifdef FOG_EXP2\r\n\r\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\r\n\r\n\t#else\r\n\r\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\r\n\r\n#endif\r\n";

	var fog_pars_fragment = "#ifdef USE_FOG\r\n\r\n\tuniform vec3 fogColor;\r\n\tvarying float fogDepth;\r\n\r\n\t#ifdef FOG_EXP2\r\n\r\n\t\tuniform float fogDensity;\r\n\r\n\t#else\r\n\r\n\t\tuniform float fogNear;\r\n\t\tuniform float fogFar;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var gradientmap_pars_fragment = "#ifdef TOON\r\n\r\n\tuniform sampler2D gradientMap;\r\n\r\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\r\n\r\n\t\t// dotNL will be from -1.0 to 1.0\r\n\t\tfloat dotNL = dot( normal, lightDirection );\r\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\r\n\r\n\t\t#ifdef USE_GRADIENTMAP\r\n\r\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\r\n\r\n\t\t#else\r\n\r\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\r\n\r\n\t\t#endif\r\n\r\n\r\n\t}\r\n\r\n#endif\r\n";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\r\n\r\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\r\n\r\n#endif\r\n";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\r\n\r\n\tuniform sampler2D lightMap;\r\n\tuniform float lightMapIntensity;\r\n\r\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\r\n\r\nGeometricContext geometry;\r\ngeometry.position = mvPosition.xyz;\r\ngeometry.normal = normalize( transformedNormal );\r\ngeometry.viewDir = normalize( -mvPosition.xyz );\r\n\r\nGeometricContext backGeometry;\r\nbackGeometry.position = geometry.position;\r\nbackGeometry.normal = -geometry.normal;\r\nbackGeometry.viewDir = geometry.viewDir;\r\n\r\nvLightFront = vec3( 0.0 );\r\n\r\n#ifdef DOUBLE_SIDED\r\n\tvLightBack = vec3( 0.0 );\r\n#endif\r\n\r\nIncidentLight directLight;\r\nfloat dotNL;\r\nvec3 directLightColor_Diffuse;\r\n\r\n#if NUM_POINT_LIGHTS > 0\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\r\n\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if NUM_SPOT_LIGHTS > 0\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\r\n\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#endif\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n\r\n#if NUM_DIR_LIGHTS > 0\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\r\n\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if NUM_HEMI_LIGHTS > 0\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n";

	var lights_pars = "uniform vec3 ambientLightColor;\r\n\r\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\r\n\r\n\tvec3 irradiance = ambientLightColor;\r\n\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\tirradiance *= PI;\r\n\r\n\t#endif\r\n\r\n\treturn irradiance;\r\n\r\n}\r\n\r\n#if NUM_DIR_LIGHTS > 0\r\n\r\n\tstruct DirectionalLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t};\r\n\r\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\r\n\t\tdirectLight.color = directionalLight.color;\r\n\t\tdirectLight.direction = directionalLight.direction;\r\n\t\tdirectLight.visible = true;\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if NUM_POINT_LIGHTS > 0\r\n\r\n\tstruct PointLight {\r\n\t\tvec3 position;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t\tfloat shadowCameraNear;\r\n\t\tfloat shadowCameraFar;\r\n\t};\r\n\r\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\r\n\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\r\n\t\tvec3 lVector = pointLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\r\n\t\tfloat lightDistance = length( lVector );\r\n\r\n\t\tdirectLight.color = pointLight.color;\r\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\r\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if NUM_SPOT_LIGHTS > 0\r\n\r\n\tstruct SpotLight {\r\n\t\tvec3 position;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t};\r\n\r\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\r\n\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\r\n\r\n\t\tvec3 lVector = spotLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\r\n\r\n\t\tif ( angleCos > spotLight.coneCos ) {\r\n\r\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\r\n\r\n\t\t\tdirectLight.color = spotLight.color;\r\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\r\n\t\t\tdirectLight.visible = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdirectLight.color = vec3( 0.0 );\r\n\t\t\tdirectLight.visible = false;\r\n\r\n\t\t}\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n\tstruct RectAreaLight {\r\n\t\tvec3 color;\r\n\t\tvec3 position;\r\n\t\tvec3 halfWidth;\r\n\t\tvec3 halfHeight;\r\n\t};\r\n\r\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\r\n\t// BRDF approximation Texture is 64x64\r\n\tuniform sampler2D ltc_1; // RGBA Float\r\n\tuniform sampler2D ltc_2; // RGBA Float\r\n\r\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\r\n\r\n#endif\r\n\r\n\r\n#if NUM_HEMI_LIGHTS > 0\r\n\r\n\tstruct HemisphereLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 skyColor;\r\n\t\tvec3 groundColor;\r\n\t};\r\n\r\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\r\n\r\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\r\n\r\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\r\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\r\n\r\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\r\n\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\t\tirradiance *= PI;\r\n\r\n\t\t#endif\r\n\r\n\t\treturn irradiance;\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\r\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\r\n\r\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\r\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\r\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec4 envMapColor = vec4( 0.0 );\r\n\r\n\t\t#endif\r\n\r\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\r\n\r\n\t}\r\n\r\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\r\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\r\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\r\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\r\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\r\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\r\n\t\t// clamp to allowable LOD ranges.\r\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\r\n\r\n\t}\r\n\r\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\r\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\r\n\r\n\t\t#else\r\n\r\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\r\n\r\n\t\t#endif\r\n\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\r\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\r\n\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\r\n\t\t\tvec2 sampleUV;\r\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\r\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\r\n\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\r\n\t\t#endif\r\n\r\n\t\treturn envMapColor.rgb * envMapIntensity;\r\n\r\n\t}\r\n\r\n#endif\r\n";

	var lights_phong_fragment = "BlinnPhongMaterial material;\r\nmaterial.diffuseColor = diffuseColor.rgb;\r\nmaterial.specularColor = specular;\r\nmaterial.specularShininess = shininess;\r\nmaterial.specularStrength = specularStrength;\r\n";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n\r\nstruct BlinnPhongMaterial {\r\n\r\n\tvec3\tdiffuseColor;\r\n\tvec3\tspecularColor;\r\n\tfloat\tspecularShininess;\r\n\tfloat\tspecularStrength;\r\n\r\n};\r\n\r\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\t#ifdef TOON\r\n\r\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\r\n\r\n\t#else\r\n\r\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\r\n\t\tvec3 irradiance = dotNL * directLight.color;\r\n\r\n\t#endif\r\n\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\tirradiance *= PI; // punctual light\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\r\n\r\n}\r\n\r\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n}\r\n\r\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\r\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\r\n\r\n#define Material_LightProbeLOD( material )\t(0)\r\n";

	var lights_physical_fragment = "PhysicalMaterial material;\r\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\r\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\r\n#ifdef STANDARD\r\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\r\n#else\r\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\r\n\tmaterial.clearCoat = saturate( clearCoat ); // Burley clearcoat model\r\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\r\n#endif\r\n";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\r\n\r\n\tvec3\tdiffuseColor;\r\n\tfloat\tspecularRoughness;\r\n\tvec3\tspecularColor;\r\n\r\n\t#ifndef STANDARD\r\n\t\tfloat clearCoat;\r\n\t\tfloat clearCoatRoughness;\r\n\t#endif\r\n\r\n};\r\n\r\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\r\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\r\n\r\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\r\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\r\n\r\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\r\n\r\n}\r\n\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\t\tvec3 normal = geometry.normal;\r\n\t\tvec3 viewDir = geometry.viewDir;\r\n\t\tvec3 position = geometry.position;\r\n\t\tvec3 lightPos = rectAreaLight.position;\r\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\r\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\r\n\t\tvec3 lightColor = rectAreaLight.color;\r\n\t\tfloat roughness = material.specularRoughness;\r\n\r\n\t\tvec3 rectCoords[ 4 ];\r\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight; // counterclockwise\r\n\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\r\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\r\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\r\n\r\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\r\n\r\n\t\tvec4 t1 = texture2D( ltc_1, uv );\r\n\t\tvec4 t2 = texture2D( ltc_2, uv );\r\n\r\n\t\tmat3 mInv = mat3(\r\n\t\t\tvec3( t1.x, 0, t1.y ),\r\n\t\t\tvec3(    0, 1,    0 ),\r\n\t\t\tvec3( t1.z, 0, t1.w )\r\n\t\t);\r\n\r\n\t\t// LTC Fresnel Approximation by Stephen Hill\r\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\r\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\r\n\r\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\r\n\r\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\r\n\r\n\tvec3 irradiance = dotNL * directLight.color;\r\n\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\tirradiance *= PI; // punctual light\r\n\r\n\t#endif\r\n\r\n\t#ifndef STANDARD\r\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\r\n\t#else\r\n\t\tfloat clearCoatDHR = 0.0;\r\n\t#endif\r\n\r\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\r\n\r\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n\t#ifndef STANDARD\r\n\r\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\r\n\r\n\t#endif\r\n\r\n}\r\n\r\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\r\n}\r\n\r\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n\t#ifndef STANDARD\r\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\t\tfloat dotNL = dotNV;\r\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\r\n\t#else\r\n\t\tfloat clearCoatDHR = 0.0;\r\n\t#endif\r\n\r\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\r\n\r\n\t#ifndef STANDARD\r\n\r\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\r\n\r\n\t#endif\r\n\r\n}\r\n\r\n#define RE_Direct\t\t\t\tRE_Direct_Physical\r\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\r\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\r\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\r\n\r\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\r\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\r\n\r\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\r\n\r\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\r\n\r\n}\r\n";

	var lights_template = "\r\n\r\nGeometricContext geometry;\r\n\r\ngeometry.position = - vViewPosition;\r\ngeometry.normal = normal;\r\ngeometry.viewDir = normalize( vViewPosition );\r\n\r\nIncidentLight directLight;\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tPointLight pointLight;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\r\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\r\n\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tSpotLight spotLight;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\r\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\r\n\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tDirectionalLight directionalLight;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\r\n\tRectAreaLight rectAreaLight;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n\t\trectAreaLight = rectAreaLights[ i ];\r\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#ifdef USE_LIGHTMAP\r\n\r\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\r\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\r\n\r\n\t\t#endif\r\n\r\n\t\tirradiance += lightMapIrradiance;\r\n\r\n\t#endif\r\n\r\n\t#if ( NUM_HEMI_LIGHTS > 0 )\r\n\r\n\t\t#pragma unroll_loop\r\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n\r\n\t\t// TODO, replace 8 with the real maxMIPLevel\r\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\r\n\r\n\t#endif\r\n\r\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\r\n\r\n#endif\r\n\r\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\r\n\r\n\t// TODO, replace 8 with the real maxMIPLevel\r\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\r\n\r\n\t#ifndef STANDARD\r\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\r\n\t#else\r\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\r\n\t#endif\r\n\r\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\r\n\r\n#endif\r\n";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\r\n\r\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\r\n\r\n#endif";

	var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\r\n\r\n\tuniform float logDepthBufFC;\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tvarying float vFragDepth;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tvarying float vFragDepth;\r\n\r\n\t#endif\r\n\r\n\tuniform float logDepthBufFC;\r\n\r\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\r\n\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\r\n\t\tvFragDepth = 1.0 + gl_Position.w;\r\n\r\n\t#else\r\n\r\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\r\n\r\n\t\tgl_Position.z *= gl_Position.w;\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var map_fragment = "#ifdef USE_MAP\r\n\r\n\tvec4 texelColor = texture2D( map, vUv );\r\n\r\n\ttexelColor = mapTexelToLinear( texelColor );\r\n\tdiffuseColor *= texelColor;\r\n\r\n#endif\r\n";

	var map_pars_fragment = "#ifdef USE_MAP\r\n\r\n\tuniform sampler2D map;\r\n\r\n#endif\r\n";

	var map_particle_fragment = "#ifdef USE_MAP\r\n\r\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\r\n\tvec4 mapTexel = texture2D( map, uv );\r\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\r\n\r\n#endif\r\n";

	var map_particle_pars_fragment = "#ifdef USE_MAP\r\n\r\n\tuniform mat3 uvTransform;\r\n\tuniform sampler2D map;\r\n\r\n#endif\r\n";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\r\n\r\n#ifdef USE_METALNESSMAP\r\n\r\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\r\n\r\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\r\n\tmetalnessFactor *= texelMetalness.b;\r\n\r\n#endif\r\n";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\r\n\r\n\tuniform sampler2D metalnessMap;\r\n\r\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\r\n\r\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\r\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\r\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\r\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\r\n\r\n#endif\r\n";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\r\n\r\n\t#ifndef USE_MORPHNORMALS\r\n\r\n\tuniform float morphTargetInfluences[ 8 ];\r\n\r\n\t#else\r\n\r\n\tuniform float morphTargetInfluences[ 4 ];\r\n\r\n\t#endif\r\n\r\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\r\n\r\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\r\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\r\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\r\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\r\n\r\n\t#ifndef USE_MORPHNORMALS\r\n\r\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\r\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\r\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\r\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var normal_fragment = "#ifdef FLAT_SHADED\r\n\r\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\r\n\r\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\r\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\r\n\tvec3 normal = normalize( cross( fdx, fdy ) );\r\n\r\n#else\r\n\r\n\tvec3 normal = normalize( vNormal );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#ifdef USE_NORMALMAP\r\n\r\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\r\n\r\n#elif defined( USE_BUMPMAP )\r\n\r\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\r\n\r\n#endif\r\n";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\r\n\r\n\tuniform sampler2D normalMap;\r\n\tuniform vec2 normalScale;\r\n\r\n\t// Per-Pixel Tangent Space Normal Mapping\r\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\r\n\r\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\r\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\r\n\t\tvec2 st0 = dFdx( vUv.st );\r\n\t\tvec2 st1 = dFdy( vUv.st );\r\n\r\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\r\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\r\n\t\tvec3 N = normalize( surf_norm );\r\n\r\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\r\n\t\tmapN.xy = normalScale * mapN.xy;\r\n\t\tmat3 tsn = mat3( S, T, N );\r\n\t\treturn normalize( tsn * mapN );\r\n\r\n\t}\r\n\r\n#endif\r\n";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\r\n\treturn normalize( normal ) * 0.5 + 0.5;\r\n}\r\n\r\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\r\n\treturn 2.0 * rgb.xyz - 1.0;\r\n}\r\n\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\nconst float ShiftRight8 = 1. / 256.;\r\n\r\nvec4 packDepthToRGBA( const in float v ) {\r\n\tvec4 r = vec4( fract( v * PackFactors ), v );\r\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n\treturn r * PackUpscale;\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n\treturn dot( v, UnpackFactors );\r\n}\r\n\r\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\r\n\r\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\r\n\treturn ( viewZ + near ) / ( near - far );\r\n}\r\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\r\n\treturn linearClipZ * ( near - far ) - near;\r\n}\r\n\r\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\r\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\r\n}\r\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\r\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\r\n}\r\n";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\r\n\r\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\r\n\tgl_FragColor.rgb *= gl_FragColor.a;\r\n\r\n#endif\r\n";

	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\r\n\r\ngl_Position = projectionMatrix * mvPosition;\r\n";

	var dithering_fragment = "#if defined( DITHERING )\r\n\r\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\r\n\r\n#endif\r\n";

	var dithering_pars_fragment = "#if defined( DITHERING )\r\n\r\n\t// based on https://www.shadertoy.com/view/MslGR8\r\n\tvec3 dithering( vec3 color ) {\r\n\t\t//Calculate grid position\r\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\r\n\r\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\r\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n\r\n\t\t//modify shift acording to grid position.\r\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n\r\n\t\t//shift the color by dither_shift\r\n\t\treturn color + dither_shift_RGB;\r\n\t}\r\n\r\n#endif\r\n";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\r\n\r\n#ifdef USE_ROUGHNESSMAP\r\n\r\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\r\n\r\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\r\n\troughnessFactor *= texelRoughness.g;\r\n\r\n#endif\r\n";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\r\n\r\n\tuniform sampler2D roughnessMap;\r\n\r\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\r\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\r\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\r\n\r\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n\r\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\r\n\t}\r\n\r\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\r\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\r\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\r\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\r\n\t\tvec2 f = fract( uv * size + 0.5 );\r\n\r\n\t\tfloat a = mix( lb, lt, f.y );\r\n\t\tfloat b = mix( rb, rt, f.y );\r\n\t\tfloat c = mix( a, b, f.x );\r\n\r\n\t\treturn c;\r\n\r\n\t}\r\n\r\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\r\n\t\tfloat shadow = 1.0;\r\n\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tshadowCoord.z += shadowBias;\r\n\r\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t// if ( all( something, something ) ) using this instead\r\n\r\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\tif ( frustumTest ) {\r\n\r\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\tshadow = (\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\r\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\r\n\t\t\tshadow = (\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t#else // no percentage-closer filtering:\r\n\r\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\r\n\t\t#endif\r\n\r\n\t\t}\r\n\r\n\t\treturn shadow;\r\n\r\n\t}\r\n\r\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\r\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\r\n\t// 2D texture:\r\n\t//\r\n\t// xzXZ\r\n\t//  y Y\r\n\t//\r\n\t// Y - Positive y direction\r\n\t// y - Negative y direction\r\n\t// X - Positive x direction\r\n\t// x - Negative x direction\r\n\t// Z - Positive z direction\r\n\t// z - Negative z direction\r\n\t//\r\n\t// Source and test bed:\r\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\r\n\r\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\r\n\r\n\t\t// Number of texels to avoid at the edge of each square\r\n\r\n\t\tvec3 absV = abs( v );\r\n\r\n\t\t// Intersect unit cube\r\n\r\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\r\n\t\tabsV *= scaleToCube;\r\n\r\n\t\t// Apply scale to avoid seams\r\n\r\n\t\t// two texels less per square (one texel will do for NEAREST)\r\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\r\n\r\n\t\t// Unwrap\r\n\r\n\t\t// space: -1 ... 1 range for each square\r\n\t\t//\r\n\t\t// #X##\t\tdim    := ( 4 , 2 )\r\n\t\t//  # #\t\tcenter := ( 1 , 1 )\r\n\r\n\t\tvec2 planar = v.xy;\r\n\r\n\t\tfloat almostATexel = 1.5 * texelSizeY;\r\n\t\tfloat almostOne = 1.0 - almostATexel;\r\n\r\n\t\tif ( absV.z >= almostOne ) {\r\n\r\n\t\t\tif ( v.z > 0.0 )\r\n\t\t\t\tplanar.x = 4.0 - v.x;\r\n\r\n\t\t} else if ( absV.x >= almostOne ) {\r\n\r\n\t\t\tfloat signX = sign( v.x );\r\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\r\n\r\n\t\t} else if ( absV.y >= almostOne ) {\r\n\r\n\t\t\tfloat signY = sign( v.y );\r\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\r\n\t\t\tplanar.y = v.z * signY - 2.0;\r\n\r\n\t\t}\r\n\r\n\t\t// Transform to UV space\r\n\r\n\t\t// scale := 0.5 / dim\r\n\t\t// translate := ( center + 0.5 ) / dim\r\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\r\n\r\n\t}\r\n\r\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\r\n\r\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\r\n\r\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\r\n\t\t// the vector from the light to the world-space position of the fragment.\r\n\t\tvec3 lightToPosition = shadowCoord.xyz;\r\n\r\n\t\t// dp = normalized distance from light to fragment position\r\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\r\n\t\tdp += shadowBias;\r\n\r\n\t\t// bd3D = base direction 3D\r\n\t\tvec3 bd3D = normalize( lightToPosition );\r\n\r\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\r\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\r\n\r\n\t\t\treturn (\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\r\n\t\t#else // no percentage-closer filtering\r\n\r\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n#endif\r\n";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\r\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\r\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\r\n\r\n\t#endif\r\n\r\n\r\n\r\n#endif\r\n";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\r\n\r\n#endif\r\n";

	var shadowmask_pars_fragment = "float getShadowMask() {\r\n\r\n\tfloat shadow = 1.0;\r\n\r\n\t#ifdef USE_SHADOWMAP\r\n\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\r\n\tDirectionalLight directionalLight;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\r\n\tSpotLight spotLight;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\r\n\tPointLight pointLight;\r\n\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\r\n\r\n\t}\r\n\r\n\t#endif\r\n\r\n\r\n\r\n\t#endif\r\n\r\n\treturn shadow;\r\n\r\n}\r\n";

	var skinbase_vertex = "#ifdef USE_SKINNING\r\n\r\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\r\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\r\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\r\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\r\n\r\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\r\n\r\n\tuniform mat4 bindMatrix;\r\n\tuniform mat4 bindMatrixInverse;\r\n\r\n\t#ifdef BONE_TEXTURE\r\n\r\n\t\tuniform sampler2D boneTexture;\r\n\t\tuniform int boneTextureSize;\r\n\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\r\n\t\t\tfloat j = i * 4.0;\r\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\r\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\r\n\r\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\r\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\r\n\r\n\t\t\ty = dy * ( y + 0.5 );\r\n\r\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\r\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\r\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\r\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\r\n\r\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\r\n\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\r\n\t#else\r\n\r\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\r\n\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\r\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\r\n\t#endif\r\n\r\n#endif\r\n";

	var skinning_vertex = "#ifdef USE_SKINNING\r\n\r\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\r\n\r\n\tvec4 skinned = vec4( 0.0 );\r\n\tskinned += boneMatX * skinVertex * skinWeight.x;\r\n\tskinned += boneMatY * skinVertex * skinWeight.y;\r\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\r\n\tskinned += boneMatW * skinVertex * skinWeight.w;\r\n\r\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\r\n\r\n#endif\r\n";

	var skinnormal_vertex = "#ifdef USE_SKINNING\r\n\r\n\tmat4 skinMatrix = mat4( 0.0 );\r\n\tskinMatrix += skinWeight.x * boneMatX;\r\n\tskinMatrix += skinWeight.y * boneMatY;\r\n\tskinMatrix += skinWeight.z * boneMatZ;\r\n\tskinMatrix += skinWeight.w * boneMatW;\r\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\r\n\r\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\r\n\r\n#endif\r\n";

	var specularmap_fragment = "float specularStrength;\r\n\r\n#ifdef USE_SPECULARMAP\r\n\r\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\r\n\tspecularStrength = texelSpecular.r;\r\n\r\n#else\r\n\r\n\tspecularStrength = 1.0;\r\n\r\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\r\n\r\n\tuniform sampler2D specularMap;\r\n\r\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\r\n\r\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\r\n\r\n#endif\r\n";

	var tonemapping_pars_fragment = "#ifndef saturate\r\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#endif\r\n\r\nuniform float toneMappingExposure;\r\nuniform float toneMappingWhitePoint;\r\n\r\n// exposure only\r\nvec3 LinearToneMapping( vec3 color ) {\r\n\r\n\treturn toneMappingExposure * color;\r\n\r\n}\r\n\r\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\r\nvec3 ReinhardToneMapping( vec3 color ) {\r\n\r\n\tcolor *= toneMappingExposure;\r\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\r\n\r\n}\r\n\r\n// source: http://filmicgames.com/archives/75\r\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\r\nvec3 Uncharted2ToneMapping( vec3 color ) {\r\n\r\n\t// John Hable's filmic operator from Uncharted 2 video game\r\n\tcolor *= toneMappingExposure;\r\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\r\n\r\n}\r\n\r\n// source: http://filmicgames.com/archives/75\r\nvec3 OptimizedCineonToneMapping( vec3 color ) {\r\n\r\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n\tcolor *= toneMappingExposure;\r\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\r\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\r\n\r\n}\r\n";

	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\r\n\r\n\tvarying vec2 vUv;\r\n\r\n#endif";

	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\r\n\r\n\tvarying vec2 vUv;\r\n\tuniform mat3 uvTransform;\r\n\r\n#endif\r\n";

	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\r\n\r\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\r\n\r\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\r\n\tvarying vec2 vUv2;\r\n\r\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\r\n\tattribute vec2 uv2;\r\n\tvarying vec2 vUv2;\r\n\r\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\r\n\tvUv2 = uv2;\r\n\r\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\r\n\r\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\r\n#endif\r\n";

	var cube_frag = "uniform samplerCube tCube;\r\nuniform float tFlip;\r\nuniform float opacity;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tgl_FragColor.a *= opacity;\r\n\r\n}\r\n";

	var cube_vert = "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_Position.z = gl_Position.w; // set z to camera.far\r\n\r\n}\r\n";

	var depth_frag = "#if DEPTH_PACKING == 3200\r\n\r\n\tuniform float opacity;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tdiffuseColor.a = opacity;\r\n\r\n\t#endif\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\r\n\r\n\t#elif DEPTH_PACKING == 3201\r\n\r\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n\r\n\t#endif\r\n\r\n}\r\n";

	var depth_vert = "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n";

	var distanceRGBA_frag = "#define DISTANCE\r\n\r\nuniform vec3 referencePosition;\r\nuniform float nearDistance;\r\nuniform float farDistance;\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main () {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\tfloat dist = length( vWorldPosition - referencePosition );\r\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\r\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\r\n\r\n\tgl_FragColor = packDepthToRGBA( dist );\r\n\r\n}\r\n";

	var distanceRGBA_vert = "#define DISTANCE\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvWorldPosition = worldPosition.xyz;\r\n\r\n}\r\n";

	var equirect_frag = "uniform sampler2D tEquirect;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvec3 direction = normalize( vWorldPosition );\r\n\r\n\tvec2 sampleUV;\r\n\r\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\r\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n}\r\n";

	var equirect_vert = "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n";

	var linedashed_frag = "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform float dashSize;\r\nuniform float totalSize;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

	var linedashed_vert = "uniform float scale;\r\nattribute float lineDistance;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\r\n\tvLineDistance = scale * lineDistance;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n";

	var meshbasic_frag = "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n\t// accumulation (baked indirect lighting only)\r\n\t#ifdef USE_LIGHTMAP\r\n\r\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n\r\n\t#endif\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

	var meshbasic_vert = "#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_ENVMAP\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n";

	var meshlambert_frag = "uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#include <lightmap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n";

	var meshlambert_vert = "#define LAMBERT\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <lights_lambert_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n";

	var meshphong_frag = "#define PHONG\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <gradientmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <lights_phong_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <normal_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_phong_fragment>\r\n\t#include <lights_template>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n";

	var meshphong_vert = "#define PHONG\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n";

	var meshphysical_frag = "#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n\tuniform float clearCoat;\r\n\tuniform float clearCoatRoughness;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <lights_pars>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_template>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n";

	var meshphysical_vert = "#define PHYSICAL\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n";

	var normal_frag = "#define NORMAL\r\n\r\nuniform float opacity;\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <normal_fragment>\r\n\r\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\r\n\r\n}\r\n";

	var normal_vert = "#define NORMAL\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n#endif\r\n\r\n}\r\n";

	var points_frag = "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_particle_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

	var points_vert = "uniform float size;\r\nuniform float scale;\r\n\r\n#include <common>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\t#ifdef USE_SIZEATTENUATION\r\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\r\n\t#else\r\n\t\tgl_PointSize = size;\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n";

	var shadow_frag = "uniform vec3 color;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\r\n\r\n\t#include <fog_fragment>\r\n\r\n}\r\n";

	var shadow_vert = "#include <fog_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars: lights_pars,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_template: lights_template,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment: normal_fragment,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	var ShaderLib = {

		basic: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		points: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: UniformsUtils.merge( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new Vector3();
		var spriteRotation = new Quaternion();
		var spriteScale = new Vector3();

		function init() {

			var vertices = new Float32Array( [
				- 0.5, - 0.5, 0, 0,
				  0.5, - 0.5, 1, 0,
				  0.5, 0.5, 1, 1,
				- 0.5, 0.5, 0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position: gl.getAttribLocation( program, 'position' ),
				uv: gl.getAttribLocation( program, 'uv' )
			};

			uniforms = {
				uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
				uvScale: gl.getUniformLocation( program, 'uvScale' ),

				rotation: gl.getUniformLocation( program, 'rotation' ),
				center: gl.getUniformLocation( program, 'center' ),
				scale: gl.getUniformLocation( program, 'scale' ),

				color: gl.getUniformLocation( program, 'color' ),
				map: gl.getUniformLocation( program, 'map' ),
				opacity: gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType: gl.getUniformLocation( program, 'fogType' ),
				fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
				fogNear: gl.getUniformLocation( program, 'fogNear' ),
				fogFar: gl.getUniformLocation( program, 'fogFar' ),
				fogColor: gl.getUniformLocation( program, 'fogColor' ),
				fogDepth: gl.getUniformLocation( program, 'fogDepth' ),

				alphaTest: gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new CanvasTexture( canvas );

		}

		this.render = function ( sprites, scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			state.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog.isFog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog.isFogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];
			var center = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				if ( material.visible === false ) continue;

				sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				center[ 0 ] = sprite.center.x - 0.5;
				center[ 1 ] = sprite.center.y - 0.5;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.center, center );
				gl.uniform2fv( uniforms.scale, scale );

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
				state.buffers.depth.setTest( material.depthTest );
				state.buffers.depth.setMask( material.depthWrite );
				state.buffers.color.setMask( material.colorWrite );

				textures.setTexture2D( material.map || texture, 0 );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

				sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );

			}

			// restore gl

			state.enable( gl.CULL_FACE );

			state.reset();

		};

		function createProgram() {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + capabilities.precision + ' float;',

				'#define SHADER_NAME ' + 'SpriteMaterial',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 center;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',
				'varying float fogDepth;',

				'void main() {',

				'	vUV = uvOffset + uv * uvScale;',

				'	vec2 alignedPosition = ( position - center ) * scale;',

				'	vec2 rotatedPosition;',
				'	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'	vec4 mvPosition;',

				'	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'	mvPosition.xy += rotatedPosition;',

				'	gl_Position = projectionMatrix * mvPosition;',

				'	fogDepth = - mvPosition.z;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + capabilities.precision + ' float;',

				'#define SHADER_NAME ' + 'SpriteMaterial',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',
				'varying float fogDepth;',

				'void main() {',

				'	vec4 texture = texture2D( map, vUV );',

				'	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'	if ( gl_FragColor.a < alphaTest ) discard;',

				'	if ( fogType > 0 ) {',

				'		float fogFactor = 0.0;',

				'		if ( fogType == 1 ) {',

				'			fogFactor = smoothstep( fogNear, fogFar, fogDepth );',

				'		} else {',

				'			const float LOG2 = 1.442695;',
				'			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
				'			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

				'		}',

				'		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',

				'	}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		}

		function painterSortStable( a, b ) {

			if ( a.renderOrder !== b.renderOrder ) {

				return a.renderOrder - b.renderOrder;

			} else if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this.userData = {};

		this.needsUpdate = true;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function () {},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else if ( key === 'overdraw' ) {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}
			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale.toArray();

			}
			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}
			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.overdraw = source.overdraw;

			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

			this.clippingPlanes = dstPlanes;

			this.shadowSide = source.shadowSide;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	};

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}

	Object.assign( Box3.prototype, {

		isBox3: true,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromArray: function ( array ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromBufferAttribute: function ( attribute ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector3();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		getCenter: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		expandByObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var scope, i, l;

			var v1 = new Vector3();

			function traverse( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			}

			return function expandByObject( object ) {

				scope = this;

				object.updateMatrixWorld( true );

				object.traverse( traverse );

				return this;

			};

		}(),

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		intersectsBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		},

		intersectsSphere: ( function () {

			var closestPoint = new Vector3();

			return function intersectsSphere( sphere ) {

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

			};

		} )(),

		intersectsPlane: function ( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= plane.constant && max >= plane.constant );

		},

		intersectsTriangle: ( function () {

			// triangle centered vertices
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			// triangle edge vectors
			var f0 = new Vector3();
			var f1 = new Vector3();
			var f2 = new Vector3();

			var testAxis = new Vector3();

			var center = new Vector3();
			var extents = new Vector3();

			var triangleNormal = new Vector3();

			function satForAxes( axes ) {

				var i, j;

				for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

					testAxis.fromArray( axes, i );
					// project the aabb onto the seperating axis
					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
					// project all 3 vertices of the triangle onto the seperating axis
					var p0 = v0.dot( testAxis );
					var p1 = v1.dot( testAxis );
					var p2 = v2.dot( testAxis );
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;

					}

				}

				return true;

			}

			return function intersectsTriangle( triangle ) {

				if ( this.isEmpty() ) {

					return false;

				}

				// compute box center and extents
				this.getCenter( center );
				extents.subVectors( this.max, center );

				// translate triangle to aabb origin
				v0.subVectors( triangle.a, center );
				v1.subVectors( triangle.b, center );
				v2.subVectors( triangle.c, center );

				// compute edge vectors for triangle
				f0.subVectors( v1, v0 );
				f1.subVectors( v2, v1 );
				f2.subVectors( v0, v2 );

				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
				];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors( f0, f1 );
				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
				return satForAxes( axes );

			};

		} )(),

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector3();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new Vector3();

			return function getBoundingSphere( optionalTarget ) {

				var result = optionalTarget || new Sphere();

				this.getCenter( result.center );

				result.radius = this.getSize( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3()
			];

			return function applyMatrix4( matrix ) {

				// transform of empty box is an empty box.
				if ( this.isEmpty() ) return this;

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	}

	Object.assign( Sphere.prototype, {

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new Box3();

			return function setFromPoints( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).getCenter( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		intersectsBox: function ( box ) {

			return box.intersectsSphere( this );

		},

		intersectsPlane: function ( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new Vector3();

			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Plane( normal, constant ) {

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	Object.assign( Plane.prototype, {

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function setFromCoplanarPoints( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function () {

			var v1 = new Vector3();

			return function intersectLine( line, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new Vector3();
			var m1 = new Matrix3();

			return function applyMatrix4( matrix, optionalNormalMatrix ) {

				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

				this.constant = - referencePoint.dot( normal );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	function Frustum( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	Object.assign( Frustum.prototype, {

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new Sphere();

			return function intersectsObject( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSprite: function () {

			var sphere = new Sphere();

			return function intersectsSprite( sprite ) {

				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new Vector3(),
				p2 = new Vector3();

			return function intersectsBox( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),

		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];

		// init

		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;

			var depthMaterial = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ i ] = depthMaterial;

			//

			var distanceMaterial = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ i ] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			// TODO Clean up (needed in case of contextlost)
			var _gl = _renderer.context;
			var _state = _renderer.state;

			// Set GL state for depth map.
			_state.disable( _gl.BLEND );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			var faceCount;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light && light.isPointLight;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				var shadowCamera = shadow.camera;

				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );

				if ( isPointLight ) {

					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;

				}

				if ( shadow.map === null ) {

					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + ".shadowMap";

					shadowCamera.updateProjectionMatrix();

				}

				if ( shadow.isSpotLightShadow ) {

					shadow.update( light );

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				if ( isPointLight ) {

					faceCount = 6;

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position

					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

				} else {

					faceCount = 1;

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				}

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();

						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );

					}

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					renderObject( scene, camera, shadowCamera, isPointLight );

				}

			}

			scope.needsUpdate = false;

		};

		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

			var geometry = object.geometry;

			var result = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if ( isPointLight ) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if ( ! customMaterial ) {

				var useMorphing = false;

				if ( material.morphTargets ) {

					if ( geometry && geometry.isBufferGeometry ) {

						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

					} else if ( geometry && geometry.isGeometry ) {

						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

					}

				}

				if ( object.isSkinnedMesh && material.skinning === false ) {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

				var useSkinning = object.isSkinnedMesh && material.skinning;

				var variantIndex = 0;

				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;

				result = materialVariants[ variantIndex ];

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( isPointLight && result.isMeshDistanceMaterial ) {

				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, isPointLight ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					var geometry = _objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, isPointLight );

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes( gl ) {

		var buffers = {};

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = gl.FLOAT;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				type = gl.UNSIGNED_SHORT;

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( attribute.dynamic === false ) {

				gl.bufferData( bufferType, array, gl.STATIC_DRAW );

			} else if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else if ( updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers[ attribute.uuid ];

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers[ attribute.uuid ];

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				delete buffers[ attribute.uuid ];

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers[ attribute.uuid ];

			if ( data === undefined ) {

				buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Euler( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;

	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties( Euler.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Euler.prototype, {

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = _Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix = new Matrix4();

			return function setFromQuaternion( q, order, update ) {

				matrix.makeRotationFromQuaternion( q );

				return this.setFromRotationMatrix( matrix, order, update );

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new Quaternion();

			return function reorder( newOrder ) {

				q.setFromEuler( this );

				return this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {

		this.mask = 1 | 0;

	}

	Object.assign( Layers.prototype, {

		set: function ( channel ) {

			this.mask = 1 << channel | 0;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel | 0;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel | 0;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		},

		test: function ( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	var object3DId = 0;

	function Object3D() {

		Object.defineProperty( this, 'id', { value: object3DId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new Quaternion();

			return function rotateOnAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateOnWorldAxis: function () {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			var q1 = new Quaternion();

			return function rotateOnWorldAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.premultiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function rotateX( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function rotateY( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function rotateZ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new Vector3();

			return function translateOnAxis( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function translateX( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function translateY( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function translateZ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new Matrix4();

			return function worldToLocal( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This method does not support objects with rotated and/or translated parent(s)

			var m1 = new Matrix4();
			var vector = new Vector3();

			return function lookAt( x, y, z ) {

				if ( x.isVector3 ) {

					vector.copy( x );

				} else {

					vector.set( x, y, z );

				}

				if ( this.isCamera ) {

					m1.lookAt( this.position, vector, this.up );

				} else {

					m1.lookAt( vector, this.position, this.up );

				}

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( ( object && object.isObject3D ) ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new Vector3();
			var scale = new Vector3();

			return function getWorldQuaternion( optionalTarget ) {

				var result = optionalTarget || new Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			};

		}(),

		getWorldRotation: function () {

			var quaternion = new Quaternion();

			return function getWorldRotation( optionalTarget ) {

				var result = optionalTarget || new Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			};

		}(),

		getWorldScale: function () {

			var position = new Vector3();
			var quaternion = new Quaternion();

			return function getWorldScale( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			};

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.matrix = this.matrix.toArray();

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.geometry !== undefined ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();
		this.projectionMatrix = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );

			return this;

		},

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			};

		}(),

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera( left, right, top, bottom, near, far ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;

				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	}

	Object.assign( Face3.prototype, {

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	var geometryId = 0; // Geometry uses even numbers as Id

	function Geometry() {

		Object.defineProperty( this, 'id', { value: geometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

				scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

				if ( uvs2 !== undefined ) {

					tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

				}

			}

			function addFace( a, b, c, materialIndex ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

				}

			}

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						if ( indices !== undefined ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

						} else {

							addFace( j, j + 1, j + 2, group.materialIndex );

						}

					}

				}

			} else {

				if ( indices !== undefined ) {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.getCenter().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new Vector3(), ab = new Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			if ( areaWeighted === undefined ) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeFlatVertexNormals: function () {

			var f, fl, face;

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );

				} else {

					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( ! ( geometry && geometry.isGeometry ) ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// colors

			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

				colors1.push( colors2[ i ].clone() );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( ! ( mesh && mesh.isMesh ) ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		setFromPoints: function ( points ) {

			this.vertices = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return this;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy( this );

		},

		copy: function ( source ) {

			var i, il, j, jl, k, kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			var vertices = source.vertices;

			for ( i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			// colors

			var colors = source.colors;

			for ( i = 0, il = colors.length; i < il; i ++ ) {

				this.colors.push( colors[ i ].clone() );

			}

			// faces

			var faces = source.faces;

			for ( i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			// face vertex uvs

			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			// morph targets

			var morphTargets = source.morphTargets;

			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;

				// vertices

				if ( morphTargets[ i ].vertices !== undefined ) {

					morphTarget.vertices = [];

					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

					}

				}

				// normals

				if ( morphTargets[ i ].normals !== undefined ) {

					morphTarget.normals = [];

					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

					}

				}

				this.morphTargets.push( morphTarget );

			}

			// morph normals

			var morphNormals = source.morphNormals;

			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

				var morphNormal = {};

				// vertex normals

				if ( morphNormals[ i ].vertexNormals !== undefined ) {

					morphNormal.vertexNormals = [];

					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push( destVertexNormal );

					}

				}

				// face normals

				if ( morphNormals[ i ].faceNormals !== undefined ) {

					morphNormal.faceNormals = [];

					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

					}

				}

				this.morphNormals.push( morphNormal );

			}

			// skin weights

			var skinWeights = source.skinWeights;

			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

				this.skinWeights.push( skinWeights[ i ].clone() );

			}

			// skin indices

			var skinIndices = source.skinIndices;

			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

				this.skinIndices.push( skinIndices[ i ].clone() );

			}

			// line distances

			var lineDistances = source.lineDistances;

			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

				this.lineDistances.push( lineDistances[ i ] );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.uuid = _Math.generateUUID();
		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.onUploadCallback = function () {};

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyIndicesArray: function ( indices ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				var index = indices[ i ];

				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectGeometry() {

		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Object.assign( DirectGeometry.prototype, {

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex = undefined;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			var morphTargetsPosition;

			if ( morphTargetsLength > 0 ) {

				morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			var morphTargetsNormal;

			if ( morphNormalsLength > 0 ) {

				morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

		},

		addAttribute: function ( name, attribute ) {

			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

				return;

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return;

			}

			this.attributes[ name ] = attribute;

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.getCenter().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object.isPoints || object.isLine ) {

				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object.isMesh ) {

				var direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			var attribute;

			if ( geometry.verticesNeedUpdate === true ) {

				attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			if ( geometry.indices.length > 0 ) {

				var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

					array.push( attribute.copyVector3sArray( morphTarget ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			var position = this.attributes.position;

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			var box = new Box3();
			var vector = new Vector3();

			return function computeBoundingSphere() {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				var position = this.attributes.position;

				if ( position ) {

					var center = this.boundingSphere.center;

					box.setFromBufferAttribute( position );
					box.getCenter( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = position.count; i < il; i ++ ) {

						vector.x = position.getX( i );
						vector.y = position.getY( i );
						vector.z = position.getZ( i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for ( var i = 0, il = array.length; i < il; i ++ ) {

						array[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					if ( groups.length === 0 ) {

						this.addGroup( 0, indices.length );

					}

					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

						var group = groups[ j ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) offset = 0;

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var vector = new Vector3();

			return function normalizeNormals() {

				var normals = this.attributes.normal;

				for ( var i = 0, il = normals.count; i < il; i ++ ) {

					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );

					vector.normalize();

					normals.setXYZ( i, vector.x, vector.y, vector.z );

				}

			};

		}(),

		toNonIndexed: function () {

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				var array = Array.prototype.slice.call( index.array );

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			var name, i, l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			var attributes = source.attributes;

			for ( name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( name in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone() );

				}

				this.morphAttributes[ name ] = array;

			}

			// groups

			var groups = source.groups;

			for ( i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;

	// BoxBufferGeometry

	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		BufferGeometry.call( this );

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var numberOfVertices = 0;
		var groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var ix, iy;

			var vector = new Vector3();

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segmentHeight - heightHalf;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PlaneGeometry

	function PlaneGeometry( width, height, widthSegments, heightSegments ) {

		Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();

	}

	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;

	// PlaneBufferGeometry

	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

		BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		width = width || 1;
		height = height || 1;

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var ix, iy;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		// indices

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = UniformsUtils.clone( source.uniforms );

		this.defines = source.defines;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Ray( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();

	}

	Object.assign( Ray.prototype, {

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		lookAt: function ( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		},

		recast: function () {

			var v1 = new Vector3();

			return function recast( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new Vector3();

			return function distanceSqToPoint( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();

			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),

		intersectSphere: function () {

			var v1 = new Vector3();

			return function intersectSphere( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, optionalTarget );

		},

		intersectsPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		intersectBox: function ( box, optionalTarget ) {

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectsBox: ( function () {

			var v = new Vector3();

			return function intersectsBox( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		} )(),

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();

			return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Line3( start, end ) {

		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();

	}

	Object.assign( Line3.prototype, {

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		getCenter: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new Vector3();
			var startEnd = new Vector3();

			return function closestPointToPointParameter( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = _Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Triangle( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	Object.assign( Triangle, {

		normal: function () {

			var v0 = new Vector3();

			return function normal( a, b, c, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );

				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {

					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

				}

				return result.set( 0, 0, 0 );

			};

		}(),

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		barycoordFromPoint: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				var result = optionalTarget || new Vector3();

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );

			};

		}(),

		containsPoint: function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

			};

		}()

	} );

	Object.assign( Triangle.prototype, {

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();

			return function area() {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		intersectsBox: function ( box ) {

			return box.intersectsTriangle( this );

		},

		closestPointToPoint: function () {

			var plane = new Plane();
			var edgeList = [ new Line3(), new Line3(), new Line3() ];
			var projectedPoint = new Vector3();
			var closestPoint = new Vector3();

			return function closestPointToPoint( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				var minDistance = Infinity;

				// project the point onto the plane of the triangle

				plane.setFromCoplanarPoints( this.a, this.b, this.c );
				plane.projectPoint( point, projectedPoint );

				// check if the projection lies within the triangle

				if ( this.containsPoint( projectedPoint ) === true ) {

					// if so, this is the closest point

					result.copy( projectedPoint );

				} else {

					// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

					edgeList[ 0 ].set( this.a, this.b );
					edgeList[ 1 ].set( this.b, this.c );
					edgeList[ 2 ].set( this.c, this.a );

					for ( var i = 0; i < edgeList.length; i ++ ) {

						edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

						var distance = projectedPoint.distanceToSquared( closestPoint );

						if ( distance < minDistance ) {

							minDistance = distance;

							result.copy( closestPoint );

						}

					}

				}

				return result;

			};

		}(),

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	function Mesh( geometry, material ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.drawMode = TrianglesDrawMode;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		setDrawMode: function ( value ) {

			this.drawMode = value;

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.drawMode = source.drawMode;

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;
			var m, ml, name;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

						name = morphTargets[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		},

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			var barycoord = new Vector3();

			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();

			function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

				Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

				uv1.multiplyScalar( barycoord.x );
				uv2.multiplyScalar( barycoord.y );
				uv3.multiplyScalar( barycoord.z );

				uv1.add( uv2 ).add( uv3 );

				return uv1.clone();

			}

			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

				var intersect;

				if ( material.side === BackSide ) {

					intersect = ray.intersectTriangle( pC, pB, pA, true, point );

				} else {

					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

				}

				if ( intersect === null ) return null;

				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

				if ( distance < raycaster.near || distance > raycaster.far ) return null;

				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};

			}

			function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );

				var intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );

				if ( intersection ) {

					if ( uv ) {

						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );

						intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

					}

					intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
					intersection.faceIndex = a;

				}

				return intersection;

			}

			return function raycast( raycaster, intersects ) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if ( material === undefined ) return;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				// Check boundingBox before continuing

				if ( geometry.boundingBox !== null ) {

					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

				}

				var intersection;

				if ( geometry.isBufferGeometry ) {

					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var uv = geometry.attributes.uv;
					var i, l;

					if ( index !== null ) {

						// indexed buffer geometry

						for ( i = 0, l = index.count; i < l; i += 3 ) {

							a = index.getX( i );
							b = index.getX( i + 1 );
							c = index.getX( i + 2 );

							intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
								intersects.push( intersection );

							}

						}

					} else if ( position !== undefined ) {

						// non-indexed buffer geometry

						for ( i = 0, l = position.count; i < l; i += 3 ) {

							a = i;
							b = i + 1;
							c = i + 2;

							intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

							if ( intersection ) {

								intersection.index = a; // triangle number in positions buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( geometry.isGeometry ) {

					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;

					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

						if ( faceMaterial === undefined ) continue;

						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];

						if ( faceMaterial.morphTargets === true ) {

							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;

							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );

							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

								var influence = morphInfluences[ t ];

								if ( influence === 0 ) continue;

								var targets = morphTargets[ t ].vertices;

								vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
								vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
								vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

							}

							vA.add( fvA );
							vB.add( fvB );
							vC.add( fvC );

							fvA = vA;
							fvB = vB;
							fvC = vC;

						}

						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

						if ( intersection ) {

							if ( uvs && uvs[ f ] ) {

								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );

								intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );

						}

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeCamera, planeMesh;
		var boxMesh;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.background;

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && background.isCubeTexture ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							uniforms: ShaderLib.cube.uniforms,
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: true,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					geometries.update( boxMesh.geometry );

				}

				boxMesh.material.uniforms.tCube.value = background;

				renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeCamera === undefined ) {

					planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
					);

					geometries.update( planeMesh.geometry );

				}

				planeMesh.material.map = background;

				// TODO Push this to renderList

				renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {

				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program && b.program && a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	function WebGLRenderList() {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function push( object, geometry, material, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			( material.transparent === true ? transparent : opaque ).push( renderItem );

			renderItemsIndex ++;

		}

		function sort() {

			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

		}

		return {
			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		var lists = {};

		function get( scene, camera ) {

			var hash = scene.id + ',' + camera.id;
			var list = lists[ hash ];

			if ( list === undefined ) {

				// console.log( 'THREE.WebGLRenderLists:', hash );

				list = new WebGLRenderList();
				lists[ hash ] = list;

			}

			return list;

		}

		function dispose() {

			lists = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			var length = objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				if ( influence[ 1 ] !== 0 ) {

					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			// Collect influences

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			// Add morphAttributes

			for ( var i = 0; i < 8; i ++ ) {

				var influence = influences[ i ];

				if ( influence ) {

					var index = influence[ 0 ];
					var value = influence[ 1 ];

					if ( value ) {

						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

						morphInfluences[ i ] = value;
						continue;

					}

				}

				morphInfluences[ i ] = 0;

			}

			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			infoRender.calls ++;
			infoRender.vertices += count;

			if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += count;

		}

		function renderInstances( geometry, start, count ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

			infoRender.calls ++;
			infoRender.vertices += count * geometry.maxInstancedCount;

			if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer( gl, extensions, infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			infoRender.calls ++;
			infoRender.vertices += count;

			if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += count;

		}

		function renderInstances( geometry, start, count ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var position = geometry.attributes.position;

			if ( position.isInterleavedBufferAttribute ) {

				count = position.data.count;

				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

			} else {

				extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );

			}

			infoRender.calls ++;
			infoRender.vertices += count * geometry.maxInstancedCount;

			if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries( gl, attributes, infoMemory ) {

		var geometries = {};
		var wireframeAttributes = {};

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( var name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			// TODO Remove duplicate code

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ geometry.id ];

			}

			attribute = wireframeAttributes[ buffergeometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];

			}

			//

			infoMemory.geometries --;

		}

		function get( object, geometry ) {

			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			infoMemory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function getWireframeAttribute( geometry ) {

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) return attribute;

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;

			// console.time( 'wireframe' );

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array = geometryAttributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

			attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

			wireframeAttributes[ geometry.id ] = attribute;

			return attribute;

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects( geometries, infoRender ) {

		var updateList = {};

		function update( object ) {

			var frame = infoRender.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateList[ buffergeometry.id ] !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateList[ buffergeometry.id ] = frame;

			}

			return buffergeometry;

		}

		function dispose() {

			updateList = {};

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	function parseIncludes( string ) {

		var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

		function replace( match, include ) {

			var replace = ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	function WebGLProgram( renderer, extensions, code, material, shader, parameters ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = generateExtensions( material.extensions, parameters, extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program, renderer );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms( renderer, extensions, capabilities ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap", "gradientMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
		];


		function allocateBones( object ) {

			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if ( capabilities.floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

			var encoding;

			if ( ! map ) {

				encoding = LinearEncoding;

			} else if ( map.isTexture ) {

				encoding = map.encoding;

			} else if ( map.isWebGLRenderTarget ) {

				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding && gammaOverrideLinear ) {

				encoding = GammaEncoding;

			}

			return encoding;

		}

		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( material.fragmentShader );
				array.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					array.push( name );
					array.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( material.onBeforeCompile.toString() );

			array.push( renderer.gammaOutput );

			return array.join();

		};

		this.acquireProgram = function ( material, shader, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function ( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory, infoRender ) {

		var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );
		var _videoTextures = {};
		var _canvas;

		//

		function clampToMaxSize( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

		}

		function makePowerOfTwo( image ) {

			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = _Math.floorPowerOfTwo( image.width );
				_canvas.height = _Math.floorPowerOfTwo( image.height );

				var context = _canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, _canvas.width, _canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height, image );

				return _canvas;

			}

			return image;

		}

		function textureNeedsPowerOfTwo( texture ) {

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {

			return texture.generateMipmaps && isPowerOfTwo &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				delete _videoTextures[ texture.id ];

			}

			infoMemory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			infoMemory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( texture.image && textureProperties.__image__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( textureProperties.__image__webglTextureCube );

			} else {

				// 2D texture

				if ( textureProperties.__webglInit === undefined ) return;

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			// remove all webgl properties
			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//



		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					if ( ! textureProperties.__image__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						infoMemory.textures ++;

					}

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = ( texture && texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				}

			}

		}

		function setTextureCubeDynamic( texture, slot ) {

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

		}

		function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

			var extension;

			if ( isPowerOfTwoImage ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				infoMemory.textures ++;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

				image = makePowerOfTwo( image );

			}

			var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				var internalFormat = _gl.DEPTH_COMPONENT;

				if ( texture.type === FloatType ) {

					if ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					internalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( _isWebGL2 ) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					internalFormat = _gl.DEPTH_COMPONENT16;

				}

				if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {

					internalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

					}

				} else {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

				}

			}

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			infoMemory.textures ++;

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

				}

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {

				var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				_gl.generateMipmap( target );
				state.bindTexture( target, null );

			}

		}

		function updateVideoTexture( texture ) {

			var id = texture.id;
			var frame = infoRender.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures[ id ] !== frame ) {

				_videoTextures[ id ] = frame;
				texture.update();

			}

		}

		this.setTexture2D = setTexture2D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;

	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {

		var properties = {};

		function get( object ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			if ( map === undefined ) {

				map = {};
				properties[ uuid ] = map;

			}

			return map;

		}

		function remove( object ) {

			delete properties[ object.uuid ];

		}

		function update( object, key, value ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			map[ key ] = value;

		}

		function dispose() {

			properties = {};

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState( gl, extensions, utils ) {

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( gl.NEVER );
									break;

								case AlwaysDepth:

									gl.depthFunc( gl.ALWAYS );
									break;

								case LessDepth:

									gl.depthFunc( gl.LESS );
									break;

								case LessEqualDepth:

									gl.depthFunc( gl.LEQUAL );
									break;

								case EqualDepth:

									gl.depthFunc( gl.EQUAL );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( gl.GEQUAL );
									break;

								case GreaterDepth:

									gl.depthFunc( gl.GREATER );
									break;

								case NotEqualDepth:

									gl.depthFunc( gl.NOTEQUAL );
									break;

								default:

									gl.depthFunc( gl.LEQUAL );

							}

						} else {

							gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );

		var capabilities = {};

		var compressedTextureFormats = null;

		var currentProgram = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		   version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
		   lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		   version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
		   lineWidthAvailable = ( version >= 2.0 );

		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		enable( gl.BLEND );
		setBlending( NormalBlending );

		//

		function initAttributes() {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== 0 ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				extension.vertexAttribDivisorANGLE( attribute, 0 );
				attributeDivisors[ attribute ] = 0;

			}

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function enable( id ) {

			if ( capabilities[ id ] !== true ) {

				gl.enable( id );
				capabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( capabilities[ id ] !== false ) {

				gl.disable( id );
				capabilities[ id ] = false;

			}

		}

		function getCompressedTextureFormats() {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
				     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending !== NoBlending ) {

				enable( gl.BLEND );

			} else {

				disable( gl.BLEND );

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					switch ( blending ) {

						case AdditiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

							}
							break;

						case SubtractiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

							}
							break;

						case MultiplyBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

							}
							break;

						default:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							}

					}

				}

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			} else {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			material.transparent === true
				? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
				: setBlending( NoBlending );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			capabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		return {

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera( fov, aspect, near, far ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan(
					_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ArrayCamera( array ) {

		PerspectiveCamera.call( this );

		this.cameras = array || [];

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebVRManager( renderer ) {

		var scope = this;

		var device = null;
		var frameData = null;

		var poseTarget = null;

		var standingMatrix = new Matrix4();
		var standingMatrixInverse = new Matrix4();

		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

			frameData = new window.VRFrameData();

		}

		var matrixWorldInverse = new Matrix4();
		var tempQuaternion = new Quaternion();
		var tempPosition = new Vector3();

		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );

		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		var currentSize, currentPixelRatio;

		function onVRDisplayPresentChange() {

			if ( device !== null && device.isPresenting ) {

				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth;
				var renderHeight = eyeParameters.renderHeight;

				currentPixelRatio = renderer.getPixelRatio();
				currentSize = renderer.getSize();

				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

			} else if ( scope.enabled ) {

				renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

			}

		}

		if ( typeof window !== 'undefined' ) {

			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

		}

		//

		this.enabled = false;
		this.userHeight = 1.6;

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;

		};

		this.setPoseTarget = function ( object ) {

			if ( object !== undefined ) poseTarget = object;

		};

		this.getCamera = function ( camera ) {

			if ( device === null ) return camera;

			device.depthNear = camera.near;
			device.depthFar = camera.far;

			device.getFrameData( frameData );

			//

			var stageParameters = device.stageParameters;

			if ( stageParameters ) {

				standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

			} else {

				standingMatrix.makeTranslation( 0, scope.userHeight, 0 );

			}


			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;

			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy( standingMatrix );
			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

			if ( pose.orientation !== null ) {

				tempQuaternion.fromArray ( pose.orientation );
				poseObject.quaternion.multiply( tempQuaternion );

			}

			if ( pose.position !== null ) {

				tempQuaternion.setFromRotationMatrix( standingMatrix );
				tempPosition.fromArray( pose.position );
				tempPosition.applyQuaternion( tempQuaternion );
				poseObject.position.add( tempPosition );

			}

			poseObject.updateMatrixWorld();

			if ( device.isPresenting === false ) return camera;

			//

			cameraL.near = camera.near;
			cameraR.near = camera.near;

			cameraL.far = camera.far;
			cameraR.far = camera.far;

			cameraVR.matrixWorld.copy( camera.matrixWorld );
			cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );

			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

			// TODO (mrdoob) Double check this code

			standingMatrixInverse.getInverse( standingMatrix );

			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

			var parent = poseObject.parent;

			if ( parent !== null ) {

				matrixWorldInverse.getInverse( parent.matrixWorld );

				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

			}

			// envMap and Mirror needs camera.matrixWorld

			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

			// HACK (mrdoob)
			// https://github.com/w3c/webvr/issues/203

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			//

			var layers = device.getLayers();

			if ( layers.length ) {

				var layer = layers[ 0 ];

				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

					cameraL.bounds.fromArray( layer.leftBounds );

				}

				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

					cameraR.bounds.fromArray( layer.rightBounds );

				}

			}

			return cameraVR;

		};

		this.getStandingMatrix = function () {

			return standingMatrix;

		};

		this.submitFrame = function () {

			if ( device && device.isPresenting ) device.submitFrame();

		};

		this.dispose = function () {

			if ( typeof window !== 'undefined' ) {

				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions( gl ) {

		var extensions = {};

		return {

			get: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ];

				}

				var extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					case 'WEBGL_compressed_texture_etc1':
						extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				extensions[ name ] = extension;

				return extension;

			}

		};

	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;

			return dstArray;

		}

	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils( gl, extensions ) {

		function convert( p ) {

			var extension;

			if ( p === RepeatWrapping ) return gl.REPEAT;
			if ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
			if ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;

			if ( p === NearestFilter ) return gl.NEAREST;
			if ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
			if ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;

			if ( p === LinearFilter ) return gl.LINEAR;
			if ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
			if ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) return extension.HALF_FLOAT_OES;

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

			if ( p === AddEquation ) return gl.FUNC_ADD;
			if ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;
			if ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;

			if ( p === ZeroFactor ) return gl.ZERO;
			if ( p === OneFactor ) return gl.ONE;
			if ( p === SrcColorFactor ) return gl.SRC_COLOR;
			if ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
			if ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;
			if ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
			if ( p === DstAlphaFactor ) return gl.DST_ALPHA;
			if ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;

			if ( p === DstColorFactor ) return gl.DST_COLOR;
			if ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
			if ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					return p;

				}

			}

			if ( p === MinEquation || p === MaxEquation ) {

				extension = extensions.get( 'EXT_blend_minmax' );

				if ( extension !== null ) {

					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;

				}

			}

			if ( p === UnsignedInt248Type ) {

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

			}

			return 0;

		}

		return { convert: convert };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function UniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	var count = 0;

	function WebGLLights() {

		var cache = new UniformsCache();

		var state = {

			id: count ++,

			hash: '',

			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights, shadows, camera ) {

			var r = 0, g = 0, b = 0;

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var viewMatrix = camera.matrixWorldInverse;

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isDirectionalLight ) {

					var uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;

					}

					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms = cache.get( light );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.hash = state.id + ',' + directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;

		}

		return {
			setup: setup,
			state: state
		};

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLRenderState() {

		var lights = new WebGLLights();

		var lightsArray = [];
		var shadowsArray = [];
		var spritesArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;
			spritesArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function pushSprite( shadowLight ) {

			spritesArray.push( shadowLight );

		}

		function setupLights( camera ) {

			lights.setup( lightsArray, shadowsArray, camera );

		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			spritesArray: spritesArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,

			pushLight: pushLight,
			pushShadow: pushShadow,
			pushSprite: pushSprite
		};

	}

	function WebGLRenderStates() {

		var renderStates = {};

		function get( scene, camera ) {

			var hash = scene.id + ',' + camera.id;

			var renderState = renderStates[ hash ];

			if ( renderState === undefined ) {

				renderState = new WebGLRenderState();
				renderStates[ hash ] = renderState;

			}

			return renderState;

		}

		function dispose() {

			renderStates = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer( parameters ) {

		console.log( 'THREE.WebGLRenderer', REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

		var currentRenderList = null;
		var currentRenderState = null;

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			_isContextLost = false,

			// internal state cache

			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
			_currentGeometryProgram = '',

			_currentCamera = null,
			_currentArrayCamera = null,

			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			//

			_usedTextureUnits = 0,

			//

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3(),

			// info

			_infoMemory = {
				geometries: 0,
				textures: 0
			},

			_infoRender = {

				frame: 0,
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			};

		this.info = {

			render: _infoRender,
			memory: _infoMemory,
			programs: null,
			autoReset: true,
			reset: resetInfo

		};

		function resetInfo() {

			_infoRender.frame ++;
			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;

		}

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl;

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );

		}

		var extensions, capabilities, state;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;
		var spriteRenderer;

		var utils;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );
			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'OES_element_index_uint' );
			extensions.get( 'ANGLE_instanced_arrays' );

			utils = new WebGLUtils( _gl, extensions );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			state = new WebGLState( _gl, extensions, utils );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory, _infoRender );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, _infoMemory );
			objects = new WebGLObjects( geometries, _infoRender );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();

			background = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

			spriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );

			_this.info.programs = programCache.programs;

			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;

		}

		initGLContext();

		// vr

		var vr = new WebVRManager( _this );

		this.vr = vr;

		// shadow map

		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function ( width, height, updateStyle ) {

			var device = vr.getDevice();

			if ( device && device.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function () {

			return {
				width: _width * _pixelRatio,
				height: _height * _pixelRatio
			};

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function () {

			return _currentViewport;

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewport.set( x, _height - y - height, width, height );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissor = function ( x, y, width, height ) {

			_scissor.set( x, _height - y - height, width, height );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return background.getClearColor();

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();

			vr.dispose();

			stopAnimation();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program, material ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program, material );

			} );

		}

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

				if ( ! material.isMeshPhongMaterial &&
					! material.isMeshStandardMaterial &&
					! material.isMeshNormalMaterial &&
					material.flatShading === true ) {

					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

						var array = object.normalArray;

						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;

						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;

						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.normal );

				_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.uv );

				_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.color );

				_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			state.setMaterial( material, frontFaceCW );

			var program = setProgram( camera, fog, material, object );
			var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );

			var updateBuffers = false;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			if ( object.morphTargetInfluences ) {

				morphtargets.update( object, geometry, material, program );

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

				}

			}

			//

			var dataCount = Infinity;

			if ( index !== null ) {

				dataCount = index.count;

			} else if ( position !== undefined ) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					switch ( object.drawMode ) {

						case TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;

						case TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;

						case TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;

					}

				}


			} else if ( object.isLine ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			}

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry, drawStart, drawCount );

				}

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			if ( startIndex === undefined ) startIndex = 0;

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.traverse( function ( object ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights( camera );

			scene.traverse( function ( object ) {

				if ( object.material ) {

					if ( Array.isArray( object.material ) ) {

						for ( var i = 0; i < object.material.length; i ++ ) {

							initMaterial( object.material[ i ], scene.fog, object );

						}

					} else {

						initMaterial( object.material, scene.fog, object );

					}

				}

			} );

		};

		// Animation Loop

		var isAnimating = false;
		var onAnimationFrame = null;

		function startAnimation() {

			if ( isAnimating ) return;

			requestAnimationLoopFrame();

			isAnimating = true;

		}

		function stopAnimation() {

			isAnimating = false;

		}

		function requestAnimationLoopFrame() {

			var device = vr.getDevice();

			if ( device && device.isPresenting ) {

				device.requestAnimationFrame( animationLoop );

			} else {

				window.requestAnimationFrame( animationLoop );

			}

		}

		function animationLoop( time ) {

			if ( isAnimating === false ) return;

			onAnimationFrame( time );

			requestAnimationLoopFrame();

		}

		this.animate = function ( callback ) {

			onAnimationFrame = callback;
			onAnimationFrame !== null ? startAnimation() : stopAnimation();

		};

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( ! ( camera && camera.isCamera ) ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost ) return;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( vr.enabled ) {

				camera = vr.getCamera( camera );

			}

			//

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.onBeforeRender( _this, scene, camera, renderTarget );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, _this.sortObjects );

			if ( _this.sortObjects === true ) {

				currentRenderList.sort();

			}

			//

			if ( _clippingEnabled ) _clipping.beginShadows();

			var shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights( camera );

			if ( _clippingEnabled ) _clipping.endShadows();

			//

			if ( this.info.autoReset ) this.info.reset();

			if ( renderTarget === undefined ) {

				renderTarget = null;

			}

			this.setRenderTarget( renderTarget );

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

				// transparent pass (back-to-front order)

				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

			}

			// custom renderers

			var spritesArray = currentRenderState.state.spritesArray;

			spriteRenderer.render( spritesArray, scene, camera );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget ) {

				textures.updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			scene.onAfterRender( _this, scene, camera );

			if ( vr.enabled ) {

				vr.submitFrame();

			}

			// _gl.finish();

			currentRenderList = null;
			currentRenderState = null;

		};

		/*
		// TODO Duplicated code (Frustum)

		var _sphere = new Sphere();

		function isObjectViewable( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSpriteViewable( sprite ) {

			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSphereViewable( sphere ) {

			if ( ! _frustum.intersectsSphere( sphere ) ) return false;

			var numPlanes = _clipping.numPlanes;

			if ( numPlanes === 0 ) return true;

			var planes = _this.clippingPlanes,

				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;

			do {

				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

			} while ( ++ i !== numPlanes );

			return true;

		}
		*/

		function projectObject( object, camera, sortObjects ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						currentRenderState.pushSprite( object );

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						object.skeleton.update();

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					_currentArrayCamera = camera;

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							var bounds = camera2.bounds;

							var x = bounds.x * _width;
							var y = bounds.y * _height;
							var width = bounds.z * _width;
							var height = bounds.w * _height;

							state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					_currentArrayCamera = null;

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

				state.setMaterial( material, frontFaceCW );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram = '';

				renderObjectImmediate( object, program, material );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		}

		function initMaterial( material, fog, object ) {

			var materialProperties = properties.get( material );

			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;

			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( materialProperties.lightsHash !== lights.state.hash ) {

				properties.update( material, 'lightsHash', lights.state.hash );
				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = ShaderLib[ parameters.shaderID ];

					materialProperties.shader = {
						name: material.type,
						uniforms: UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.onBeforeCompile( materialProperties.shader );

				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var programAttributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			var uniforms = materialProperties.shader.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			materialProperties.fog = fog;

			// store the light setup it was created for

			materialProperties.lightsHash = lights.state.hash;

			if ( material.lights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, fog, material, object ) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;

			if ( _clippingEnabled ) {

				if ( _localClippingEnabled || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );

				}

			}

			if ( material.needsUpdate === false ) {

				if ( materialProperties.program === undefined ) {

					material.needsUpdate = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					material.needsUpdate = true;

				} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {

					material.needsUpdate = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

					material.needsUpdate = true;

				}

			}

			if ( material.needsUpdate ) {

				initMaterial( material, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				// Avoid unneeded uniform updates per ArrayCamera's sub-camera

				if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {

					_currentCamera = ( _currentArrayCamera || camera );

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === undefined ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
							boneTexture.needsUpdate = true;

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

				if ( material.lights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material.isMeshBasicMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				} else if ( material.isMeshLambertMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );

				} else if ( material.isMeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshToonMaterial ) {

						refreshUniformsToon( m_uniforms, material );

					} else {

						refreshUniformsPhong( m_uniforms, material );

					}

				} else if ( material.isMeshStandardMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else {

						refreshUniformsStandard( m_uniforms, material );

					}

				} else if ( material.isMeshDepthMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );

				} else if ( material.isMeshDistanceMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );

				} else if ( material.isMeshNormalMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );

				} else if ( material.isLineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

					if ( material.isLineDashedMaterial ) {

						refreshUniformsDash( m_uniforms, material );

					}

				} else if ( material.isPointsMaterial ) {

					refreshUniformsPoints( m_uniforms, material );

				} else if ( material.isShadowMaterial ) {

					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;

				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
				material.uniformsNeedUpdate = false;

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value = material.color;

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.envMap ) {

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;
					var rotation = uvScaleMap.rotation;
					var center = uvScaleMap.center;

					uvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					var offset = material.map.offset;
					var repeat = material.map.repeat;
					var rotation = material.map.rotation;
					var center = material.map.center;

					material.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsFog( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			refreshUniformsPhong( uniforms, material );

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

			refreshUniformsStandard( uniforms, material );

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		// Textures

		function allocTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		this.allocTextureUnit = allocTextureUnit;

		// this.setTexture2D = setTexture2D;
		this.setTexture2D = ( function () {

			var warned = false;

			// backwards compatibility: peel texture.texture
			return function setTexture2D( texture, slot ) {

				if ( texture && texture.isWebGLRenderTarget ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTexture = ( function () {

			var warned = false;

			return function setTexture( texture, slot ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
					warned = true;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTextureCube = ( function () {

			var warned = false;

			return function setTextureCube( texture, slot ) {

				// backwards compatibility: peel texture.texture
				if ( texture && texture.isWebGLRenderTargetCube ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( ( texture && texture.isCubeTexture ) ||
					( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

					// CompressedTexture can have Array in image :/

					// this function alone should take care of cube textures
					textures.setTextureCube( texture, slot );

				} else {

					// assumed: texture property of THREE.WebGLRenderTargetCube

					textures.setTextureCubeDynamic( texture, slot );

				}

			};

		}() );

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget ) {

			_currentRenderTarget = renderTarget;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = null;
			var isCube = false;

			if ( renderTarget ) {

				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLRenderTargetCube ) {

					framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
					isCube = true;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level ) {

			var width = texture.image.width;
			var height = texture.image.height;
			var internalFormat = utils.convert( texture.format );

			this.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, internalFormat, position.x, position.y, width, height, 0 );

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function FogExp2( color, density ) {

		this.name = '';

		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	FogExp2.prototype.isFogExp2 = true;

	FogExp2.prototype.clone = function () {

		return new FogExp2( this.color.getHex(), this.density );

	};

	FogExp2.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Fog( color, near, far ) {

		this.name = '';

		this.color = new Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	Fog.prototype.isFog = true;

	Fog.prototype.clone = function () {

		return new Fog( this.color.getHex(), this.near, this.far );

	};

	Fog.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {

		Object3D.call( this );

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	}

	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Scene,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */

	function SpriteMaterial( parameters ) {

		Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		return this;

	};

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Sprite( material ) {

		Object3D.call( this );

		this.type = 'Sprite';

		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Sprite,

		isSprite: true,

		raycast: ( function () {

			var intersectPoint = new Vector3();
			var worldPosition = new Vector3();
			var worldScale = new Vector3();

			return function raycast( raycaster, intersects ) {

				worldPosition.setFromMatrixPosition( this.matrixWorld );
				raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );

				worldScale.setFromMatrixScale( this.matrixWorld );
				var guessSizeSq = worldScale.x * worldScale.y / 4;

				if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					point: intersectPoint.clone(),
					face: null,
					object: this

				} );

			};

		}() ),

		clone: function () {

			return new this.constructor( this.material ).copy( this );

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.center !== undefined ) this.center.copy( source.center );

			return this;

		}


	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LOD() {

		Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );

	}

	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LOD,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			var levels = source.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			return this;

		},

		addLevel: function ( object, distance ) {

			if ( distance === undefined ) distance = 0;

			distance = Math.abs( distance );

			var levels = this.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

		},

		getObjectForDistance: function ( distance ) {

			var levels = this.levels;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		},

		raycast: ( function () {

			var matrixPosition = new Vector3();

			return function raycast( raycaster, intersects ) {

				matrixPosition.setFromMatrixPosition( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( matrixPosition );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			};

		}() ),

		update: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function update( camera ) {

				var levels = this.levels;

				if ( levels.length > 1 ) {

					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );

					var distance = v1.distanceTo( v2 );

					levels[ 0 ].object.visible = true;

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance >= levels[ i ].distance ) {

							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;

						} else {

							break;

						}

					}

					for ( ; i < l; i ++ ) {

						levels[ i ].object.visible = false;

					}

				}

			};

		}(),

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.levels = [];

			var levels = this.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	function Skeleton( bones, boneInverses ) {

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	Object.assign( Skeleton.prototype, {

		calculateInverses: function () {

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.getInverse( this.bones[ i ].matrixWorld );

				}

				this.boneInverses.push( inverse );

			}

		},

		pose: function () {

			var bone, i, il;

			// recover the bind-time world matrices

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.getInverse( this.boneInverses[ i ] );

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		},

		update: ( function () {

			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();

			return function update() {

				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;

				// flatten bone matrices to array

				for ( var i = 0, il = bones.length; i < il; i ++ ) {

					// compute the offset between the current and the original transform

					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );

				}

				if ( boneTexture !== undefined ) {

					boneTexture.needsUpdate = true;

				}

			};

		} )(),

		clone: function () {

			return new Skeleton( this.bones, this.boneInverses );

		},

		getBoneByName: function ( name ) {

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function SkinnedMesh( geometry, material ) {

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

		var bones = this.initBones();
		var skeleton = new Skeleton( bones );

		this.bind( skeleton, this.matrixWorld );

		this.normalizeSkinWeights();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		initBones: function () {

			var bones = [], bone, gbone;
			var i, il;

			if ( this.geometry && this.geometry.bones !== undefined ) {

				// first, create array of 'Bone' objects from geometry data

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					// create new 'Bone' object

					bone = new Bone();
					bones.push( bone );

					// apply values

					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

				}

				// second, create bone hierarchy

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

						// subsequent bones in the hierarchy

						bones[ gbone.parent ].add( bones[ i ] );

					} else {

						// topmost bone, immediate child of the skinned mesh

						this.add( bones[ i ] );

					}

				}

			}

			// now the bones are part of the scene graph and children of the skinned mesh.
			// let's update the corresponding matrices

			this.updateMatrixWorld( true );

			return bones;

		},

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			var scale, i;

			if ( this.geometry && this.geometry.isGeometry ) {

				for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

					var sw = this.geometry.skinWeights[ i ];

					scale = 1.0 / sw.manhattanLength();

					if ( scale !== Infinity ) {

						sw.multiplyScalar( scale );

					} else {

						sw.set( 1, 0, 0, 0 ); // do something reasonable

					}

				}

			} else if ( this.geometry && this.geometry.isBufferGeometry ) {

				var vec = new Vector4();

				var skinWeight = this.geometry.attributes.skinWeight;

				for ( i = 0; i < skinWeight.count; i ++ ) {

					vec.x = skinWeight.getX( i );
					vec.y = skinWeight.getY( i );
					vec.z = skinWeight.getZ( i );
					vec.w = skinWeight.getW( i );

					scale = 1.0 / vec.manhattanLength();

					if ( scale !== Infinity ) {

						vec.multiplyScalar( scale );

					} else {

						vec.set( 1, 0, 0, 0 ); // do something reasonable

					}

					skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

				}

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.getInverse( this.matrixWorld );

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.getInverse( this.bindMatrix );

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues( parameters );

	}

	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Line( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new LineSegments( geometry, material );

		}

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];

						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

							start.fromBufferAttribute( positionAttribute, i - 1 );
							end.fromBufferAttribute( positionAttribute, i );

							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new THREE.Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					lineDistances[ 0 ] = 0;

					for ( var i = 1, l = vertices.length; i < l; i ++ ) {

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

					}

				}

				return this;

			};

		}() ),

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var precision = raycaster.linePrecision;
				var precisionSq = precision * precision;

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

							var a = indices[ i ];
							var b = indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					} else {

						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for ( var i = 0; i < nbVertices - 1; i += step ) {

						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];

						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

							start.fromBufferAttribute( positionAttribute, i );
							end.fromBufferAttribute( positionAttribute, i + 1 );

							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new THREE.Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

						start.copy( vertices[ i ] );
						end.copy( vertices[ i + 1 ] );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

					}

				}

				return this;

			};

		}() )

	} );

	/**
	 * @author mgreter / http://github.com/mgreter
	 */

	function LineLoop( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineLoop';

	}

	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineLoop,

		isLineLoop: true,

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	function PointsMaterial( parameters ) {

		Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.lights = false;

		this.setValues( parameters );

	}

	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Points( geometry, material ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();

				function testPoint( point, index ) {

					var rayPointDistanceSq = ray.distanceSqToPoint( point );

					if ( rayPointDistanceSq < localThresholdSq ) {

						var intersectPoint = ray.closestPointToPoint( point );
						intersectPoint.applyMatrix4( matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectPoint );

						if ( distance < raycaster.near || distance > raycaster.far ) return;

						intersects.push( {

							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object

						} );

					}

				}

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, il = indices.length; i < il; i ++ ) {

							var a = indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

							position.fromArray( positions, i * 3 );

							testPoint( position, i );

						}

					}

				} else {

					var vertices = geometry.vertices;

					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

						testPoint( vertices[ i ], i );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

	}

	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

		constructor: VideoTexture,

		isVideoTexture: true,

		update: function () {

			var video = this.image;

			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}

	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WireframeGeometry( geometry ) {

		BufferGeometry.call( this );

		this.type = 'WireframeGeometry';

		// buffer

		var vertices = [];

		// helper variables

		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;

		// different logic for Geometry and BufferGeometry

		if ( geometry && geometry.isGeometry ) {

			// create a data structure that contains all edges without duplicates

			var faces = geometry.faces;

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( j = 0; j < 3; j ++ ) {

					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );

					key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else if ( geometry && geometry.isBufferGeometry ) {

			var position, indices, groups;
			var group, start, count;
			var index1, index2;

			vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( o = 0, ol = groups.length; o < ol; ++ o ) {

					group = groups[ o ];

					start = group.start;
					count = group.count;

					for ( i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( j = 0; j < 3; j ++ ) {

							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( key in edges ) {

					e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				position = geometry.attributes.position;

				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */

	// ParametricGeometry

	function ParametricGeometry( func, slices, stacks ) {

		Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();

	}

	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	// ParametricBufferGeometry

	function ParametricBufferGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricBufferGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		var EPS = 0.00001;

		var normal = new Vector3();

		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();

		var i, j;

		// generate vertices, normals and uvs

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			var v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				var u = j / slices;

				// vertex

				p0 = func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					p1 = func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					p1 = func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					p1 = func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					p1 = func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PolyhedronGeometry

	function PolyhedronGeometry( vertices, indices, radius, detail ) {

		Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();

	}

	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	// PolyhedronBufferGeometry

	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

		BufferGeometry.call( this );

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		// default buffer data

		var vertexBuffer = [];
		var uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		appplyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( var i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			var cols = Math.pow( 2, detail );

			// we use this multidimensional array as a data structure for creating the subdivision

			var v = [];

			var i, j;

			// construct all of the vertices for this subdivision

			for ( i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );

				var rows = cols - i;

				for ( j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( i = 0; i < cols; i ++ ) {

				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function appplyRadius( radius ) {

			var vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			var vertex = new Vector3();

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( var i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];

				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			var stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			var centroid = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				var azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TetrahedronGeometry

	function TetrahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

	// TetrahedronBufferGeometry

	function TetrahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// OctahedronGeometry

	function OctahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

	// OctahedronBufferGeometry

	function OctahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// IcosahedronGeometry

	function IcosahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

	// IcosahedronBufferGeometry

	function IcosahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// DodecahedronGeometry

	function DodecahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

	// DodecahedronBufferGeometry

	function DodecahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */

	// TubeGeometry

	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

		Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();

	}

	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;

	// TubeBufferGeometry

	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

		BufferGeometry.call( this );

		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		var frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();

		var i, j;

		// buffer

		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( j = 0; j <= radialSegments; j ++ ) {

				var v = j / radialSegments * Math.PI * 2;

				var sin = Math.sin( v );
				var cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				for ( j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */

	// TorusKnotGeometry

	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

		Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();

	}

	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

	// TorusKnotBufferGeometry

	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

		BufferGeometry.call( this );

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, j;

		var vertex = new Vector3();
		var normal = new Vector3();

		var P1 = new Vector3();
		var P2 = new Vector3();

		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();

		// generate vertices, normals and uvs

		for ( i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			var u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				// indices

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TorusGeometry

	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();

	}

	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;

	// TorusBufferGeometry

	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		BufferGeometry.call( this );

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();

		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= radialSegments; j ++ ) {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= radialSegments; j ++ ) {

			for ( i = 1; i <= tubularSegments; i ++ ) {

				// indices

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	var Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];

			if ( ! outerNode ) return triangles;

			var minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( var i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order

	function linkedList( data, start, end, dim, clockwise ) {

		var i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points

	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		var p = start, again;

		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)

	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order

		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		var stop = ear, prev, next;

		// iterate through ears, slicing them one by one

		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears

			if ( ear === stop ) {

				// try filtering points and slicing again

				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes

	function isEar( ear ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

				return false;

			}

			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;

		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		// first look for points inside the triangle in increasing z-order

		var p = ear.nextZ;

		while ( p && p.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.nextZ;

		}

		// then look for points in decreasing z-order

		p = ear.prevZ;

		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;

			p = p.prevZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections

	function cureLocalIntersections( start, triangles, dim ) {

		var p = start;

		do {

			var a = p.prev, b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved

				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return p;

	}

	// try splitting polygon into two and triangulate them independently

	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two

		var a = start;

		do {

			var b = a.next.next;

			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal

					var c = splitPolygon( a, b );

					// filter colinear points around the cuts

					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half

					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes

	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		var queue = [], i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right

		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it

	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );

		if ( outerNode ) {

			var b = splitPolygon( outerNode, hole );

			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon

	function findHoleBridge( hole, outerNode ) {

		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

				if ( x <= hx && x > qx ) {

					qx = x;

					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;

		p = m.next;

		while ( p !== stop ) {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		}

		return m;

	}

	// interlink polygon nodes in z-order

	function indexCurve( start, minX, minY, invSize ) {

		var p = start;

		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

	function sortLinked( list ) {

		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;

				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox

	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range

		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring

	function getLeftmost( start ) {

		var p = start, leftmost = start;

		do {

			if ( p.x < leftmost.x ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle

	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

	}

	// signed area of a triangle

	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal

	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect

	function intersects( p1, q1, p2, q2 ) {

		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;

		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

	}

	// check if a polygon diagonal intersects any polygon segments

	function intersectsPolygon( a, b ) {

		var p = a;

		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
							intersects( p, p.next, a, b ) ) {

				return true;

			}

			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon

	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon

	function middleInside( a, b ) {

		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;

		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

				inside = ! inside;

			}

			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

	function splitPolygon( a, b ) {

		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)

	function insertNode( i, x, y, last ) {

		var p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertice index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		var sum = 0;

		for ( var i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			var holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( var i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			var triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( var i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	};

	function removeDupEndPts( points ) {

		var l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( var i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *  frames: <Object> // containing arrays of tangents, normals, binormals
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	// ExtrudeGeometry

	function ExtrudeGeometry( shapes, options ) {

		Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();

	}

	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

	// ExtrudeBufferGeometry

	function ExtrudeBufferGeometry( shapes, options ) {

		if ( typeof ( shapes ) === "undefined" ) {

			return;

		}

		BufferGeometry.call( this );

		this.type = 'ExtrudeBufferGeometry';

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeVertexNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	}

	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

	ExtrudeBufferGeometry.prototype.getArrays = function () {

		var positionAttribute = this.getAttribute( "position" );
		var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];

		var uvAttribute = this.getAttribute( "uv" );
		var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];

		var IndexAttribute = this.index;
		var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];

		return {
			position: verticesArray,
			uv: uvArray,
			index: indicesArray
		};

	};

	ExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {

		var sl = shapes.length;
		options.arrays = this.getArrays();

		for ( var s = 0; s < sl; s ++ ) {

			var shape = shapes[ s ];
			this.addShape( shape, options );

		}

		this.setIndex( options.arrays.index );
		this.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

	};

	ExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {

		var arrays = options.arrays ? options.arrays : this.getArrays();
		var verticesArray = arrays.position;
		var indicesArray = arrays.index;
		var uvArray = arrays.uv;

		var placeholder = [];


		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new Vector3();
			normal = new Vector3();
			position2 = new Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! ShapeUtils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( ShapeUtils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

		}


		var faces = ShapeUtils.triangulateShape( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2( pt, vec, size ) {

			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x,
				v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x,
				v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			if ( Math.abs( collinear0 ) > Number.EPSILON ) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

				// scaling factor for v_prev to intersection point

				var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
					( v_prev_x * v_next_y - v_prev_y * v_next_x );

				// vector from inPt to intersection point

				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {

					return new Vector2( v_trans_x, v_trans_y );

				} else {

					shrink_by = Math.sqrt( v_trans_lensq / 2 );

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false; // assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {

					if ( v_next_x > Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( v_prev_x < - Number.EPSILON ) {

						if ( v_next_x < - Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

							direction_eq = true;

						}

					}

				}

				if ( direction_eq ) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y = v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );

				}

			}

			return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [],
			oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 );

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y, - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 );

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y, amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			var start = verticesArray.length / 3;

			if ( bevelEnabled ) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}

			}

			scope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var start = verticesArray.length / 3;
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}


			scope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );


		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0,
					sl = steps + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d );

				}

			}

		}

		function v( x, y, z ) {

			placeholder.push( x );
			placeholder.push( y );
			placeholder.push( z );

		}


		function f3( a, b, c ) {

			addVertex( a );
			addVertex( b );
			addVertex( c );

			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );

		}

		function f4( a, b, c, d ) {

			addVertex( a );
			addVertex( b );
			addVertex( d );

			addVertex( b );
			addVertex( c );
			addVertex( d );


			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 3 ] );

			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );
			addUV( uvs[ 3 ] );

		}

		function addVertex( index ) {

			indicesArray.push( verticesArray.length / 3 );
			verticesArray.push( placeholder[ index * 3 + 0 ] );
			verticesArray.push( placeholder[ index * 3 + 1 ] );
			verticesArray.push( placeholder[ index * 3 + 2 ] );

		}


		function addUV( vector2 ) {

			uvArray.push( vector2.x );
			uvArray.push( vector2.y );

		}

		if ( ! options.arrays ) {

			this.setIndex( indicesArray );
			this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		}

	};

	ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}
	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	// TextGeometry

	function TextGeometry( text, parameters ) {

		Geometry.call( this );

		this.type = 'TextGeometry';

		this.parameters = {
			text: text,
			parameters: parameters
		};

		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();

	}

	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;

	// TextBufferGeometry

	function TextBufferGeometry( text, parameters ) {

		parameters = parameters || {};

		var font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();

		}

		var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		ExtrudeBufferGeometry.call( this, shapes, parameters );

		this.type = 'TextBufferGeometry';

	}

	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// SphereGeometry

	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;

	// SphereBufferGeometry

	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var ix, iy;

		var index = 0;
		var grid = [];

		var vertex = new Vector3();
		var normal = new Vector3();

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy <= heightSegments; iy ++ ) {

			var verticesRow = [];

			var v = iy / heightSegments;

			for ( ix = 0; ix <= widthSegments; ix ++ ) {

				var u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( vertex.x, vertex.y, vertex.z ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( iy = 0; iy < heightSegments; iy ++ ) {

			for ( ix = 0; ix < widthSegments; ix ++ ) {

				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// RingGeometry

	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;

	// RingBufferGeometry

	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// some helper variables

		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= phiSegments; j ++ ) {

			for ( i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( j = 0; j < phiSegments; j ++ ) {

			var thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( i = 0; i < thetaSegments; i ++ ) {

				segment = i + thetaSegmentLevel;

				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// LatheGeometry

	function LatheGeometry( points, segments, phiStart, phiLength ) {

		Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();

	}

	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;

	// LatheBufferGeometry

	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

		BufferGeometry.call( this );

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


		// buffers

		var indices = [];
		var vertices = [];
		var uvs = [];

		// helper variables

		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;

		// generate vertices and uvs

		for ( i = 0; i <= segments; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var sin = Math.sin( phi );
			var cos = Math.cos( phi );

			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < ( points.length - 1 ); j ++ ) {

				base = j + i * points.length;

				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();

			// this is the buffer offset for the last line of vertices

			base = segments * points.length * 3;

			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// ShapeGeometry

	function ShapeGeometry( shapes, curveSegments ) {

		Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( typeof curveSegments === 'object' ) {

			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

			curveSegments = curveSegments.curveSegments;

		}

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();

	}

	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;

	ShapeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	};

	// ShapeBufferGeometry

	function ShapeBufferGeometry( shapes, curveSegments ) {

		BufferGeometry.call( this );

		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		curveSegments = curveSegments || 12;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var groupStart = 0;
		var groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( var i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			var i, l, shapeHole;

			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );

			var shapeVertices = points.shape;
			var shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

				// also check if holes are in the opposite direction

				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

					shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

			}

			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

				var vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

	ShapeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	};

	//

	function toJSON( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function EdgesGeometry( geometry, thresholdAngle ) {

		BufferGeometry.call( this );

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		// buffer

		var vertices = [];

		// helper variables

		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];

		// prepare source geometry

		var geometry2;

		if ( geometry.isBufferGeometry ) {

			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;

		// now create a data structure where each entry represents an edge with its adjoining faces

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					edges[ key ].face2 = i;

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			var e = edges[ key ];

			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// CylinderGeometry

	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;

	// CylinderBufferGeometry

	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		var scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();

			var groupCount = 0;

			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( y = 0; y <= heightSegments; y ++ ) {

				var indexRow = [];

				var v = y / heightSegments;

				// calculate the radius of the current row

				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				for ( y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			var x, centerIndexStart, centerIndexEnd;

			var uv = new Vector2();
			var vertex = new Vector3();

			var groupCount = 0;

			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex

			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;

				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	// ConeGeometry

	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;

	// ConeBufferGeometry

	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */

	// CircleGeometry

	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;

	// CircleBufferGeometry

	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			var segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



	var Geometries = Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>,
	 *  opacity: <float>
	 * }
	 */

	function ShadowMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.opacity = 1.0;

		this.lights = true;
		this.transparent = true;

		this.setValues( parameters );

	}

	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;

	ShadowMaterial.prototype.isShadowMaterial = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial( parameters ) {

		ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	}

	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = { 'PHYSICAL': '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = { 'PHYSICAL': '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshToonMaterial( parameters ) {

		MeshPhongMaterial.call( this );

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.gradientMap = null;

		this.setValues( parameters );

	}

	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function ( source ) {

		MeshPhongMaterial.prototype.copy.call( this, source );

		this.gradientMap = source.gradientMap;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	function LineDashedMaterial( parameters ) {

		LineBasicMaterial.call( this );

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function ( source ) {

		LineBasicMaterial.prototype.copy.call( this, source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	};



	var Materials = Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;
			return this;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var loading = {};

	function FileLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FileLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];

				data = window.decodeURIComponent( data );

				if ( isBase64 ) data = window.atob( data );

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				var request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					Cache.add( url, response );

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 ) {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else if ( this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		},

		setRequestHeader: function ( value ) {

			this.requestHeader = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	function CompressedTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( CompressedTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();
			texture.image = images;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	function DataTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( DataTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new DataTexture();

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ImageLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( ImageLoader.prototype, {

		crossOrigin: 'Anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			image.addEventListener( 'load', function () {

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}, false );

			/*
			image.addEventListener( 'progress', function ( event ) {

				if ( onProgress ) onProgress( event );

			}, false );
			*/

			image.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			}, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( CubeTextureLoader.prototype, {

		crossOrigin: 'Anonymous',

		load: function ( urls, onLoad, onProgress, onError ) {

			var texture = new CubeTexture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function TextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( TextureLoader.prototype, {

		crossOrigin: 'Anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			var i, u, theta;

			// compute the tangent vectors for each segment on the curve

			for ( i = 0; i <= segments; i ++ ) {

				u = i / segments;

				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		Curve.call( this );

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;

	}

	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x - this.aX;
			var ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	};

	EllipseCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	};


	EllipseCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	};

	EllipseCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	};

	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly();
	var py = new CubicPoly();
	var pz = new CubicPoly();

	function CatmullRomCurve3( points, closed, curveType, tension ) {

		Curve.call( this );

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;

	}

	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var points = this.points;
		var l = points.length;

		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		var p0, p1, p2, p3; // 4 points

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	};

	CatmullRomCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	};

	CatmullRomCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	};

	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	function CubicBezierCurve( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();

	}

	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	};

	CubicBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function CubicBezierCurve3( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();

	}

	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	};

	CubicBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function LineCurve( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve.prototype.getTangent = function ( /* t */ ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	LineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function LineCurve3( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	};

	QuadraticBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve3( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	};

	QuadraticBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function SplineCurve( points /* array of Vector2 */ ) {

		Curve.call( this );

		this.type = 'SplineCurve';

		this.points = points || [];

	}

	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var points = this.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	};

	SplineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	};

	SplineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	};

	SplineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	};



	var Curves = Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {

		Curve.call( this );

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

		constructor: CurvePath,

		add: function ( curve ) {

			this.curves.push( curve );

		},

		closePath: function () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 40;

			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		getPoints: function ( divisions ) {

			divisions = divisions || 12;

			var points = [], last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && curve.isLineCurve ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		copy: function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		},

		toJSON: function () {

			var data = Curve.prototype.toJSON.call( this );

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/

	function Path( points ) {

		CurvePath.call( this );

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

		constructor: Path,

		setFromPoints: function ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

		},

		moveTo: function ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		},

		lineTo: function ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		splineThru: function ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

		},

		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

		},

		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		},

		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		},

		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

		},

		copy: function ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		},

		toJSON: function () {

			var data = CurvePath.prototype.toJSON.call( this );

			data.currentPoint = this.currentPoint.toArray();

			return data;

		},

		fromJSON: function ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape( points ) {

		Path.call( this, points );

		this.uuid = _Math.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

		constructor: Shape,

		getPointsHoles: function ( divisions ) {

			var holesPts = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints: function ( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		},

		copy: function ( source ) {

			Path.prototype.copy.call( this, source );

			this.holes = [];

			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

				var hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		},

		toJSON: function () {

			var data = Path.prototype.toJSON.call( this );

			data.uuid = this.uuid;
			data.holes = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Path.prototype.fromJSON.call( this, json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Light( color, intensity ) {

		Object3D.call( this );

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;

	}

	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Light,

		isLight: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function HemisphereLight( skyColor, groundColor, intensity ) {

		Light.call( this, skyColor, intensity );

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.matrix = new Matrix4();

	}

	Object.assign( LightShadow.prototype, {

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function SpotLightShadow() {

		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

	}

	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: SpotLightShadow,

		isSpotLightShadow: true,

		update: function ( light ) {

			var camera = this.camera;

			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

		Light.call( this, color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: SpotLight,

		isSpotLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function PointLight( color, intensity, distance, decay ) {

		Light.call( this, color, intensity );

		this.type = 'PointLight';

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / ( 4 * Math.PI );

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	}

	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: PointLight,

		isPointLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectionalLightShadow( ) {

		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: DirectionalLightShadow

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DirectionalLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AmbientLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	}

	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: AmbientLight,

		isAmbientLight: true

	} );

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	function RectAreaLight( color, intensity, width, height ) {

		Light.call( this, color, intensity );

		this.type = 'RectAreaLight';

		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;

	}

	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: RectAreaLight,

		isRectAreaLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.width = source.width;
			this.height = source.height;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	} );

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function StringKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: StringKeyframeTrack,

		ValueTypeName: 'string',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,

		InterpolantFactoryMethodSmooth: undefined

	} );

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function BooleanKeyframeTrack( name, times, values ) {

		KeyframeTrack.call( this, name, times, values );

	}

	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: BooleanKeyframeTrack,

		ValueTypeName: 'bool',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined

		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	} );

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset = i1 * stride,

				alpha = ( t - t0 ) / ( t1 - t0 );

			for ( var end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function QuaternionKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: QuaternionKeyframeTrack,

		ValueTypeName: 'quaternion',

		// ValueBufferType is inherited

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodLinear: function ( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: undefined // not yet implemented

	} );

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function ColorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: ColorKeyframeTrack,

		ValueTypeName: 'color'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	} );

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function NumberKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: NumberKeyframeTrack,

		ValueTypeName: 'number'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	/**
	 * @author tschw
	 */

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		}

	};

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function KeyframeTrack( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

		this.validate();
		this.optimize();

	}

	// Static methods:

	Object.assign( KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		parse: function ( json ) {

			if ( json.type === undefined ) {

				throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

			}

			var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

			if ( json.times === undefined ) {

				var times = [], values = [];

				AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

				json.times = times;
				json.values = values;

			}

			// derived classes can define a static parse method
			if ( trackType.parse !== undefined ) {

				return trackType.parse( json );

			} else {

				// by default, we assume a constructor compatible with the base
				return new trackType( json.name, json.times, json.values, json.interpolation );

			}

		},

		toJSON: function ( track ) {

			var trackType = track.constructor;

			var json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				var interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		},

		_getTrackTypeForValueTypeName: function ( typeName ) {

			switch ( typeName.toLowerCase() ) {

				case 'scalar':
				case 'double':
				case 'float':
				case 'number':
				case 'integer':

					return NumberKeyframeTrack;

				case 'vector':
				case 'vector2':
				case 'vector3':
				case 'vector4':

					return VectorKeyframeTrack;

				case 'color':

					return ColorKeyframeTrack;

				case 'quaternion':

					return QuaternionKeyframeTrack;

				case 'bool':
				case 'boolean':

					return BooleanKeyframeTrack;

				case 'string':

					return StringKeyframeTrack;

			}

			throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

		}

	} );

	Object.assign( KeyframeTrack.prototype, {

		constructor: KeyframeTrack,

		TimeBufferType: Float32Array,

		ValueBufferType: Float32Array,

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodDiscrete: function ( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodLinear: function ( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: function ( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		setInterpolation: function ( interpolation ) {

			var factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return;

			}

			this.createInterpolant = factoryMethod;

		},

		getInterpolation: function () {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		},

		getValueSize: function () {

			return this.values.length / this.times.length;

		},

		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function ( timeScale ) {

			if ( timeScale !== 1.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {

			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {

			var valid = true;

			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			var times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			var prevTime = null;

			for ( var i = 0; i !== nKeys; i ++ ) {

				var currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( var i = 0, n = values.length; i !== n; ++ i ) {

						var value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {

			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				writeIndex = 1,
				lastIndex = times.length - 1;

			for ( var i = 1; i < lastIndex; ++ i ) {

				var keep = false;

				var time = times[ i ];
				var timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( var j = 0; j !== stride; ++ j ) {

							var value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						var readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( var j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			}

			return this;

		}

	} );

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function VectorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: VectorKeyframeTrack,

		ValueTypeName: 'vector'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	function AnimationClip( name, duration, tracks ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;

		this.uuid = _Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

		this.optimize();

	}

	Object.assign( AnimationClip, {

		parse: function ( json ) {

			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

			}

			return new AnimationClip( json.name, json.duration, tracks );

		},

		toJSON: function ( clip ) {

			var tracks = [],
				clipTracks = clip.tracks;

			var json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks

			};

			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		},

		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for ( var i = 0; i < numMorphTargets; i ++ ) {

				var times = [];
				var values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new AnimationClip( name, - 1, tracks );

		},

		findByName: function ( objectOrClipArray, name ) {

			var clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( var i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		},

		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

			var animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					var name = parts[ 1 ];

					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			var clips = [];

			for ( var name in animationToMorphTargets ) {

				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		},

		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					var times = [];
					var values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			var tracks = [];

			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;

			var hierarchyTracks = animation.hierarchy || [];

			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

				var animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					var morphTargetNames = {};

					for ( var k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {

						var times = [];
						var values = [];

						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							var animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * ( fps || 1.0 );

				} else {

					// ...assume skeletal animation

					var boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			var clip = new AnimationClip( clipName, duration, tracks );

			return clip;

		}

	} );

	Object.assign( AnimationClip.prototype, {

		resetDuration: function () {

			var tracks = this.tracks, duration = 0;

			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

				var track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

		},

		trim: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		},

		optimize: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function MaterialLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};

	}

	Object.assign( MaterialLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setTextures: function ( value ) {

			this.textures = value;

		},

		parse: function ( json ) {

			var textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			var material = new Materials[ json.type ]();

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;

			// Deprecated

			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalScale !== undefined ) {

				var normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			return material;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferGeometryLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( BufferGeometryLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var geometry = new BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	} );

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader() {

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	}

	Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			var handlers = this.handlers;

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	Object.assign( Loader.prototype, {

		crossOrigin: undefined,

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};

			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();

			return function createMaterial( m, texturePath, crossOrigin ) {

				// convert from old material format

				var textures = {};

				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );

					var texture;

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );

					}

					if ( repeat !== undefined ) {

						texture.repeat.fromArray( repeat );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

					}

					if ( offset !== undefined ) {

						texture.offset.fromArray( offset );

					}

					if ( wrap !== undefined ) {

						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

					}

					if ( anisotropy !== undefined ) {

						texture.anisotropy = anisotropy;

					}

					var uuid = _Math.generateUUID();

					textures[ uuid ] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for ( var name in m ) {

					var value = m[ name ];

					switch ( name ) {

						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = [ value, value ];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;

					}

				}

				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

				if ( json.opacity < 1 ) json.transparent = true;

				materialLoader.setTextures( textures );

				return materialLoader.parse( json );

			};

		} )()

	} );

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			// Merges multi-byte utf-8 characters.
			return decodeURIComponent( escape( s ) );

		},

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function JSONLoader( manager ) {

		if ( typeof manager === 'boolean' ) {

			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.withCredentials = false;

	}

	Object.assign( JSONLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );

			var loader = new FileLoader( this.manager );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				var json = JSON.parse( text );
				var metadata = json.metadata;

				if ( metadata !== undefined ) {

					var type = metadata.type;

					if ( type !== undefined ) {

						if ( type.toLowerCase() === 'object' ) {

							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;

						}

						if ( type.toLowerCase() === 'scene' ) {

							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
							return;

						}

					}

				}

				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		parse: ( function () {

			function parseModel( json, geometry ) {

				function isBitSet( value, position ) {

					return value & ( 1 << position );

				}

				var i, j, fi,

					offset, zLength,

					colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

					vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					scale = json.scale,

					nUvLayers = 0;


				if ( json.uvs !== undefined ) {

					// disregard empty arrays

					for ( i = 0; i < json.uvs.length; i ++ ) {

						if ( json.uvs[ i ].length ) nUvLayers ++;

					}

					for ( i = 0; i < nUvLayers; i ++ ) {

						geometry.faceVertexUvs[ i ] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while ( offset < zLength ) {

					vertex = new Vector3();

					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;

					geometry.vertices.push( vertex );

				}

				offset = 0;
				zLength = faces.length;

				while ( offset < zLength ) {

					type = faces[ offset ++ ];

					isQuad = isBitSet( type, 0 );
					hasMaterial = isBitSet( type, 1 );
					hasFaceVertexUv = isBitSet( type, 3 );
					hasFaceNormal = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor = isBitSet( type, 6 );
					hasFaceVertexColor = isBitSet( type, 7 );

					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if ( isQuad ) {

						faceA = new Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];

						faceB = new Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];

						offset += 4;

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

								for ( j = 0; j < 4; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							faceB.normal.copy( faceA.normal );

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 4; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);


								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							faceA.color.setHex( hex );
							faceB.color.setHex( hex );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 4; i ++ ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

							}

						}

						geometry.faces.push( faceA );
						geometry.faces.push( faceB );

					} else {

						face = new Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];

								for ( j = 0; j < 3; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									geometry.faceVertexUvs[ i ][ fi ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 3; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								face.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 3; i ++ ) {

								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new Color( colors[ colorIndex ] ) );

							}

						}

						geometry.faces.push( face );

					}

				}

			}

			function parseSkin( json, geometry ) {

				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

				if ( json.skinWeights ) {

					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

						var x = json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

						geometry.skinWeights.push( new Vector4( x, y, z, w ) );

					}

				}

				if ( json.skinIndices ) {

					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

						var a = json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

						geometry.skinIndices.push( new Vector4( a, b, c, d ) );

					}

				}

				geometry.bones = json.bones;

				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}

			}

			function parseMorphing( json, geometry ) {

				var scale = json.scale;

				if ( json.morphTargets !== undefined ) {

					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];

						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;

						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

							var vertex = new Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;

							dstVertices.push( vertex );

						}

					}

				}

				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						faces[ i ].color.fromArray( morphColors, i * 3 );

					}

				}

			}

			function parseAnimations( json, geometry ) {

				var outputAnimations = [];

				// parse old style Bone/Hierarchy animations
				var animations = [];

				if ( json.animation !== undefined ) {

					animations.push( json.animation );

				}

				if ( json.animations !== undefined ) {

					if ( json.animations.length ) {

						animations = animations.concat( json.animations );

					} else {

						animations.push( json.animations );

					}

				}

				for ( var i = 0; i < animations.length; i ++ ) {

					var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );

				}

				// parse implicit morph animations
				if ( geometry.morphTargets ) {

					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );

				}

				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

			}

			return function parse( json, texturePath ) {

				if ( json.data !== undefined ) {

					// Geometry 4.0 spec
					json = json.data;

				}

				if ( json.scale !== undefined ) {

					json.scale = 1.0 / json.scale;

				} else {

					json.scale = 1.0;

				}

				var geometry = new Geometry();

				parseModel( json, geometry );
				parseSkin( json, geometry );
				parseMorphing( json, geometry );
				parseAnimations( json, geometry );

				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				if ( json.materials === undefined || json.materials.length === 0 ) {

					return { geometry: geometry };

				} else {

					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

					return { geometry: geometry, materials: materials };

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ObjectLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.texturePath = '';

	}

	Object.assign( ObjectLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				var json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				var metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json, onLoad ) {

			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );

			var object = this.parseObject( json.object, geometries, materials );

			if ( json.animations ) {

				object.animations = this.parseAnimations( json.animations );

			}

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseShape: function ( json ) {

			var shapes = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		},

		parseGeometries: function ( json, shapes ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new JSONLoader();
				var bufferGeometryLoader = new BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);

							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':

							var geometryShapes = [];

							for ( var i = 0, l = data.shapes.length; i < l; i ++ ) {

								var shape = shapes[ data.shapes[ i ] ];

								geometryShapes.push( shape );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data, this.texturePath ).geometry;

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.type === 'MultiMaterial' ) {

						// Deprecated

						var array = [];

						for ( var j = 0; j < data.materials.length; j ++ ) {

							array.push( loader.parse( data.materials[ j ] ) );

						}

						materials[ data.uuid ] = array;

					} else {

						materials[ data.uuid ] = loader.parse( data );

					}

				}

			}

			return materials;

		},

		parseAnimations: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var clip = AnimationClip.parse( json[ i ] );

				animations.push( clip );

			}

			return animations;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new LoadingManager( onLoad );

				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new Texture( images[ data.image ] );
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					var array = [];

					for ( var i = 0, l = name.length; i < l; i ++ ) {

						var uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				object.matrix.fromArray( data.matrix );
				object.matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				var children = data.children;

				for ( var i = 0; i < children.length; i ++ ) {

					object.add( this.parseObject( children[ i ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	} );

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};

	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};

	/**
	 * @author thespite / http://clicktorelease.com/
	 */

	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;

	}

	ImageBitmapLoader.prototype = {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function load( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			fetch( url ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				return createImageBitmap( blob, scope.options );

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			} );

		},

		setCrossOrigin: function ( /* value */ ) {

			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/

	function ShapePath() {

		this.type = 'ShapePath';

		this.subPaths = [];
		this.currentPath = null;

	}

	Object.assign( ShapePath.prototype, {

		moveTo: function ( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

		},

		lineTo: function ( x, y ) {

			this.currentPath.lineTo( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		},

		splineThru: function ( pts ) {

			this.currentPath.splineThru( pts );

		},

		toShapes: function ( isCCW, noHoles ) {

			function toShapesNoHoles( inSubpaths ) {

				var shapes = [];

				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

					var tmpPath = inSubpaths[ i ];

					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			var isClockWise = ShapeUtils.isClockWise;

			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


			var solid, tmpPath, tmpShape, shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				var ambiguous = false;
				var toChange = [];

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					var sho = newShapeHoles[ sIdx ];

					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						var ho = sho[ hIdx ];
						var hole_unassigned = true;

						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}
						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {

					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Font( data ) {

		this.type = 'Font';

		this.data = data;

	}

	Object.assign( Font.prototype, {

		isFont: true,

		generateShapes: function ( text, size, divisions ) {

			if ( size === undefined ) size = 100;
			if ( divisions === undefined ) divisions = 4;

			var shapes = [];
			var paths = createPaths( text, size, divisions, this.data );

			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

			}

			return shapes;

		}

	} );

	function createPaths( text, size, divisions, data ) {

		var chars = String( text ).split( '' );
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

		var paths = [];

		var offsetX = 0, offsetY = 0;

		for ( var i = 0; i < chars.length; i ++ ) {

			var char = chars[ i ];

			if ( char === '\n' ) {

				offsetX = 0;
				offsetY -= line_height;

			} else {

				var ret = createPath( char, divisions, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );

			}

		}

		return paths;

	}

	function createPath( char, divisions, scale, offsetX, offsetY, data ) {

		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

		if ( ! glyph ) return;

		var path = new ShapePath();

		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if ( glyph.o ) {

			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

			for ( var i = 0, l = outline.length; i < l; ) {

				var action = outline[ i ++ ];

				switch ( action ) {

					case 'm': // moveTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.moveTo( x, y );

						break;

					case 'l': // lineTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.lineTo( x, y );

						break;

					case 'q': // quadraticCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						break;

					case 'b': // bezierCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						break;

				}

			}

		}

		return { offsetX: glyph.ha * scale, path: path };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function FontLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FontLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json;

				try {

					json = JSON.parse( text );

				} catch ( e ) {

					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );

				}

				var font = scope.parse( json );

				if ( onLoad ) onLoad( font );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			return new Font( json );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var context;

	var AudioContext = {

		getContext: function () {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function AudioLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AudioLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.load( url, function ( buffer ) {

				var context = AudioContext.getContext();

				context.decodeAudioData( buffer, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			}, onProgress, onError );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

	}

	Object.assign( StereoCamera.prototype, {

		update: ( function () {

			var instance, focus, fov, aspect, near, far, zoom, eyeSep;

			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();

			return function update( camera ) {

				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

				if ( needsUpdate ) {

					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;

					// translate xOffset

					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;

					// for left eye

					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraL.projectionMatrix.copy( projectionMatrix );

					// for right eye

					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraR.projectionMatrix.copy( projectionMatrix );

				}

				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

			};

		} )()

	} );

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CubeCamera( near, far, cubeResolution ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

			renderer.setRenderTarget( null );

		};

		this.clear = function ( renderer, color, depth, stencil ) {

			var renderTarget = this.renderTarget;

			for ( var i = 0; i < 6; i ++ ) {

				renderTarget.activeCubeFace = i;
				renderer.setRenderTarget( renderTarget );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( null );

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioListener() {

		Object3D.call( this );

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

	}

	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function ( ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function ( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function ( value ) {

			this.gain.gain.value = value;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var listener = this.context.listener;
				var up = this.up;

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

				if ( listener.positionX ) {

					listener.positionX.setValueAtTime( position.x, this.context.currentTime );
					listener.positionY.setValueAtTime( position.y, this.context.currentTime );
					listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
					listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
					listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
					listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
					listener.upX.setValueAtTime( up.x, this.context.currentTime );
					listener.upY.setValueAtTime( up.y, this.context.currentTime );
					listener.upZ.setValueAtTime( up.z, this.context.currentTime );

				} else {

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio( listener ) {

		Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];

	}

	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setBuffer: function ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		},

		play: function () {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			var source = this.context.createBufferSource();

			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );

			this.isPlaying = true;

			this.source = source;

			return this.connect();

		},

		pause: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				this.source.stop();
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;

			}

			return this;

		},

		stop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.offset = 0;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			return this;

		},

		disconnect: function () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function ( value ) {

			if ( ! value ) value = [];

			if ( this.isPlaying === true ) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		getFilter: function () {

			return this.getFilters()[ 0 ];

		},

		setFilter: function ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		},

		setPlaybackRate: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		},

		setLoop: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},

		setVolume: function ( value ) {

			this.gain.gain.value = value;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PositionalAudio( listener ) {

		Audio.call( this, listener );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

	}

	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

		constructor: PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function ( value ) {

			this.panner.refDistance = value;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function ( value ) {

			this.panner.rolloffFactor = value;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function ( value ) {

			this.panner.distanceModel = value;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function ( value ) {

			this.panner.maxDistance = value;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				position.setFromMatrixPosition( this.matrixWorld );

				this.panner.setPosition( position.x, position.y, position.z );

			};

		} )()


	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser( audio, fftSize ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	Object.assign( AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for ( var i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	} );

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function PropertyMixer( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		var bufferType = Float64Array,
			mixFunction;

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				break;

			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;

			default:
				mixFunction = this._lerp;

		}

		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	Object.assign( PropertyMixer.prototype, {

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function ( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,

				currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function ( accuIndex ) {

			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,

				binding = this.binding;

			this.cumulativeWeight = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				var originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {

			var binding = this.binding;

			var buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * 3;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			this.cumulativeWeight = 0;

		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {

			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		},


		// mix functions

		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		},

		_slerp: function ( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		},

		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

			var s = 1 - t;

			for ( var i = 0; i !== stride; ++ i ) {

				var j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

	} );

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	// Characters [].:/ are reserved for track binding syntax.
	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	function Composite( targetGroup, path, optionalParsedPath ) {

		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		},

		setValue: function ( array, offset ) {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: ( function () {

			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );

			return function sanitizeNodeName( name ) {

				return name.replace( /\s/g, '_' ).replace( reservedRe, '' );

			};

		}() ),

		parseTrackName: function () {

			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );

			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );

			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );

			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );

			var trackRe = new RegExp( ''
				+ '^'
				+ directoryRe
				+ nodeRe
				+ objectRe
				+ propertyRe
				+ '$'
			);

			var supportedObjectNames = [ 'material', 'materials', 'bones' ];

			return function parseTrackName( trackName ) {

				var matches = trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== - 1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			};

		}(),

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === "morphTargetInfluences" ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}


					} else {

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */

	function AnimationObjectGroup() {

		this.uuid = _Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

		var scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	Object.assign( AnimationObjectGroup.prototype, {

		isAnimationObjectGroup: true,

		add: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length,
				knownObject = undefined;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
							'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		remove: function () {

			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// remove & forget
		uncache: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_: function ( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		},

		unsubscribe_: function ( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	} );

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	function AnimationAction( mixer, clip, localRoot ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;

		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( var i = 0; i !== nTracks; ++ i ) {

			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants;	// bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; 		// no. of repetitions when looping

		this.paused = false;				// true -> zero effective time scale
		this.enabled = true;				// false -> zero effective weight

		this.clampWhenFinished 	= false;	// keep feeding the last frame?

		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

	}

	Object.assign( AnimationAction.prototype, {

		// State & Scheduling

		play: function () {

			this._mixer._activateAction( this );

			return this;

		},

		stop: function () {

			this._mixer._deactivateAction( this );

			return this.reset();

		},

		reset: function () {

			this.paused = false;
			this.enabled = true;

			this.time = 0;			// restart clip
			this._loopCount = - 1;	// forget previous loops
			this._startTime = null;	// forget scheduling

			return this.stopFading().stopWarping();

		},

		isRunning: function () {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this );

		},

		// return true when play has been called
		isScheduled: function () {

			return this._mixer._isActiveAction( this );

		},

		startAt: function ( time ) {

			this._startTime = time;

			return this;

		},

		setLoop: function ( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		},

		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {

			return this._effectiveWeight;

		},

		fadeIn: function ( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		},

		fadeOut: function ( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		},

		crossFadeFrom: function ( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		},

		crossFadeTo: function ( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		},

		stopFading: function () {

			var weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		},

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {

			return this._effectiveTimeScale;

		},

		setDuration: function ( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		},

		syncWith: function ( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		},

		halt: function ( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		},

		warp: function ( startTimeScale, endTimeScale, duration ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,

				timeScale = this.timeScale;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		},

		stopWarping: function () {

			var timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		},

		// Object Accessors

		getMixer: function () {

			return this._mixer;

		},

		getClip: function () {

			return this._clip;

		},

		getRoot: function () {

			return this._localRoot || this._mixer._root;

		},

		// Interna

		_update: function ( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			var startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			var weight = this._updateWeight( time );

			if ( weight > 0 ) {

				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );

				}

			}

		},

		_updateWeight: function ( time ) {

			var weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		},

		_updateTimeScale: function ( time ) {

			var timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				var interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		},

		_updateTime: function ( deltaTime ) {

			var time = this.time + deltaTime;

			if ( deltaTime === 0 ) return time;

			var duration = this._clip.duration,

				loop = this.loop,
				loopCount = this._loopCount;

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else break handle_stop;

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				var pingPong = ( loop === LoopPingPong );

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					var pending = this.repetitions - loopCount;

					if ( pending < 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 0 ) {

							// entering the last round

							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					this.time = time;
					return duration - time;

				}

			}

			this.time = time;
			return time;

		},

		_setEndings: function ( atStart, atEnd, pingPong ) {

			var settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart 	= ZeroSlopeEnding;
				settings.endingEnd		= ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		},

		_scheduleFading: function ( duration, weightNow, weightThen ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

			return this;

		}

	} );

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function AnimationMixer( root ) {

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;

	}

	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: AnimationMixer,

		_bindAction: function ( action, prototypeAction ) {

			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( var i = 0; i !== nTracks; ++ i ) {

				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		},

		_activateAction: function ( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				var bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		},

		_deactivateAction: function ( action ) {

			if ( this._isActiveAction( action ) ) {

				var bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		},

		// Memory manager

		_initMemoryManager: function () {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< AnimationAction >	- used as prototypes
			// 		actionByRoot: AnimationAction			- lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			var scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		},

		// Memory management for AnimationAction objects

		_isActiveAction: function ( action ) {

			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		},

		_addInactiveAction: function ( action, clipUuid, rootUuid ) {

			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				var knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		},

		_removeInactiveAction: function ( action ) {

			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		},

		_removeInactiveBindingsForAction: function ( action ) {

			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		},

		_lendAction: function ( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		},

		_takeBackAction: function ( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding: function ( binding, rootUuid, trackName ) {

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				bindings = this._bindings;

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		},

		_removeInactiveBinding: function ( binding ) {

			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			remove_empty_map: {

				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

				delete bindingsByRoot[ rootUuid ];

			}

		},

		_lendBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		},

		_takeBackBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant: function () {

			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		},

		_takeBackControlInterpolant: function ( interpolant ) {

			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		},

		_controlInterpolantsResultBuffer: new Float32Array( 1 ),

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject !== null ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;

			if ( actionsForClip !== undefined ) {

				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		},

		// get an existing action
		existingAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		},

		// deactivates all previously scheduled actions
		stopAllAction: function () {

			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for ( var i = 0; i !== nActions; ++ i ) {

				actions[ i ].reset();

			}

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].useCount = 0;

			}

			return this;

		},

		// advance the time and update apply the animation
		update: function ( deltaTime ) {

			deltaTime *= this.timeScale;

			var actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( var i = 0; i !== nActions; ++ i ) {

				var action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			var bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		},

		// return this mixer's root target object
		getRoot: function () {

			return this._root;

		},

		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {

			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				var actionsToRemove = actionsForClip.knownActions;

				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					var action = actionsToRemove[ i ];

					this._deactivateAction( action );

					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		},

		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {

			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( var clipUuid in actionsByClip ) {

				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( var trackName in bindingByName ) {

					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		},

		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {

			var action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	Uniform.prototype.clone = function () {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.maxInstancedCount = source.maxInstancedCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.uuid = _Math.generateUUID();

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer( array, stride ) {

		this.uuid = _Math.generateUUID();

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.onUploadCallback = function () {};

		this.version = 0;

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

		BufferAttribute.call( this, array, itemSize );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	function Raycaster( origin, direction, near, far ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( ( camera && camera.isPerspectiveCamera ) ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( ( camera && camera.isOrthographicCamera ) ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	Object.assign( Clock.prototype, {

		start: function () {

			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */

	function Spherical( radius, phi, theta ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
		this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

		return this;

	}

	Object.assign( Spherical.prototype, {

		set: function ( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = vec3.length();

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
				this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

			}

			return this;

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */

	function Cylindrical( radius, theta, y ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

		return this;

	}

	Object.assign( Cylindrical.prototype, {

		set: function ( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
			this.theta = Math.atan2( vec3.x, vec3.z );
			this.y = vec3.y;

			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Box2( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

	}

	Object.assign( Box2.prototype, {

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector2();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		getCenter: function ( optionalTarget ) {

			var result = optionalTarget || new Vector2();
			return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( optionalTarget ) {

			var result = optionalTarget || new Vector2();
			return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		intersectsBox: function ( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector2();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function VertexNormalsHelper( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count;

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	}

	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

	VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function SpotLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new BufferGeometry();

		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;

	SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	SpotLightHelper.prototype.update = function () {

		var vector = new Vector3();
		var vector2 = new Vector3();

		return function update() {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

	}();

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function getBoneList( object ) {

		var boneList = [];

		if ( object && object.isBone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	function SkeletonHelper( object ) {

		var bones = getBoneList( object );

		var geometry = new BufferGeometry();

		var vertices = [];
		var colors = [];

		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );

		for ( var i = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		LineSegments.call( this, geometry, material );

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;

	SkeletonHelper.prototype.updateMatrixWorld = function () {

		var vector = new Vector3();

		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();

		return function updateMatrixWorld( force ) {

			var bones = this.bones;

			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );

			matrixWorldInv.getInverse( this.root.matrixWorld );

			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PointLightHelper( light, sphereSize, color ) {

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

		Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	}

	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;

	PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	PointLightHelper.prototype.update = function () {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function RectAreaLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var material = new LineBasicMaterial( { fog: false } );

		var geometry = new BufferGeometry();

		geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );

		this.line = new Line( geometry, material );
		this.add( this.line );


		this.update();

	}

	RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

	RectAreaLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	RectAreaLightHelper.prototype.update = function () {

		// calculate new dimensions of the helper

		var hx = this.light.width * 0.5;
		var hy = this.light.height * 0.5;

		var position = this.line.geometry.attributes.position;
		var array = position.array;

		// update vertices

		array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
		array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
		array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
		array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
		array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;

		position.needsUpdate = true;

		if ( this.color !== undefined ) {

			this.line.material.color.set( this.color );

		} else {

			this.line.material.color.copy( this.light.color );

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function HemisphereLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;

		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );

		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

	HemisphereLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	HemisphereLightHelper.prototype.update = function () {

		var vector = new Vector3();

		var color1 = new Color();
		var color2 = new Color();

		return function update() {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? color1 : color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function GridHelper( size, divisions, color1, color2 ) {

		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;

		var vertices = [], colors = [];

		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			var color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	GridHelper.prototype = Object.create( LineSegments.prototype );
	GridHelper.prototype.constructor = GridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */

	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var vertices = [];
		var colors = [];

		var x, z;
		var v, i, j, r, color;

		// create the radials

		for ( i = 0; i <= radials; i ++ ) {

			v = ( i / radials ) * ( Math.PI * 2 );

			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( i = 0; i <= circles; i ++ ) {

			color = ( i & 1 ) ? color1 : color2;

			r = radius - ( radius / circles * i );

			for ( j = 0; j < divisions; j ++ ) {

				// first vertex

				v = ( j / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function FaceNormalsHelper( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	}

	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

	FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function DirectionalLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

	DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	DirectionalLightHelper.prototype.update = function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();

		return function update() {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( v3 );
			this.targetLine.scale.z = v3.length();

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	function CameraHelper( camera ) {

		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

		var vertices = [];
		var colors = [];

		var pointMap = {};

		// colors

		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		LineSegments.call( this, geometry, material );

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new Vector3();
		var camera = new Camera();

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				var position = geometry.getAttribute( 'position' );

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

				}

			}

		}

		return function update() {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );

			// near

			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );

			// far

			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );

			// up

			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );

			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function BoxHelper( object, color ) {

		this.object = object;

		if ( color === undefined ) color = 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.matrixAutoUpdate = false;

		this.update();

	}

	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;

	BoxHelper.prototype.update = ( function () {

		var box = new Box3();

		return function update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				box.setFromObject( this.object );

			}

			if ( box.isEmpty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		};

	} )();

	BoxHelper.prototype.setFromObject = function ( object ) {

		this.object = object;
		this.update();

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3Helper( box, hex ) {

		this.type = 'Box3Helper';

		this.box = box;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		var geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.geometry.computeBoundingSphere();

	}

	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;

	Box3Helper.prototype.updateMatrixWorld = function ( force ) {

		var box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function PlaneHelper( plane, size, hex ) {

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = ( size === undefined ) ? 1 : size;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		//

		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

	}

	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;

	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

		var scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.lookAt( this.plane.normal );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	var lineGeometry;
	var coneGeometry;

	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( lineGeometry === undefined ) {

			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;

	ArrowHelper.prototype.setDirection = ( function () {

		var axis = new Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );

	};

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AxesHelper( size ) {

		size = size || 1;

		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );

	}

	var LineStrip = 0;

	var LinePieces = 1;

	function MeshFaceMaterial( materials ) {

		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;

	}

	function MultiMaterial( materials ) {

		if ( materials === undefined ) materials = [];

		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {

			return materials.slice();

		};
		return materials;

	}

	function PointCloud( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function Particle( material ) {

		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );

	}

	function ParticleSystem( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function PointCloudMaterial( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleBasicMaterial( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleSystemMaterial( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function Vertex( x, y, z ) {

		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );

	}

	//

	function DynamicBufferAttribute( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );

	}

	function Int8Attribute( array, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );

	}

	function Uint8Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );

	}

	function Uint8ClampedAttribute( array, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );

	}

	function Int16Attribute( array, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );

	}

	function Uint16Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );

	}

	function Int32Attribute( array, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );

	}

	function Uint32Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );

	}

	function Float32Attribute( array, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );

	}

	function Float64Attribute( array, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );

	}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Object.assign( CurvePath.prototype, {

		createPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from path points (for Line or Points objects)

			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );

		},

		createSpacedPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from equidistant sampling along the path

			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );

		},

		createGeometry: function ( points ) {

			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			var geometry = new Geometry();

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return geometry;

		}

	} );

	//

	Object.assign( Path.prototype, {

		fromPoints: function ( points ) {

			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );

		}

	} );

	//

	function ClosedSplineCurve3( points ) {

		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;

	}

	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function SplineCurve3( points ) {

		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function Spline( points ) {

		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

	Object.assign( Spline.prototype, {

		initFromArray: function ( /* a */ ) {

			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

		},
		getControlPointsArray: function ( /* optionalTarget */ ) {

			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

		}

	} );

	//

	function AxisHelper( size ) {

		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );

	}

	function BoundingBoxHelper( object, color ) {

		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );

	}

	function EdgesHelper( object, hex ) {

		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	GridHelper.prototype.setColors = function () {

		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	SkeletonHelper.prototype.update = function () {

		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

	};

	function WireframeHelper( object, hex ) {

		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	//

	Object.assign( Loader.prototype, {

		extractUrlBase: function ( url ) {

			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );

		}

	} );

	function XHRLoader( manager ) {

		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );

	}

	function BinaryTextureLoader( manager ) {

		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );

	}

	//

	Object.assign( Box2.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Object.assign( Box3.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Line3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Object.assign( _Math, {

		random16: function () {

			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		nearestPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );

		},

		nextPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );

		}

	} );

	Object.assign( Matrix3.prototype, {

		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

		}

	} );

	Object.assign( Matrix4.prototype, {

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},
		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		getPosition: function () {

			var v1;

			return function getPosition() {

				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );

			};

		}(),
		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );

		},
		multiplyToArray: function () {

			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

		},
		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );

		},
		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		translate: function () {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},
		rotateX: function () {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},
		rotateY: function () {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},
		rotateZ: function () {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},
		rotateByAxis: function () {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {

			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );

		}

	} );

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Object.assign( Ray.prototype, {

		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionPlane: function ( plane ) {

			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		}

	} );

	Object.assign( Shape.prototype, {

		extractAllPoints: function ( divisions ) {

			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );

		},
		extrude: function ( options ) {

			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );

		},
		makeGeometry: function ( options ) {

			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );

		}

	} );

	Object.assign( Vector2.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector3.prototype, {

		setEulerFromRotationMatrix: function () {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},
		setEulerFromQuaternion: function () {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},
		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );

		},
		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );

		},
		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );

		},
		applyProjection: function ( m ) {

			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );

		},
		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector4.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	//

	Object.assign( Geometry.prototype, {

		computeTangents: function () {

			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

		},
		computeLineDistances: function () {

			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

		}

	} );

	Object.assign( Object3D.prototype, {

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},
		renderDepth: function () {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},
		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		}

	} );

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Object.defineProperties( LOD.prototype, {

		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}

	} );

	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

		get: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		}

	} );

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		}

	} );

	Object.assign( BufferGeometry.prototype, {

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},
		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},
		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},
		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},
		computeOffsets: function () {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

		}

	} );

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	//

	Object.defineProperties( Uniform.prototype, {

		dynamic: {
			set: function () {

				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

			}
		},
		onUpdate: {
			value: function () {

				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;

			}
		}

	} );

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},
		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		}

	} );

	Object.defineProperties( MeshPhongMaterial.prototype, {

		metal: {
			get: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	Object.assign( WebGLRenderer.prototype, {

		getCurrentRenderTarget: function () {

			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();

		},

		getMaxAnisotropy: function () {

			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();

		},

		getPrecision: function () {

			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;

		},

		resetGLState: function () {

			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();

		},

		supportsFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );

		},
		supportsHalfFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );

		},
		supportsStandardDerivatives: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );

		},
		supportsCompressedTextureS3TC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

		},
		supportsCompressedTexturePVRTC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		},
		supportsBlendMinMax: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );

		},
		supportsVertexTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;

		},
		supportsInstancedArrays: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );

		},
		enableScissorTest: function ( boolean ) {

			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );

		},
		initMaterial: function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		},
		addPrePlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		},
		addPostPlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		},
		updateShadowMap: function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		},
		setFaceCulling: function () {

			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

		}

	} );

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		}
	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Object.defineProperties( WebVRManager.prototype, {

		standing: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .standing has been removed.' );

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	AudioAnalyser.prototype.getData = function () {

		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	//

	var GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;

			if ( geometry2.isMesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	var ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

			var loader = new TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( url, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadTextureCube: function ( urls, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

			var loader = new CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( urls, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadCompressedTexture: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

		},

		loadCompressedTextureCube: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

		}

	};

	//

	function Projector() {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function () {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	}

	//

	function CanvasRenderer() {

		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	}

	//

	var SceneUtils = {

		createMultiMaterialObject: function ( /* geometry, materials */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		detach: function ( /* child, parent, scene */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		attach: function ( /* child, scene, parent */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		}

	};

	//

	function LensFlare() {

		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );

	}

	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.LineLoop = LineLoop;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.Texture = Texture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.JSONLoader = JSONLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.FontLoader = FontLoader;
	exports.FileLoader = FileLoader;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.RectAreaLight = RectAreaLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.ArrayCamera = ArrayCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.AudioContext = AudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.Face3 = Face3;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Cylindrical = Cylindrical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.Color = Color;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.RectAreaLightHelper = RectAreaLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.PolarGridHelper = PolarGridHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoxHelper = BoxHelper;
	exports.Box3Helper = Box3Helper;
	exports.PlaneHelper = PlaneHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxesHelper = AxesHelper;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ShapeUtils = ShapeUtils;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.TextBufferGeometry = TextBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.BufferAttribute = BufferAttribute;
	exports.ArcCurve = ArcCurve;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.EllipseCurve = EllipseCurve;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.SplineCurve = SplineCurve;
	exports.REVISION = REVISION;
	exports.MOUSE = MOUSE;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.CubeGeometry = BoxGeometry;
	exports.Face4 = Face4;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.PointCloud = PointCloud;
	exports.Particle = Particle;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float64Attribute = Float64Attribute;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.Spline = Spline;
	exports.AxisHelper = AxisHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.XHRLoader = XHRLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.GeometryUtils = GeometryUtils;
	exports.ImageUtils = ImageUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;
	exports.SceneUtils = SceneUtils;
	exports.LensFlare = LensFlare;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJDb250cm9sbGVycy9JbmRleENvbnRyb2xsZXIudHMiLCJhcHAudHMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWUvYnVpbGQvdGhyZWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLDZCQUErQjtBQUUvQixhQUFhO0FBRWI7SUFFSTtJQUVBLENBQUM7SUFTRCw4QkFBSSxHQUFKO1FBRUgsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBRSxFQUFFLEVBQUUsTUFBTSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUUsQ0FBQztRQUNsRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTNCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFL0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUUsQ0FBQztRQUN2RCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFFL0MsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFFLENBQUM7UUFDM0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBRSxDQUFDO1FBRTVCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxLQUFLLENBQUMsYUFBYSxDQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFFLENBQUM7UUFDL0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUUsTUFBTSxDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsV0FBVyxDQUFFLENBQUM7UUFDNUQsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUUsQ0FBQztRQUV0RCxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELGlDQUFPLEdBQVA7UUFFSSxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFFbkIscUJBQXFCLENBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBRSxDQUFDO1FBRXRDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQztRQUUxQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUUsQ0FBQztJQUVwRCxDQUFDO0lBK0ZELHNCQUFDO0FBQUQsQ0EzSUEsQUEySUMsSUFBQTtBQTNJWSwwQ0FBZTs7Ozs7QUNINUIsY0FBYztBQUNkLGlFQUFnRTtBQUVoRSxXQUFXO0FBRVgsaURBQWlEO0FBRWpELGNBQWM7QUFDZCxJQUFJLGVBQWUsR0FBRyxJQUFJLGlDQUFlLEVBQUUsQ0FBQztBQUU1QyxlQUFlLENBQUMsSUFBSSxFQUFFLENBQUM7OztBQ1h2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSBcInRocmVlXCI7XG5cbi8vIEludGVyZmFjZXNcblxuZXhwb3J0IGNsYXNzIEluZGV4Q29udHJvbGxlciAge1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKCkgXG4gICAge1xuICAgIH1cblxuICAgIHByaXZhdGUgY2FtZXJhOmFueTtcbiAgICBwcml2YXRlIHNjZW5lOmFueTtcbiAgICBwcml2YXRlIHJlbmRlcmVyOmFueTtcbiAgICBwcml2YXRlIGdlb21ldHJ5OmFueTtcbiAgICBwcml2YXRlIG1hdGVyaWFsOmFueTtcbiAgICBwcml2YXRlIG1lc2g6YW55O1xuXG4gICAgaW5pdCgpIHtcblxuXHR0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggNzAsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjAxLCAxMCApO1xuXHR0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTtcblxuXHR0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cblx0dGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMC4yLCAwLjIsIDAuMiApO1xuXHR0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCgpO1xuXG5cdHRoaXMubWVzaCA9IG5ldyBUSFJFRS5NZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XG5cdHRoaXMuc2NlbmUuYWRkKCB0aGlzLm1lc2ggKTtcblxuXHR0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoIHsgYW50aWFsaWFzOiB0cnVlIH0gKTtcblx0dGhpcy5yZW5kZXJlci5zZXRTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0ICk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggdGhpcy5yZW5kZXJlci5kb21FbGVtZW50ICk7XG4gICAgXG4gICAgdGhpcy5hbmltYXRlKCk7XG59XG5cbmFuaW1hdGUoKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzZWxmLmFuaW1hdGUgKTtcblxuXHR0aGlzLm1lc2gucm90YXRpb24ueCArPSAwLjAxO1xuXHR0aGlzLm1lc2gucm90YXRpb24ueSArPSAwLjAyO1xuXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhICk7XG4gICAgXG59XG5cbiAgICAvKmluaXQoKSBcbiAgICB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIFxuXG4gICAgICAgIFxuICAgICAgICAvLyAgUmVnYXJkbGVzcywgbGV04oCZcyBraWNrIG9mZiB0aGUgVGhyZWUuanMgYmFzaWNzIGhlcmU6XG5cbiAgICAgICAgdmFyIGNhbWVyYSwgc2NlbmUsIHJlbmRlcmVyLCBjb250cm9sc1xuXG5cbiAgICAgICAgLy8gIFdlIG5lZWQgYSByZW5kZXJlci5cblxuICAgICAgICByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlIH0pXG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoIDB4Q0NDQ0NDIClcbiAgICAgICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyggd2luZG93LmRldmljZVBpeGVsUmF0aW8gKVxuICAgICAgICByZW5kZXJlci5zZXRTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0IClcbiAgICAgICAgcmVuZGVyZXIudnIuZW5hYmxlZCAgPSB0cnVlXG4gICAgICAgIC8vcmVuZGVyZXIudnIuc3RhbmRpbmcgPSB0cnVlXG4gICAgICAgIHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZVxuICAgICAgICByZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXBcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggcmVuZGVyZXIuZG9tRWxlbWVudCApXG5cblxuICAgICAgICAvLyAgT25jZSB3ZSBjcmVhdGUgdGhlIGNhbWVyYSB3ZeKAmWxsIGF0dGFjaCBpdCB0byB0aGUgc2NlbmUuIFRoaXMgaXMgdXN1YWxseVxuICAgICAgICAvLyAgbm90IG5lY2Vzc2FyeSwgYnV0IHdl4oCZcmUgZ29pbmcgdG8gYXR0YWNoIGEg4oCcaGVhZOKAnSB0byB0aGUgY2FtZXJhIHRoYXQgY2FzdHNcbiAgICAgICAgLy8gIGEgc2hhZG93IHNvIHlvdSBjYW4gc2VlIGV2aWRlbmNlIG9mIHlvdXIgb3duIHByZXNlbmNlLlxuXG4gICAgICAgIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggNTAsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwIClcbiAgICAgICAgc2NlbmUgID0gbmV3IFRIUkVFLlNjZW5lKClcbiAgICAgICAgc2NlbmUuYWRkKCBjYW1lcmEgKVxuXG4gICAgICAgIC8vICBPaywgd2XigJl2ZSBnb3QgdGhlIGJhc2ljIFRocmVlLmpzIG92ZXJoZWFkIG91dCBvZiB0aGUgd2F5LlxuICAgICAgICAvLyAgTm93IGxldOKAmXMgYWRkIHNvbWUgc3R1ZmYgdG8gb3VyIGVtcHR5IHNjZW5lLlxuXG4gICAgICAgIHZhciBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCAweEZGRkZGRiwgMSlcbiAgICAgICAgbGlnaHQucG9zaXRpb24uc2V0KCAgMSwgMTAsIC0wLjUgKVxuICAgICAgICBsaWdodC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgICAgICBsaWdodC5zaGFkb3cubWFwU2l6ZS53aWR0aCAgPSAyMDQ4XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDIwNDhcbiAgICAgICAgbGlnaHQuc2hhZG93LmNhbWVyYS5uZWFyICAgID0gICAgMVxuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLmZhciAgICAgPSAgIDEyXG4gICAgICAgIHNjZW5lLmFkZCggbGlnaHQgKVxuXG4gICAgICAgIHNjZW5lLmFkZCggbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggMHg5MDkwOTAsIDB4NDA0MDQwICkpXG5cblxuICAgICAgICB2YXIgZmxvb3IgPSBuZXcgVEhSRUUuTWVzaChcblxuICAgICAgICAgICAgbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoIDYsIDYsIDEyLCAxMiApLFxuICAgICAgICAgICAgbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcblxuICAgICAgICAgICAgICAgIHJvdWdobmVzczogMS4wLFxuICAgICAgICAgICAgICAgIG1ldGFsbmVzczogMC4wLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAweEZGRkZGRixcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjhcbiAgICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgZmxvb3Iucm90YXRpb24ueCA9IE1hdGguUEkgLyAtMlxuICAgICAgICBmbG9vci5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuICAgICAgICBzY2VuZS5hZGQoIGZsb29yIClcblxuICAgICAgICB2YXIgd2lyZWZyYW1lID0gbmV3IFRIUkVFLk1lc2goXG5cbiAgICAgICAgICAgIGZsb29yLmdlb21ldHJ5LmNsb25lKCksXG4gICAgICAgICAgICBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuXG4gICAgICAgICAgICAgICAgY29sb3I6IDB4RkZGRkZGLFxuICAgICAgICAgICAgICAgIHdpcmVmcmFtZTogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICB3aXJlZnJhbWUucm90YXRpb24ueCA9IE1hdGguUEkgLyAtMlxuICAgICAgICB3aXJlZnJhbWUucG9zaXRpb24ueSA9IC0wLjAwMVxuICAgICAgICBzY2VuZS5hZGQoIHdpcmVmcmFtZSApXG5cbiAgICAgICAgLy8gIFlvdXIgaGVhZCBpcyBnb2luZyB0byBjYXN0IGEgc2hhZG93LlxuICAgICAgICAvLyAgWW91IHdvbuKAmXQgc2VlIHRoaXMgc3BoZXJlIGJlY2F1c2UgaXTigJlzIHNpbmdsZS1zaWRlZCBiZSBkZWZhdWx0XG4gICAgICAgIC8vICBhbmQgdGhlIGNhbWVyYSBpcyBzaXR0aW5nIG9uIHRoZSBpbnNpZGUgOylcblxuICAgICAgICB2YXIgdG9ydXMgPSBuZXcgVEhSRUUuTWVzaChcblxuICAgICAgICAgICAgbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KCAwLjQsIDAuMTUsIDI1NiwgMzIgKSxcbiAgICAgICAgICAgIG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7IHJvdWdobmVzczogMC4wMSwgbWV0YWxuZXNzOiAwLjIgfSlcbiAgICAgICAgKVxuICAgICAgICB0b3J1cy5wb3NpdGlvbi5zZXQoIC0wLjI1LCAxLjQsIC0xLjUgKVxuICAgICAgICB0b3J1cy5jYXN0U2hhZG93ICAgID0gdHJ1ZVxuICAgICAgICB0b3J1cy5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuICAgICAgICBzY2VuZS5hZGQoIHRvcnVzIClcblxuICAgICAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKVxuICAgIH0qL1xufSIsIlxuLy8gQ29udHJvbGxlcnNcbmltcG9ydCB7IEluZGV4Q29udHJvbGxlciB9IGZyb20gXCIuL0NvbnRyb2xsZXJzL0luZGV4Q29udHJvbGxlclwiO1xuXG4vLyBTZXJ2aWNlc1xuXG4vLyBJbnN0YW50aWF0ZSBTZXJ2aWNlcyB3aXRoIGRlcGVuZGVuY3kgaW5qZWN0aW9uXG5cbi8vIENvbnRyb2xsZXJzXG5sZXQgaW5kZXhDb250cm9sbGVyID0gbmV3IEluZGV4Q29udHJvbGxlcigpO1xuXG5pbmRleENvbnRyb2xsZXIuaW5pdCgpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5USFJFRSA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8vIFBvbHlmaWxsc1xuXG5cdGlmICggTnVtYmVyLkVQU0lMT04gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdE51bWJlci5FUFNJTE9OID0gTWF0aC5wb3coIDIsIC0gNTIgKTtcblxuXHR9XG5cblx0aWYgKCBOdW1iZXIuaXNJbnRlZ2VyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHQvLyBNaXNzaW5nIGluIElFXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzSW50ZWdlclxuXG5cdFx0TnVtYmVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKCB2YWx1ZSApICYmIE1hdGguZmxvb3IoIHZhbHVlICkgPT09IHZhbHVlO1xuXG5cdFx0fTtcblxuXHR9XG5cblx0Ly9cblxuXHRpZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXG5cblx0XHRNYXRoLnNpZ24gPSBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRcdHJldHVybiAoIHggPCAwICkgPyAtIDEgOiAoIHggPiAwICkgPyAxIDogKyB4O1xuXG5cdFx0fTtcblxuXHR9XG5cblx0aWYgKCAnbmFtZScgaW4gRnVuY3Rpb24ucHJvdG90eXBlID09PSBmYWxzZSApIHtcblxuXHRcdC8vIE1pc3NpbmcgaW4gSUVcblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxzKmZ1bmN0aW9uXFxzKihbXlxcKFxcc10qKS8gKVsgMSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggT2JqZWN0LmFzc2lnbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0Ly8gTWlzc2luZyBpbiBJRVxuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cblxuXHRcdCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0JyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb3V0cHV0ID0gT2JqZWN0KCB0YXJnZXQgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4ICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1sgaW5kZXggXTtcblxuXHRcdFx0XHRcdGlmICggc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbmV4dEtleSBpbiBzb3VyY2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoIHNvdXJjZSwgbmV4dEtleSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0b3V0cHV0WyBuZXh0S2V5IF0gPSBzb3VyY2VbIG5leHRLZXkgXTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdFx0fTtcblxuXHRcdH0gKSgpO1xuXG5cdH1cblxuXHQvKipcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHt9XG5cblx0T2JqZWN0LmFzc2lnbiggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSwge1xuXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0aGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuXHRcdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XG5cblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XG5cblx0XHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gbGlzdGVuZXJBcnJheS5zbGljZSggMCApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdHZhciBSRVZJU0lPTiA9ICc5MCc7XG5cdHZhciBNT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xuXHR2YXIgQ3VsbEZhY2VOb25lID0gMDtcblx0dmFyIEN1bGxGYWNlQmFjayA9IDE7XG5cdHZhciBDdWxsRmFjZUZyb250ID0gMjtcblx0dmFyIEN1bGxGYWNlRnJvbnRCYWNrID0gMztcblx0dmFyIEZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcblx0dmFyIEZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5cdHZhciBCYXNpY1NoYWRvd01hcCA9IDA7XG5cdHZhciBQQ0ZTaGFkb3dNYXAgPSAxO1xuXHR2YXIgUENGU29mdFNoYWRvd01hcCA9IDI7XG5cdHZhciBGcm9udFNpZGUgPSAwO1xuXHR2YXIgQmFja1NpZGUgPSAxO1xuXHR2YXIgRG91YmxlU2lkZSA9IDI7XG5cdHZhciBGbGF0U2hhZGluZyA9IDE7XG5cdHZhciBTbW9vdGhTaGFkaW5nID0gMjtcblx0dmFyIE5vQ29sb3JzID0gMDtcblx0dmFyIEZhY2VDb2xvcnMgPSAxO1xuXHR2YXIgVmVydGV4Q29sb3JzID0gMjtcblx0dmFyIE5vQmxlbmRpbmcgPSAwO1xuXHR2YXIgTm9ybWFsQmxlbmRpbmcgPSAxO1xuXHR2YXIgQWRkaXRpdmVCbGVuZGluZyA9IDI7XG5cdHZhciBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcblx0dmFyIE11bHRpcGx5QmxlbmRpbmcgPSA0O1xuXHR2YXIgQ3VzdG9tQmxlbmRpbmcgPSA1O1xuXHR2YXIgQWRkRXF1YXRpb24gPSAxMDA7XG5cdHZhciBTdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xuXHR2YXIgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XG5cdHZhciBNaW5FcXVhdGlvbiA9IDEwMztcblx0dmFyIE1heEVxdWF0aW9uID0gMTA0O1xuXHR2YXIgWmVyb0ZhY3RvciA9IDIwMDtcblx0dmFyIE9uZUZhY3RvciA9IDIwMTtcblx0dmFyIFNyY0NvbG9yRmFjdG9yID0gMjAyO1xuXHR2YXIgT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcblx0dmFyIFNyY0FscGhhRmFjdG9yID0gMjA0O1xuXHR2YXIgT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcblx0dmFyIERzdEFscGhhRmFjdG9yID0gMjA2O1xuXHR2YXIgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcblx0dmFyIERzdENvbG9yRmFjdG9yID0gMjA4O1xuXHR2YXIgT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcblx0dmFyIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5cdHZhciBOZXZlckRlcHRoID0gMDtcblx0dmFyIEFsd2F5c0RlcHRoID0gMTtcblx0dmFyIExlc3NEZXB0aCA9IDI7XG5cdHZhciBMZXNzRXF1YWxEZXB0aCA9IDM7XG5cdHZhciBFcXVhbERlcHRoID0gNDtcblx0dmFyIEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcblx0dmFyIEdyZWF0ZXJEZXB0aCA9IDY7XG5cdHZhciBOb3RFcXVhbERlcHRoID0gNztcblx0dmFyIE11bHRpcGx5T3BlcmF0aW9uID0gMDtcblx0dmFyIE1peE9wZXJhdGlvbiA9IDE7XG5cdHZhciBBZGRPcGVyYXRpb24gPSAyO1xuXHR2YXIgTm9Ub25lTWFwcGluZyA9IDA7XG5cdHZhciBMaW5lYXJUb25lTWFwcGluZyA9IDE7XG5cdHZhciBSZWluaGFyZFRvbmVNYXBwaW5nID0gMjtcblx0dmFyIFVuY2hhcnRlZDJUb25lTWFwcGluZyA9IDM7XG5cdHZhciBDaW5lb25Ub25lTWFwcGluZyA9IDQ7XG5cdHZhciBVVk1hcHBpbmcgPSAzMDA7XG5cdHZhciBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5cdHZhciBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XG5cdHZhciBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcblx0dmFyIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuXHR2YXIgU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDU7XG5cdHZhciBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcblx0dmFyIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gMzA3O1xuXHR2YXIgUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuXHR2YXIgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5cdHZhciBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcblx0dmFyIE5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xuXHR2YXIgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuXHR2YXIgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG5cdHZhciBMaW5lYXJGaWx0ZXIgPSAxMDA2O1xuXHR2YXIgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5cdHZhciBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuXHR2YXIgVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5cdHZhciBCeXRlVHlwZSA9IDEwMTA7XG5cdHZhciBTaG9ydFR5cGUgPSAxMDExO1xuXHR2YXIgVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuXHR2YXIgSW50VHlwZSA9IDEwMTM7XG5cdHZhciBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuXHR2YXIgRmxvYXRUeXBlID0gMTAxNTtcblx0dmFyIEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xuXHR2YXIgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcblx0dmFyIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTg7XG5cdHZhciBVbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTk7XG5cdHZhciBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xuXHR2YXIgQWxwaGFGb3JtYXQgPSAxMDIxO1xuXHR2YXIgUkdCRm9ybWF0ID0gMTAyMjtcblx0dmFyIFJHQkFGb3JtYXQgPSAxMDIzO1xuXHR2YXIgTHVtaW5hbmNlRm9ybWF0ID0gMTAyNDtcblx0dmFyIEx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyNTtcblx0dmFyIFJHQkVGb3JtYXQgPSBSR0JBRm9ybWF0O1xuXHR2YXIgRGVwdGhGb3JtYXQgPSAxMDI2O1xuXHR2YXIgRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcblx0dmFyIFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG5cdHZhciBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3Nztcblx0dmFyIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDMzNzc4O1xuXHR2YXIgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XG5cdHZhciBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xuXHR2YXIgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MTtcblx0dmFyIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xuXHR2YXIgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5cdHZhciBSR0JfRVRDMV9Gb3JtYXQgPSAzNjE5Njtcblx0dmFyIFJHQkFfQVNUQ180eDRfRm9ybWF0ID0gMzc4MDg7XG5cdHZhciBSR0JBX0FTVENfNXg0X0Zvcm1hdCA9IDM3ODA5O1xuXHR2YXIgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcblx0dmFyIFJHQkFfQVNUQ182eDVfRm9ybWF0ID0gMzc4MTE7XG5cdHZhciBSR0JBX0FTVENfNng2X0Zvcm1hdCA9IDM3ODEyO1xuXHR2YXIgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcblx0dmFyIFJHQkFfQVNUQ184eDZfRm9ybWF0ID0gMzc4MTQ7XG5cdHZhciBSR0JBX0FTVENfOHg4X0Zvcm1hdCA9IDM3ODE1O1xuXHR2YXIgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XG5cdHZhciBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzgxNztcblx0dmFyIFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODE4O1xuXHR2YXIgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuXHR2YXIgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xuXHR2YXIgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODIxO1xuXHR2YXIgTG9vcE9uY2UgPSAyMjAwO1xuXHR2YXIgTG9vcFJlcGVhdCA9IDIyMDE7XG5cdHZhciBMb29wUGluZ1BvbmcgPSAyMjAyO1xuXHR2YXIgSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IDIzMDA7XG5cdHZhciBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XG5cdHZhciBJbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XG5cdHZhciBaZXJvQ3VydmF0dXJlRW5kaW5nID0gMjQwMDtcblx0dmFyIFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG5cdHZhciBXcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcblx0dmFyIFRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcblx0dmFyIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG5cdHZhciBUcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcblx0dmFyIExpbmVhckVuY29kaW5nID0gMzAwMDtcblx0dmFyIHNSR0JFbmNvZGluZyA9IDMwMDE7XG5cdHZhciBHYW1tYUVuY29kaW5nID0gMzAwNztcblx0dmFyIFJHQkVFbmNvZGluZyA9IDMwMDI7XG5cdHZhciBMb2dMdXZFbmNvZGluZyA9IDMwMDM7XG5cdHZhciBSR0JNN0VuY29kaW5nID0gMzAwNDtcblx0dmFyIFJHQk0xNkVuY29kaW5nID0gMzAwNTtcblx0dmFyIFJHQkRFbmNvZGluZyA9IDMwMDY7XG5cdHZhciBCYXNpY0RlcHRoUGFja2luZyA9IDMyMDA7XG5cdHZhciBSR0JBRGVwdGhQYWNraW5nID0gMzIwMTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0dmFyIF9NYXRoID0ge1xuXG5cdFx0REVHMlJBRDogTWF0aC5QSSAvIDE4MCxcblx0XHRSQUQyREVHOiAxODAgLyBNYXRoLlBJLFxuXG5cdFx0Z2VuZXJhdGVVVUlEOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cblx0XHRcdHZhciBsdXQgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMjU2OyBpICsrICkge1xuXG5cdFx0XHRcdGx1dFsgaSBdID0gKCBpIDwgMTYgPyAnMCcgOiAnJyApICsgKCBpICkudG9TdHJpbmcoIDE2ICkudG9VcHBlckNhc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG5cdFx0XHRcdHZhciBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHRcdFx0dmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRcdFx0XHR2YXIgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdFx0XHRcdHZhciBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0XHRcdFx0cmV0dXJuIGx1dFsgZDAgJiAweGZmIF0gKyBsdXRbIGQwID4+IDggJiAweGZmIF0gKyBsdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMCA+PiAyNCAmIDB4ZmYgXSArICctJyArXG5cdFx0XHRcdFx0bHV0WyBkMSAmIDB4ZmYgXSArIGx1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIGx1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgbHV0WyBkMSA+PiAyNCAmIDB4ZmYgXSArICctJyArXG5cdFx0XHRcdFx0bHV0WyBkMiAmIDB4M2YgfCAweDgwIF0gKyBsdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBsdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMiA+PiAyNCAmIDB4ZmYgXSArXG5cdFx0XHRcdFx0bHV0WyBkMyAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBsdXRbIGQzID4+IDI0ICYgMHhmZiBdO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSApKCksXG5cblx0XHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXG5cdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuXG5cdFx0ZXVjbGlkZWFuTW9kdWxvOiBmdW5jdGlvbiAoIG4sIG0gKSB7XG5cblx0XHRcdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cblx0XHR9LFxuXG5cdFx0Ly8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuXG5cdFx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdFx0XHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvblxuXG5cdFx0bGVycDogZnVuY3Rpb24gKCB4LCB5LCB0ICkge1xuXG5cdFx0XHRyZXR1cm4gKCAxIC0gdCApICogeCArIHQgKiB5O1xuXG5cdFx0fSxcblxuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuXG5cdFx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcblxuXHRcdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0XHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG5cdFx0XHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG5cdFx0fSxcblxuXHRcdHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcblxuXHRcdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdFx0XHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG5cdFx0XHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG5cdFx0fSxcblxuXHRcdC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXHRcdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG5cdFx0fSxcblxuXHRcdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblx0XHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG5cdFx0XHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xuXG5cdFx0fSxcblxuXHRcdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuXHRcdHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcblxuXHRcdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XG5cblx0XHR9LFxuXG5cdFx0ZGVnVG9SYWQ6IGZ1bmN0aW9uICggZGVncmVlcyApIHtcblxuXHRcdFx0cmV0dXJuIGRlZ3JlZXMgKiBfTWF0aC5ERUcyUkFEO1xuXG5cdFx0fSxcblxuXHRcdHJhZFRvRGVnOiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XG5cblx0XHRcdHJldHVybiByYWRpYW5zICogX01hdGguUkFEMkRFRztcblxuXHRcdH0sXG5cblx0XHRpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xuXG5cdFx0fSxcblxuXHRcdGNlaWxQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguY2VpbCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cblx0XHR9LFxuXG5cdFx0Zmxvb3JQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG5cdCAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICovXG5cblx0ZnVuY3Rpb24gVmVjdG9yMiggeCwgeSApIHtcblxuXHRcdHRoaXMueCA9IHggfHwgMDtcblx0XHR0aGlzLnkgPSB5IHx8IDA7XG5cblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWZWN0b3IyLnByb3RvdHlwZSwge1xuXG5cdFx0XCJ3aWR0aFwiOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLng7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHR0aGlzLnggPSB2YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdFwiaGVpZ2h0XCI6IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMueTtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdHRoaXMueSA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIFZlY3RvcjIucHJvdG90eXBlLCB7XG5cblx0XHRpc1ZlY3RvcjI6IHRydWUsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHRcdHRoaXMueSA9IHNjYWxhcjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0XHR0aGlzLnggPSB4O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHRcdHRoaXMueSA9IHk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXHRcdFx0dGhpcy55ID0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCArPSB2Lng7XG5cdFx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdFx0dGhpcy54ICs9IHM7XG5cdFx0XHR0aGlzLnkgKz0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0XHR0aGlzLnkgLT0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdFx0dGhpcy54IC09IHM7XG5cdFx0XHR0aGlzLnkgLT0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0XHR0aGlzLnkgKj0gdi55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54IC89IHYueDtcblx0XHRcdHRoaXMueSAvPSB2Lnk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuXHRcdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXTtcblx0XHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbWluID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciBtYXggPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XG5cdFx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdFx0fSxcblxuXHRcdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG5cdFx0fSxcblxuXHRcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuXHRcdH0sXG5cblx0XHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcblxuXHRcdH0sXG5cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHRcdH0sXG5cblx0XHRhbmdsZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xuXG5cdFx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKCB0aGlzLnksIHRoaXMueCApO1xuXG5cdFx0XHRpZiAoIGFuZ2xlIDwgMCApIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xuXG5cdFx0XHRyZXR1cm4gYW5nbGU7XG5cblx0XHR9LFxuXG5cdFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xuXHRcdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdFx0fSxcblxuXHRcdG1hbmhhdHRhbkRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0XHR9LFxuXG5cdFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH0sXG5cblx0XHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xuXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRcdHZhciB4ID0gdGhpcy54IC0gY2VudGVyLng7XG5cdFx0XHR2YXIgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG5cdFx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG5cdFx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cblx0ICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cblx0ICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxuXHQgKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICovXG5cblx0ZnVuY3Rpb24gTWF0cml4NCgpIHtcblxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIE1hdHJpeDQucHJvdG90eXBlLCB7XG5cblx0XHRpc01hdHJpeDQ6IHRydWUsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcblx0XHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xuXHRcdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XG5cdFx0XHR0ZVsgOCBdID0gbWVbIDggXTsgdGVbIDkgXSA9IG1lWyA5IF07IHRlWyAxMCBdID0gbWVbIDEwIF07IHRlWyAxMSBdID0gbWVbIDExIF07XG5cdFx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcblx0XHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4dHJhY3RCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG5cdFx0XHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XG5cdFx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG5cdFx0XHR6QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAyICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG1ha2VCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcblx0XHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcblx0XHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdFx0MCwgMCwgMCwgMVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBleHRyYWN0Um90YXRpb24oIG0gKSB7XG5cblx0XHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuXHRcdFx0XHR2YXIgc2NhbGVYID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XG5cdFx0XHRcdHZhciBzY2FsZVogPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdFx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcblx0XHRcdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XG5cblx0XHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0XHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuXHRcdFx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcblxuXHRcdFx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHRcdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG5cdFx0XHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0XHR2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdFx0dmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcblx0XHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHRcdHRlWyA4IF0gPSBkO1xuXG5cdFx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0XHR0ZVsgOSBdID0gLSBiICogYztcblxuXHRcdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcblx0XHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xuXHRcdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdFx0dGVbIDEgXSA9IGEgKiBmO1xuXHRcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xuXHRcdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XG5cdFx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0XHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XG5cdFx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xuXHRcdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xuXHRcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0XHR0ZVsgMiBdID0gLSBhICogZDtcblx0XHRcdFx0dGVbIDYgXSA9IGI7XG5cdFx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdFx0dGVbIDggXSA9IGFlICogZCArIGJmO1xuXG5cdFx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0XHR0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XG5cblx0XHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XG5cdFx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0XHR0ZVsgMSBdID0gZjtcblx0XHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcblx0XHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xuXHRcdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0XHR0ZVsgNCBdID0gLSBmO1xuXHRcdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xuXHRcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0XHR0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XG5cdFx0XHRcdHRlWyA2IF0gPSBiICogZTtcblx0XHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdFx0dGVbIDMgXSA9IDA7XG5cdFx0XHR0ZVsgNyBdID0gMDtcblx0XHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdFx0Ly8gYm90dG9tIHJvd1xuXHRcdFx0dGVbIDEyIF0gPSAwO1xuXHRcdFx0dGVbIDEzIF0gPSAwO1xuXHRcdFx0dGVbIDE0IF0gPSAwO1xuXHRcdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgeCA9IHEuX3gsIHkgPSBxLl95LCB6ID0gcS5feiwgdyA9IHEuX3c7XG5cdFx0XHR2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcblx0XHRcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xuXHRcdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuXHRcdFx0dGVbIDAgXSA9IDEgLSAoIHl5ICsgenogKTtcblx0XHRcdHRlWyA0IF0gPSB4eSAtIHd6O1xuXHRcdFx0dGVbIDggXSA9IHh6ICsgd3k7XG5cblx0XHRcdHRlWyAxIF0gPSB4eSArIHd6O1xuXHRcdFx0dGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcblx0XHRcdHRlWyA5IF0gPSB5eiAtIHd4O1xuXG5cdFx0XHR0ZVsgMiBdID0geHogLSB3eTtcblx0XHRcdHRlWyA2IF0gPSB5eiArIHd4O1xuXHRcdFx0dGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XG5cblx0XHRcdC8vIGxhc3QgY29sdW1uXG5cdFx0XHR0ZVsgMyBdID0gMDtcblx0XHRcdHRlWyA3IF0gPSAwO1xuXHRcdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0XHQvLyBib3R0b20gcm93XG5cdFx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgeCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgeSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgeiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuXHRcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHRcdHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKTtcblxuXHRcdFx0XHRpZiAoIHoubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRcdFx0ei56ID0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ei5ub3JtYWxpemUoKTtcblx0XHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICk7XG5cblx0XHRcdFx0aWYgKCB4Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHQvLyB1cCBhbmQgeiBhcmUgcGFyYWxsZWxcblxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0ei54ICs9IDAuMDAwMTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHoueiArPSAwLjAwMDE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR6Lm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR4Lm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHR5LmNyb3NzVmVjdG9ycyggeiwgeCApO1xuXG5cdFx0XHRcdHRlWyAwIF0gPSB4Lng7IHRlWyA0IF0gPSB5Lng7IHRlWyA4IF0gPSB6Lng7XG5cdFx0XHRcdHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XG5cdFx0XHRcdHRlWyAyIF0gPSB4Lno7IHRlWyA2IF0gPSB5Lno7IHRlWyAxMCBdID0gei56O1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcblxuXHRcdFx0aWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdFx0fSxcblxuXHRcdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHZhciBhZSA9IGEuZWxlbWVudHM7XG5cdFx0XHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuXHRcdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcblx0XHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cblx0XHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHRcdHZhciBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcblx0XHRcdHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG5cdFx0XHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuXHRcdFx0dGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0Mjtcblx0XHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0XHR0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuXHRcdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcblx0XHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuXHRcdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cblx0XHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0XHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuXHRcdFx0dGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG5cdFx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdFx0dGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcblx0XHRcdHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG5cdFx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHRcdHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xuXHRcdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcblx0XHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHRcdFx0djEueSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XG5cdFx0XHRcdFx0djEueiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XG5cblx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcblx0XHRcdHZhciBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcblx0XHRcdHZhciBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XG5cdFx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG5cdFx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuXHRcdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdG40MSAqIChcblx0XHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxuXHRcdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuXHRcdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xuXHRcdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xuXHRcdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuXHRcdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxuXHRcdFx0XHQpICtcblx0XHRcdFx0bjQyICogKFxuXHRcdFx0XHRcdCsgbjExICogbjIzICogbjM0XG5cdFx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXG5cdFx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG5cdFx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XG5cdFx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXG5cdFx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG5cdFx0XHRcdCkgK1xuXHRcdFx0XHRuNDMgKiAoXG5cdFx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcblx0XHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcblx0XHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcblx0XHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcblx0XHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcblx0XHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcblx0XHRcdFx0KSArXG5cdFx0XHRcdG40NCAqIChcblx0XHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxuXHRcdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuXHRcdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xuXHRcdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxuXHRcdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuXHRcdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxuXHRcdFx0XHQpXG5cblx0XHRcdCk7XG5cblx0XHR9LFxuXG5cdFx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR2YXIgdG1wO1xuXG5cdFx0XHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcblx0XHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XG5cblx0XHRcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG5cdFx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdFx0dG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHYueDtcblx0XHRcdHRlWyAxMyBdID0gdi55O1xuXHRcdFx0dGVbIDE0IF0gPSB2Lno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XG5cblx0XHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cyxcblx0XHRcdFx0bWUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sIG40MSA9IG1lWyAzIF0sXG5cdFx0XHRcdG4xMiA9IG1lWyA0IF0sIG4yMiA9IG1lWyA1IF0sIG4zMiA9IG1lWyA2IF0sIG40MiA9IG1lWyA3IF0sXG5cdFx0XHRcdG4xMyA9IG1lWyA4IF0sIG4yMyA9IG1lWyA5IF0sIG4zMyA9IG1lWyAxMCBdLCBuNDMgPSBtZVsgMTEgXSxcblx0XHRcdFx0bjE0ID0gbWVbIDEyIF0sIG4yNCA9IG1lWyAxMyBdLCBuMzQgPSBtZVsgMTQgXSwgbjQ0ID0gbWVbIDE1IF0sXG5cblx0XHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxuXHRcdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG5cdFx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcblx0XHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXG5cdFx0XHR2YXIgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xuXG5cdFx0XHRpZiAoIGRldCA9PT0gMCApIHtcblxuXHRcdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0OiAuZ2V0SW52ZXJzZSgpIGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcblxuXHRcdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcblx0XHRcdHRlWyAxIF0gPSAoIG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdFx0dGVbIDIgXSA9ICggbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdFx0dGVbIDQgXSA9IHQxMiAqIGRldEludjtcblx0XHRcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdFx0dGVbIDYgXSA9ICggbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsgNyBdID0gKCBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcblx0XHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xuXHRcdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xuXHRcdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcblx0XHRcdHRlWyAxMyBdID0gKCBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQgKSAqIGRldEludjtcblx0XHRcdHRlWyAxNCBdID0gKCBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQgKSAqIGRldEludjtcblx0XHRcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2NhbGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG5cdFx0XHR0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xuXHRcdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuXHRcdFx0dGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcblx0XHRcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcblx0XHRcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XG5cblx0XHR9LFxuXG5cdFx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHRcdDAsIDAsIDEsIHosXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0XHQwLCBjLCAtIHMsIDAsXG5cdFx0XHRcdDAsIHMsIGMsIDAsXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQgYywgMCwgcywgMCxcblx0XHRcdFx0IDAsIDEsIDAsIDAsXG5cdFx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdFx0IDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHRjLCAtIHMsIDAsIDAsXG5cdFx0XHRcdHMsIGMsIDAsIDAsXG5cdFx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdFx0dmFyIHQgPSAxIC0gYztcblx0XHRcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuXHRcdFx0dmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcblx0XHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0XHR0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdFx0IHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHR4LCAwLCAwLCAwLFxuXHRcdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0XHQwLCAwLCB6LCAwLFxuXHRcdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG1ha2VTaGVhcjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0XHR0aGlzLnNldChcblxuXHRcdFx0XHQxLCB5LCB6LCAwLFxuXHRcdFx0XHR4LCAxLCB6LCAwLFxuXHRcdFx0XHR4LCB5LCAxLCAwLFxuXHRcdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvbXBvc2U6IGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0XHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cdFx0XHR0aGlzLnNjYWxlKCBzY2FsZSApO1xuXHRcdFx0dGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBkZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHRcdHZhciBzeCA9IHZlY3Rvci5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcblx0XHRcdFx0dmFyIHN5ID0gdmVjdG9yLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xuXHRcdFx0XHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0XHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cdFx0XHRcdHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cdFx0XHRcdGlmICggZGV0IDwgMCApIHN4ID0gLSBzeDtcblxuXHRcdFx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0XHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcblx0XHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG5cdFx0XHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0XHRcdG1hdHJpeC5jb3B5KCB0aGlzICk7XG5cblx0XHRcdFx0dmFyIGludlNYID0gMSAvIHN4O1xuXHRcdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XG5cdFx0XHRcdHZhciBpbnZTWiA9IDEgLyBzejtcblxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cblx0XHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRcdHNjYWxlLnggPSBzeDtcblx0XHRcdFx0c2NhbGUueSA9IHN5O1xuXHRcdFx0XHRzY2FsZS56ID0gc3o7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRcdGlmICggZmFyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm1ha2VQZXJzcGVjdGl2ZSgpIGhhcyBiZWVuIHJlZGVmaW5lZCBhbmQgaGFzIGEgbmV3IHNpZ25hdHVyZS4gUGxlYXNlIGNoZWNrIHRoZSBkb2NzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0XHR2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0XHR2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xuXG5cdFx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XG5cdFx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XG5cdFx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjO1x0dGVbIDE0IF0gPSBkO1xuXHRcdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dmFyIHcgPSAxLjAgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdFx0dmFyIGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xuXHRcdFx0dmFyIHAgPSAxLjAgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdFx0dmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApICogdztcblx0XHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAqIGg7XG5cdFx0XHR2YXIgeiA9ICggZmFyICsgbmVhciApICogcDtcblxuXHRcdFx0dGVbIDAgXSA9IDIgKiB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xuXHRcdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAqIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xuXHRcdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xuXHRcdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDkgXSA9IHRlWyA5IF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEyIF0gPSB0ZVsgMTIgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDE1IF0gPSB0ZVsgMTUgXTtcblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICovXG5cblx0ZnVuY3Rpb24gUXVhdGVybmlvbiggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4IHx8IDA7XG5cdFx0dGhpcy5feSA9IHkgfHwgMDtcblx0XHR0aGlzLl96ID0geiB8fCAwO1xuXHRcdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFF1YXRlcm5pb24sIHtcblxuXHRcdHNsZXJwOiBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XG5cblx0XHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdFx0fSxcblxuXHRcdHNsZXJwRmxhdDogZnVuY3Rpb24gKCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcblxuXHRcdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG5cdFx0XHR2YXIgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxuXHRcdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXG5cdFx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcblx0XHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdLFxuXG5cdFx0XHRcdHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcblx0XHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuXHRcdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXG5cdFx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cblx0XHRcdFx0dmFyIHMgPSAxIC0gdCxcblxuXHRcdFx0XHRcdGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG5cblx0XHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuXHRcdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XG5cblx0XHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcblx0XHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdHZhciBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxuXHRcdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcblxuXHRcdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuXHRcdFx0XHRcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XG5cdFx0XHRcdHkwID0geTAgKiBzICsgeTEgKiB0RGlyO1xuXHRcdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XG5cblx0XHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxuXHRcdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdFx0dmFyIGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XG5cblx0XHRcdFx0XHR4MCAqPSBmO1xuXHRcdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdFx0ejAgKj0gZjtcblx0XHRcdFx0XHR3MCAqPSBmO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRkc3RbIGRzdE9mZnNldCBdID0geDA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xuXG5cdFx0eDoge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR5OiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl95O1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHo6IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dzoge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcblxuXHRcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cdFx0XHR0aGlzLl93ID0gdztcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcblx0XHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG5cdFx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciwgdXBkYXRlICkge1xuXG5cdFx0XHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLm9yZGVyO1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxuXG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3M7XG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW47XG5cblx0XHRcdHZhciBjMSA9IGNvcyggeCAvIDIgKTtcblx0XHRcdHZhciBjMiA9IGNvcyggeSAvIDIgKTtcblx0XHRcdHZhciBjMyA9IGNvcyggeiAvIDIgKTtcblxuXHRcdFx0dmFyIHMxID0gc2luKCB4IC8gMiApO1xuXHRcdFx0dmFyIHMyID0gc2luKCB5IC8gMiApO1xuXHRcdFx0dmFyIHMzID0gc2luKCB6IC8gMiApO1xuXG5cdFx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuXHRcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuXHRcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdFx0dmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XG5cdFx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxuXG5cdFx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuXHRcdFx0XHRzO1xuXG5cdFx0XHRpZiAoIHRyYWNlID4gMCApIHtcblxuXHRcdFx0XHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xuXHRcdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcblxuXHRcdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcblx0XHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcblxuXHRcdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cdFx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgcjtcblxuXHRcdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xuXG5cdFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRcdFx0aWYgKCByIDwgRVBTICkge1xuXG5cdFx0XHRcdFx0ciA9IDA7XG5cblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdFx0XHR2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX3ggPSB2MS54O1xuXHRcdFx0XHR0aGlzLl95ID0gdjEueTtcblx0XHRcdFx0dGhpcy5feiA9IHYxLno7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBxdWF0ZXJuaW9uIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcblxuXHRcdH0sXG5cblx0XHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5feCAqPSAtIDE7XG5cdFx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuXHRcdH0sXG5cblx0XHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cblx0XHR9LFxuXG5cdFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0XHR9LFxuXG5cdFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdFx0aWYgKCBsID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGwgPSAxIC8gbDtcblxuXHRcdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuXHRcdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XG5cblx0XHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcblxuXHRcdH0sXG5cblx0XHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblxuXHRcdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG5cdFx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcblx0XHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xuXG5cdFx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcblx0XHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHRcdHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuXHRcdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcblxuXHRcdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xuXHRcdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcblx0XHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xuXG5cdFx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuY29weSggcWIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdFx0dGhpcy5fdyA9IHc7XG5cdFx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdFx0dGhpcy5feiA9IHo7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHNpbkhhbGZUaGV0YSApIDwgMC4wMDEgKSB7XG5cblx0XHRcdFx0dGhpcy5fdyA9IDAuNSAqICggdyArIHRoaXMuX3cgKTtcblx0XHRcdFx0dGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcblx0XHRcdFx0dGhpcy5feSA9IDAuNSAqICggeSArIHRoaXMuX3kgKTtcblx0XHRcdFx0dGhpcy5feiA9IDAuNSAqICggeiArIHRoaXMuX3ogKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcblx0XHRcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG5cdFx0XHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cblx0XHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdFx0dGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcblx0XHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcblxuXHRcdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xuXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuXHQgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICovXG5cblx0ZnVuY3Rpb24gVmVjdG9yMyggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMueCA9IHggfHwgMDtcblx0XHR0aGlzLnkgPSB5IHx8IDA7XG5cdFx0dGhpcy56ID0geiB8fCAwO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBWZWN0b3IzLnByb3RvdHlwZSwge1xuXG5cdFx0aXNWZWN0b3IzOiB0cnVlLFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cblx0XHRcdHRoaXMueCA9IHg7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXHRcdFx0dGhpcy56ID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy56ID0gc2NhbGFyO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRcdHRoaXMueCA9IHg7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdFx0dGhpcy55ID0geTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG5cdFx0XHR0aGlzLnogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuXHRcdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54ID0gdi54O1xuXHRcdFx0dGhpcy55ID0gdi55O1xuXHRcdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCArPSB2Lng7XG5cdFx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdFx0dGhpcy56ICs9IHYuejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRcdHRoaXMueCArPSBzO1xuXHRcdFx0dGhpcy55ICs9IHM7XG5cdFx0XHR0aGlzLnogKz0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xuXG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy54IC09IHYueDtcblx0XHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdFx0dGhpcy54IC09IHM7XG5cdFx0XHR0aGlzLnkgLT0gcztcblx0XHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdFx0dGhpcy56ICo9IHYuejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0XHR0aGlzLnogPSBhLnogKiBiLno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XG5cblx0XHRcdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG5cdFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG5cdFx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdFx0dmFyIHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xuXG5cdFx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XG5cdFx0XHR0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKSAqIHc7XG5cdFx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0XHR2YXIgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cblx0XHRcdHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcblx0XHRcdHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHRcdHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcblx0XHRcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cblx0XHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cdFx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcblx0XHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcblx0XHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHR0aGlzLnggLz0gdi54O1xuXHRcdFx0dGhpcy55IC89IHYueTtcblx0XHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0XHR9LFxuXG5cdFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1pbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgbWF4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG5cdFx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XG5cblx0XHR9LFxuXG5cdFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjZWlsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXHRcdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdFx0fSxcblxuXHRcdC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD9cblxuXHRcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cblx0XHR9LFxuXG5cdFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG5cdFx0fSxcblxuXHRcdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xuXG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xuXG5cdFx0fSxcblxuXHRcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcblxuXHRcdH0sXG5cblx0XHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHRcdH0sXG5cblx0XHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB0aGlzLCB2ICk7XG5cblx0XHR9LFxuXG5cdFx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXHRcdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHRcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuXHRcdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0dmFyIHNjYWxhciA9IHZlY3Rvci5kb3QoIHRoaXMgKSAvIHZlY3Rvci5sZW5ndGhTcSgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ZWN0b3IgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XG5cblx0XHR9LFxuXG5cdFx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdFx0XHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiByZWZsZWN0KCBub3JtYWwgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICkgKTtcblxuXHRcdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdFx0cmV0dXJuIE1hdGguYWNvcyggX01hdGguY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0XHR9LFxuXG5cdFx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueSwgZHogPSB0aGlzLnogLSB2Lno7XG5cblx0XHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cblx0XHR9LFxuXG5cdFx0bWFuaGF0dGFuRGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21TcGhlcmljYWw6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdFx0dmFyIHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBzLnBoaSApICogcy5yYWRpdXM7XG5cblx0XHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCBzLnRoZXRhICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcy5waGkgKSAqIHMucmFkaXVzO1xuXHRcdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3MoIHMudGhldGEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbUN5bGluZHJpY2FsOiBmdW5jdGlvbiAoIGMgKSB7XG5cblx0XHRcdHRoaXMueCA9IGMucmFkaXVzICogTWF0aC5zaW4oIGMudGhldGEgKTtcblx0XHRcdHRoaXMueSA9IGMueTtcblx0XHRcdHRoaXMueiA9IGMucmFkaXVzICogTWF0aC5jb3MoIGMudGhldGEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuXHRcdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHRcdHRoaXMueSA9IGVbIDEzIF07XG5cdFx0XHR0aGlzLnogPSBlWyAxNCBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0dmFyIHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRcdHZhciBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0XHR0aGlzLnggPSBzeDtcblx0XHRcdHRoaXMueSA9IHN5O1xuXHRcdFx0dGhpcy56ID0gc3o7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggbSwgaW5kZXggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBNYXRyaXgzKCkge1xuXG5cdFx0dGhpcy5lbGVtZW50cyA9IFtcblxuXHRcdFx0MSwgMCwgMCxcblx0XHRcdDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHRdO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBNYXRyaXgzLnByb3RvdHlwZSwge1xuXG5cdFx0aXNNYXRyaXgzOiB0cnVlLFxuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHRlWyAwIF0gPSBuMTE7IHRlWyAxIF0gPSBuMjE7IHRlWyAyIF0gPSBuMzE7XG5cdFx0XHR0ZVsgMyBdID0gbjEyOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNSBdID0gbjMyO1xuXHRcdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgMCxcblx0XHRcdFx0MCwgMSwgMCxcblx0XHRcdFx0MCwgMCwgMVxuXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdFx0dGVbIDMgXSA9IG1lWyAzIF07IHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTtcblx0XHRcdHRlWyA2IF0gPSBtZVsgNiBdOyB0ZVsgNyBdID0gbWVbIDcgXTsgdGVbIDggXSA9IG1lWyA4IF07XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21NYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdG1lWyAwIF0sIG1lWyA0IF0sIG1lWyA4IF0sXG5cdFx0XHRcdG1lWyAxIF0sIG1lWyA1IF0sIG1lWyA5IF0sXG5cdFx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHRcdFx0djEueSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XG5cdFx0XHRcdFx0djEueiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XG5cblx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuXHRcdH0sXG5cblx0XHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdFx0dmFyIGJlID0gYi5lbGVtZW50cztcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHZhciBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgMyBdLCBhMTMgPSBhZVsgNiBdO1xuXHRcdFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA0IF0sIGEyMyA9IGFlWyA3IF07XG5cdFx0XHR2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDUgXSwgYTMzID0gYWVbIDggXTtcblxuXHRcdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyAzIF0sIGIxMyA9IGJlWyA2IF07XG5cdFx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDQgXSwgYjIzID0gYmVbIDcgXTtcblx0XHRcdHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNSBdLCBiMzMgPSBiZVsgOCBdO1xuXG5cdFx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxO1xuXHRcdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHRcdHRlWyA2IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzM7XG5cblx0XHRcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzE7XG5cdFx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdFx0dGVbIDcgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMztcblxuXHRcdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMTtcblx0XHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0XHR0ZVsgOCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xuXHRcdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuXHRcdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxuXHRcdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG5cdFx0fSxcblxuXHRcdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcblxuXHRcdFx0aWYgKCBtYXRyaXggJiYgbWF0cml4LmlzTWF0cml4NCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk1hdHJpeDM6IC5nZXRJbnZlcnNlKCkgbm8gbG9uZ2VyIHRha2VzIGEgTWF0cml4NCBhcmd1bWVudC5cIiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cyxcblx0XHRcdFx0dGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXG5cdFx0XHRcdG4xMiA9IG1lWyAzIF0sIG4yMiA9IG1lWyA0IF0sIG4zMiA9IG1lWyA1IF0sXG5cdFx0XHRcdG4xMyA9IG1lWyA2IF0sIG4yMyA9IG1lWyA3IF0sIG4zMyA9IG1lWyA4IF0sXG5cblx0XHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuXHRcdFx0XHR0MTIgPSBuMzIgKiBuMTMgLSBuMzMgKiBuMTIsXG5cdFx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblxuXHRcdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cblx0XHRcdGlmICggZGV0ID09PSAwICkge1xuXG5cdFx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDM6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG5cdFx0XHRcdGlmICggdGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBkZXRJbnYgPSAxIC8gZGV0O1xuXG5cdFx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XG5cdFx0XHR0ZVsgMiBdID0gKCBuMzIgKiBuMjEgLSBuMzEgKiBuMjIgKSAqIGRldEludjtcblxuXHRcdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcblx0XHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xuXHRcdFx0dGVbIDUgXSA9ICggbjMxICogbjEyIC0gbjMyICogbjExICkgKiBkZXRJbnY7XG5cblx0XHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcblx0XHRcdHRlWyA4IF0gPSAoIG4yMiAqIG4xMSAtIG4yMSAqIG4xMiApICogZGV0SW52O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0XHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xuXHRcdFx0dG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeDQgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKCByICkge1xuXG5cdFx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHJbIDAgXSA9IG1bIDAgXTtcblx0XHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRcdHJbIDMgXSA9IG1bIDEgXTtcblx0XHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRcdHJbIDYgXSA9IG1bIDIgXTtcblx0XHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0VXZUcmFuc2Zvcm06IGZ1bmN0aW9uICggdHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kgKSB7XG5cblx0XHRcdHZhciBjID0gTWF0aC5jb3MoIHJvdGF0aW9uICk7XG5cdFx0XHR2YXIgcyA9IE1hdGguc2luKCByb3RhdGlvbiApO1xuXG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcblx0XHRcdFx0LSBzeSAqIHMsIHN5ICogYywgLSBzeSAqICggLSBzICogY3ggKyBjICogY3kgKSArIGN5ICsgdHksXG5cdFx0XHRcdDAsIDAsIDFcblx0XHRcdCk7XG5cblx0XHR9LFxuXG5cdFx0c2NhbGU6IGZ1bmN0aW9uICggc3gsIHN5ICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR0ZVsgMCBdICo9IHN4OyB0ZVsgMyBdICo9IHN4OyB0ZVsgNiBdICo9IHN4O1xuXHRcdFx0dGVbIDEgXSAqPSBzeTsgdGVbIDQgXSAqPSBzeTsgdGVbIDcgXSAqPSBzeTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cm90YXRlOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdFx0dmFyIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0dmFyIGExMSA9IHRlWyAwIF0sIGExMiA9IHRlWyAzIF0sIGExMyA9IHRlWyA2IF07XG5cdFx0XHR2YXIgYTIxID0gdGVbIDEgXSwgYTIyID0gdGVbIDQgXSwgYTIzID0gdGVbIDcgXTtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBhMTEgKyBzICogYTIxO1xuXHRcdFx0dGVbIDMgXSA9IGMgKiBhMTIgKyBzICogYTIyO1xuXHRcdFx0dGVbIDYgXSA9IGMgKiBhMTMgKyBzICogYTIzO1xuXG5cdFx0XHR0ZVsgMSBdID0gLSBzICogYTExICsgYyAqIGEyMTtcblx0XHRcdHRlWyA0IF0gPSAtIHMgKiBhMTIgKyBjICogYTIyO1xuXHRcdFx0dGVbIDcgXSA9IC0gcyAqIGExMyArIGMgKiBhMjM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCB0eCwgdHkgKSB7XG5cblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRcdHRlWyAwIF0gKz0gdHggKiB0ZVsgMiBdOyB0ZVsgMyBdICs9IHR4ICogdGVbIDUgXTsgdGVbIDYgXSArPSB0eCAqIHRlWyA4IF07XG5cdFx0XHR0ZVsgMSBdICs9IHR5ICogdGVbIDIgXTsgdGVbIDQgXSArPSB0eSAqIHRlWyA1IF07IHRlWyA3IF0gKz0gdHkgKiB0ZVsgOCBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG5cdCAqL1xuXG5cdHZhciB0ZXh0dXJlSWQgPSAwO1xuXG5cdGZ1bmN0aW9uIFRleHR1cmUoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiB0ZXh0dXJlSWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdHRoaXMuaW1hZ2UgPSBpbWFnZSAhPT0gdW5kZWZpbmVkID8gaW1hZ2UgOiBUZXh0dXJlLkRFRkFVTFRfSU1BR0U7XG5cdFx0dGhpcy5taXBtYXBzID0gW107XG5cblx0XHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XG5cblx0XHR0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHR0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuXHRcdHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IGFuaXNvdHJvcHkgOiAxO1xuXG5cdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFJHQkFGb3JtYXQ7XG5cdFx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFVuc2lnbmVkQnl0ZVR5cGU7XG5cblx0XHR0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XG5cdFx0dGhpcy5yZXBlYXQgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXHRcdHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuXHRcdHRoaXMuZmxpcFkgPSB0cnVlO1xuXHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDtcdC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG5cdFx0Ly8gVmFsdWVzIG9mIGVuY29kaW5nICE9PSBUSFJFRS5MaW5lYXJFbmNvZGluZyBvbmx5IHN1cHBvcnRlZCBvbiBtYXAsIGVudk1hcCBhbmQgZW1pc3NpdmVNYXAuXG5cdFx0Ly9cblx0XHQvLyBBbHNvIGNoYW5naW5nIHRoZSBlbmNvZGluZyBhZnRlciBhbHJlYWR5IHVzZWQgYnkgYSBNYXRlcmlhbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IG1ha2UgdGhlIE1hdGVyaWFsXG5cdFx0Ly8gdXBkYXRlLiAgWW91IG5lZWQgdG8gZXhwbGljaXRseSBjYWxsIE1hdGVyaWFsLm5lZWRzVXBkYXRlIHRvIHRyaWdnZXIgaXQgdG8gcmVjb21waWxlLlxuXHRcdHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gZW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cdFx0dGhpcy5vblVwZGF0ZSA9IG51bGw7XG5cblx0fVxuXG5cdFRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcblx0VGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBVVk1hcHBpbmc7XG5cblx0VGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUZXh0dXJlLFxuXG5cdFx0aXNUZXh0dXJlOiB0cnVlLFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdFx0dGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcblx0XHRcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XG5cblx0XHRcdHRoaXMubWFwcGluZyA9IHNvdXJjZS5tYXBwaW5nO1xuXG5cdFx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xuXHRcdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblxuXHRcdFx0dGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xuXHRcdFx0dGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xuXG5cdFx0XHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblxuXHRcdFx0dGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xuXHRcdFx0dGhpcy50eXBlID0gc291cmNlLnR5cGU7XG5cblx0XHRcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcblx0XHRcdHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIHNvdXJjZS5jZW50ZXIgKTtcblx0XHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG5cblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xuXG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0XHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcblx0XHRcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG5cdFx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG5cdFx0XHR0aGlzLmVuY29kaW5nID0gc291cmNlLmVuY29kaW5nO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdFx0dmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xuXG5cdFx0XHRpZiAoICEgaXNSb290T2JqZWN0ICYmIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldERhdGFVUkwoIGltYWdlICkge1xuXG5cdFx0XHRcdHZhciBjYW52YXM7XG5cblx0XHRcdFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0Y2FudmFzID0gaW1hZ2U7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuXHRcdFx0XHRcdGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuXHRcdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cblx0XHRcdFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cblx0XHRcdFx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhICkge1xuXG5cdFx0XHRcdFx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2UsIDAsIDAgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC41LFxuXHRcdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblxuXHRcdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXG5cblx0XHRcdFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcblx0XHRcdFx0b2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcblx0XHRcdFx0Y2VudGVyOiBbIHRoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnkgXSxcblx0XHRcdFx0cm90YXRpb246IHRoaXMucm90YXRpb24sXG5cblx0XHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXG5cblx0XHRcdFx0bWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcblx0XHRcdFx0bWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcblx0XHRcdFx0YW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5LFxuXG5cdFx0XHRcdGZsaXBZOiB0aGlzLmZsaXBZXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXG5cblx0XHRcdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuXHRcdFx0XHRpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGltYWdlLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTsgLy8gVUdIXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9IHtcblx0XHRcdFx0XHRcdHV1aWQ6IGltYWdlLnV1aWQsXG5cdFx0XHRcdFx0XHR1cmw6IGdldERhdGFVUkwoIGltYWdlIClcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdH0sXG5cblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zZm9ybVV2OiBmdW5jdGlvbiAoIHV2ICkge1xuXG5cdFx0XHRpZiAoIHRoaXMubWFwcGluZyAhPT0gVVZNYXBwaW5nICkgcmV0dXJuO1xuXG5cdFx0XHR1di5hcHBseU1hdHJpeDMoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcblxuXHRcdFx0XHRcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XG5cblx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XG5cblx0XHRcdFx0XHRcdHV2LnggPSB1di54IDwgMCA/IDAgOiAxO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XG5cblx0XHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHR1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBUICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdHV2LnkgPSBNYXRoLmNlaWwoIHV2LnkgKSAtIHV2Lnk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuZmxpcFkgKSB7XG5cblx0XHRcdFx0dXYueSA9IDEgLSB1di55O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggVGV4dHVyZS5wcm90b3R5cGUsIFwibmVlZHNVcGRhdGVcIiwge1xuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cblx0ICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFZlY3RvcjQoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLnggPSB4IHx8IDA7XG5cdFx0dGhpcy55ID0geSB8fCAwO1xuXHRcdHRoaXMueiA9IHogfHwgMDtcblx0XHR0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFZlY3RvcjQucHJvdG90eXBlLCB7XG5cblx0XHRpc1ZlY3RvcjQ6IHRydWUsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdFx0dGhpcy54ID0geDtcblx0XHRcdHRoaXMueSA9IHk7XG5cdFx0XHR0aGlzLnogPSB6O1xuXHRcdFx0dGhpcy53ID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy56ID0gc2NhbGFyO1xuXHRcdFx0dGhpcy53ID0gc2NhbGFyO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRcdHRoaXMueCA9IHg7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuXHRcdFx0dGhpcy55ID0geTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG5cdFx0XHR0aGlzLnogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XG5cblx0XHRcdHRoaXMudyA9IHc7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuXHRcdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IHYueDtcblx0XHRcdHRoaXMueSA9IHYueTtcblx0XHRcdHRoaXMueiA9IHYuejtcblx0XHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy54ICs9IHYueDtcblx0XHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0XHR0aGlzLnogKz0gdi56O1xuXHRcdFx0dGhpcy53ICs9IHYudztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHRcdHRoaXMueCArPSBzO1xuXHRcdFx0dGhpcy55ICs9IHM7XG5cdFx0XHR0aGlzLnogKz0gcztcblx0XHRcdHRoaXMudyArPSBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHRcdHRoaXMueiA9IGEueiArIGIuejtcblx0XHRcdHRoaXMudyA9IGEudyArIGIudztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cblx0XHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0XHR0aGlzLnogKz0gdi56ICogcztcblx0XHRcdHRoaXMudyArPSB2LncgKiBzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdFx0dGhpcy56IC09IHYuejtcblx0XHRcdHRoaXMudyAtPSB2Lnc7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR0aGlzLnggLT0gcztcblx0XHRcdHRoaXMueSAtPSBzO1xuXHRcdFx0dGhpcy56IC09IHM7XG5cdFx0XHR0aGlzLncgLT0gcztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0XHR0aGlzLncgPSBhLncgLSBiLnc7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy53ICo9IHNjYWxhcjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56LCB3ID0gdGhpcy53O1xuXHRcdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcblx0XHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xuXHRcdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xuXHRcdFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdFx0fSxcblxuXHRcdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cblxuXHRcdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XG5cblx0XHRcdHZhciBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XG5cblx0XHRcdGlmICggcyA8IDAuMDAwMSApIHtcblxuXHRcdFx0XHR0aGlzLnggPSAxO1xuXHRcdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0XHR0aGlzLnogPSAwO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMueCA9IHEueCAvIHM7XG5cdFx0XHRcdHRoaXMueSA9IHEueSAvIHM7XG5cdFx0XHRcdHRoaXMueiA9IHEueiAvIHM7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxuXG5cdFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0XHR2YXIgYW5nbGUsIHgsIHksIHosXHRcdC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XG5cdFx0XHRcdGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xuXHRcdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblxuXHRcdFx0XHR0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uICkgJiZcblx0XHRcdCAgICAgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XG5cblx0XHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcblx0XHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuXHRcdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cblx0XHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yICkgJiZcblx0XHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yICkgJiZcblx0XHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yICkgJiZcblx0XHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cblx0XHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cblx0XHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xuXG5cdFx0XHRcdHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcblx0XHRcdFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xuXHRcdFx0XHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XG5cdFx0XHRcdHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xuXHRcdFx0XHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcblx0XHRcdFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XG5cblx0XHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcblxuXHRcdFx0XHRcdC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cblx0XHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KCB4eCApO1xuXHRcdFx0XHRcdFx0eSA9IHh5IC8geDtcblx0XHRcdFx0XHRcdHogPSB4eiAvIHg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHtcblxuXHRcdFx0XHRcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cblx0XHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xuXHRcdFx0XHRcdFx0eCA9IHh5IC8geTtcblx0XHRcdFx0XHRcdHogPSB5eiAvIHk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblxuXHRcdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xuXG5cdFx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0XHR6ID0gMDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XG5cdFx0XHRcdFx0XHR4ID0geHogLyB6O1xuXHRcdFx0XHRcdFx0eSA9IHl6IC8gejtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG5cdFx0XHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xuXHRcdFx0ICAgICAgICAgICAgICAgICAgICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICtcblx0XHRcdCAgICAgICAgICAgICAgICAgICAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xuXG5cdFx0XHQvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG5cdFx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcblx0XHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblx0XHRcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5tYXgoIHRoaXMudywgdi53ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cdFx0XHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtaW4gPSBuZXcgVmVjdG9yNCgpO1xuXHRcdFx0XHRcdG1heCA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XG5cblx0XHR9LFxuXG5cdFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5jZWlsKCB0aGlzLncgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXHRcdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblx0XHRcdHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHRcdHRoaXMueiA9IC0gdGhpcy56O1xuXHRcdFx0dGhpcy53ID0gLSB0aGlzLnc7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXG5cdFx0fSxcblxuXHRcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG5cblx0XHR9LFxuXG5cdFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG5cdFx0fSxcblxuXHRcdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xuXG5cdFx0fSxcblxuXHRcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcblxuXHRcdH0sXG5cblx0XHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cdFx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy53O1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cdFx0XHR0aGlzLncgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgTWFyaXVzIEtpbnRlbCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9raW50ZWxcblx0ICovXG5cblx0Lypcblx0IEluIG9wdGlvbnMsIHdlIGNhbiBzcGVjaWZ5OlxuXHQgKiBUZXh0dXJlIHBhcmFtZXRlcnMgZm9yIGFuIGF1dG8tZ2VuZXJhdGVkIHRhcmdldCB0ZXh0dXJlXG5cdCAqIGRlcHRoQnVmZmVyL3N0ZW5jaWxCdWZmZXI6IEJvb2xlYW5zIHRvIGluZGljYXRlIGlmIHdlIHNob3VsZCBnZW5lcmF0ZSB0aGVzZSBidWZmZXJzXG5cdCovXG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG5cdFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHR0aGlzLnNjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXHRcdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcblxuXHRcdHRoaXMudmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuZW5jb2RpbmcgKTtcblxuXHRcdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XG5cdFx0dGhpcy5kZXB0aFRleHR1cmUgPSBvcHRpb25zLmRlcHRoVGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aFRleHR1cmUgOiBudWxsO1xuXG5cdH1cblxuXHRXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBXZWJHTFJlbmRlclRhcmdldCxcblxuXHRcdGlzV2ViR0xSZW5kZXJUYXJnZXQ6IHRydWUsXG5cblx0XHRzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRcdGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCApIHtcblxuXHRcdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudmlld3BvcnQuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cdFx0XHR0aGlzLnNjaXNzb3Iuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXG5cdFx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoIHNvdXJjZS52aWV3cG9ydCApO1xuXG5cdFx0XHR0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xuXG5cdFx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuXHRcdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XG5cdFx0XHR0aGlzLmRlcHRoVGV4dHVyZSA9IHNvdXJjZS5kZXB0aFRleHR1cmU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuXHRcdFdlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XG5cdFx0dGhpcy5hY3RpdmVNaXBNYXBMZXZlbCA9IDA7XG5cblx0fVxuXG5cdFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblx0V2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcblxuXHRXZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XG5cblx0XHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcblxuXHRcdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xuXHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xuXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xuXG5cdH1cblxuXHREYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuXHREYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhVGV4dHVyZTtcblxuXHREYXRhVGV4dHVyZS5wcm90b3R5cGUuaXNEYXRhVGV4dHVyZSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEN1YmVUZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XG5cblx0XHRpbWFnZXMgPSBpbWFnZXMgIT09IHVuZGVmaW5lZCA/IGltYWdlcyA6IFtdO1xuXHRcdG1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXG5cdFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcblxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHR9XG5cblx0Q3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcblx0Q3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZVRleHR1cmU7XG5cblx0Q3ViZVRleHR1cmUucHJvdG90eXBlLmlzQ3ViZVRleHR1cmUgPSB0cnVlO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQ3ViZVRleHR1cmUucHJvdG90eXBlLCAnaW1hZ2VzJywge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmltYWdlO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5pbWFnZSA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKlxuXHQgKiBVbmlmb3JtcyBvZiBhIHByb2dyYW0uXG5cdCAqIFRob3NlIGZvcm0gYSB0cmVlIHN0cnVjdHVyZSB3aXRoIGEgc3BlY2lhbCB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciB0aGUgcm9vdCxcblx0ICogd2hpY2ggeW91IGdldCBieSBjYWxsaW5nICduZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICknLlxuXHQgKlxuXHQgKlxuXHQgKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcblx0ICpcblx0ICogLnNlcSAtIGFycmF5IG9mIG5lc3RlZCB1bmlmb3Jtc1xuXHQgKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcblx0ICpcblx0ICpcblx0ICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxuXHQgKlxuXHQgKiAuc2V0VmFsdWUoIGdsLCB2YWx1ZSwgW3JlbmRlcmVyXSApXG5cdCAqXG5cdCAqIFx0XHR1cGxvYWRzIGEgdW5pZm9ybSB2YWx1ZShzKVxuXHQgKiAgXHR0aGUgJ3JlbmRlcmVyJyBwYXJhbWV0ZXIgaXMgbmVlZGVkIGZvciBzYW1wbGVyIHVuaWZvcm1zXG5cdCAqXG5cdCAqXG5cdCAqIFN0YXRpYyBtZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIChyZW5kZXJlciBmYWN0b3JpemF0aW9ucyk6XG5cdCAqXG5cdCAqIC51cGxvYWQoIGdsLCBzZXEsIHZhbHVlcywgcmVuZGVyZXIgKVxuXHQgKlxuXHQgKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcblx0ICpcblx0ICogLnNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSA6IGZpbHRlcmVkU2VxXG5cdCAqXG5cdCAqIFx0XHRmaWx0ZXJzICdzZXEnIGVudHJpZXMgd2l0aCBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHZhbHVlc1xuXHQgKlxuXHQgKlxuXHQgKiBNZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIChyZW5kZXJlciBmYWN0b3JpemF0aW9ucyk6XG5cdCAqXG5cdCAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlIClcblx0ICpcblx0ICogXHRcdHNldHMgdW5pZm9ybSB3aXRoICBuYW1lICduYW1lJyB0byAndmFsdWUnXG5cdCAqXG5cdCAqIC5zZXQoIGdsLCBvYmosIHByb3AgKVxuXHQgKlxuXHQgKiBcdFx0c2V0cyB1bmlmb3JtIGZyb20gb2JqZWN0IGFuZCBwcm9wZXJ0eSB3aXRoIHNhbWUgbmFtZSB0aGFuIHVuaWZvcm1cblx0ICpcblx0ICogLnNldE9wdGlvbmFsKCBnbCwgb2JqLCBwcm9wIClcblx0ICpcblx0ICogXHRcdGxpa2UgLnNldCBmb3IgYW4gb3B0aW9uYWwgcHJvcGVydHkgb2YgdGhlIG9iamVjdFxuXHQgKlxuXHQgKi9cblxuXHR2YXIgZW1wdHlUZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcblx0dmFyIGVtcHR5Q3ViZVRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcblxuXHQvLyAtLS0gQmFzZSBmb3IgaW5uZXIgbm9kZXMgKGluY2x1ZGluZyB0aGUgcm9vdCkgLS0tXG5cblx0ZnVuY3Rpb24gVW5pZm9ybUNvbnRhaW5lcigpIHtcblxuXHRcdHRoaXMuc2VxID0gW107XG5cdFx0dGhpcy5tYXAgPSB7fTtcblxuXHR9XG5cblx0Ly8gLS0tIFV0aWxpdGllcyAtLS1cblxuXHQvLyBBcnJheSBDYWNoZXMgKHByb3ZpZGUgdHlwZWQgYXJyYXlzIGZvciB0ZW1wb3JhcnkgYnkgc2l6ZSlcblxuXHR2YXIgYXJyYXlDYWNoZUYzMiA9IFtdO1xuXHR2YXIgYXJyYXlDYWNoZUkzMiA9IFtdO1xuXG5cdC8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xuXG5cdHZhciBtYXQ0YXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiApO1xuXHR2YXIgbWF0M2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSApO1xuXG5cdC8vIEZsYXR0ZW5pbmcgZm9yIGFycmF5cyBvZiB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuXG5cdGZ1bmN0aW9uIGZsYXR0ZW4oIGFycmF5LCBuQmxvY2tzLCBibG9ja1NpemUgKSB7XG5cblx0XHR2YXIgZmlyc3RFbGVtID0gYXJyYXlbIDAgXTtcblxuXHRcdGlmICggZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCApIHJldHVybiBhcnJheTtcblx0XHQvLyB1bm9wdGltaXplZDogISBpc05hTiggZmlyc3RFbGVtIClcblx0XHQvLyBzZWUgaHR0cDovL2phY2tzb25kdW5zdGFuLmNvbS9hcnRpY2xlcy85ODNcblxuXHRcdHZhciBuID0gbkJsb2NrcyAqIGJsb2NrU2l6ZSxcblx0XHRcdHIgPSBhcnJheUNhY2hlRjMyWyBuIF07XG5cblx0XHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ciA9IG5ldyBGbG9hdDMyQXJyYXkoIG4gKTtcblx0XHRcdGFycmF5Q2FjaGVGMzJbIG4gXSA9IHI7XG5cblx0XHR9XG5cblx0XHRpZiAoIG5CbG9ja3MgIT09IDAgKSB7XG5cblx0XHRcdGZpcnN0RWxlbS50b0FycmF5KCByLCAwICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMSwgb2Zmc2V0ID0gMDsgaSAhPT0gbkJsb2NrczsgKysgaSApIHtcblxuXHRcdFx0XHRvZmZzZXQgKz0gYmxvY2tTaXplO1xuXHRcdFx0XHRhcnJheVsgaSBdLnRvQXJyYXkoIHIsIG9mZnNldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcjtcblxuXHR9XG5cblx0Ly8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cblxuXHRmdW5jdGlvbiBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApIHtcblxuXHRcdHZhciByID0gYXJyYXlDYWNoZUkzMlsgbiBdO1xuXG5cdFx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHIgPSBuZXcgSW50MzJBcnJheSggbiApO1xuXHRcdFx0YXJyYXlDYWNoZUkzMlsgbiBdID0gcjtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApXG5cdFx0XHRyWyBpIF0gPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XG5cblx0XHRyZXR1cm4gcjtcblxuXHR9XG5cblx0Ly8gLS0tIFNldHRlcnMgLS0tXG5cblx0Ly8gTm90ZTogRGVmaW5pbmcgdGhlc2UgbWV0aG9kcyBleHRlcm5hbGx5LCBiZWNhdXNlIHRoZXkgY29tZSBpbiBhIGJ1bmNoXG5cdC8vIGFuZCB0aGlzIHdheSB0aGVpciBuYW1lcyBtaW5pZnkuXG5cblx0Ly8gU2luZ2xlIHNjYWxhclxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlMWYoIGdsLCB2ICkge1xuXG5cdFx0Z2wudW5pZm9ybTFmKCB0aGlzLmFkZHIsIHYgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWUxaSggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdiApO1xuXG5cdH1cblxuXHQvLyBTaW5nbGUgZmxvYXQgdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuVmVjdG9yTilcblxuXHRmdW5jdGlvbiBzZXRWYWx1ZTJmdiggZ2wsIHYgKSB7XG5cblx0XHRpZiAoIHYueCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdsLnVuaWZvcm0yZiggdGhpcy5hZGRyLCB2LngsIHYueSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZTNmdiggZ2wsIHYgKSB7XG5cblx0XHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiApO1xuXG5cdFx0fSBlbHNlIGlmICggdi5yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm0zZiggdGhpcy5hZGRyLCB2LnIsIHYuZywgdi5iICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnbC51bmlmb3JtM2Z2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWU0ZnYoIGdsLCB2ICkge1xuXG5cdFx0aWYgKCB2LnggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQgZ2wudW5pZm9ybTRmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBTaW5nbGUgbWF0cml4IChmcm9tIGZsYXQgYXJyYXkgb3IgTWF0cml4TilcblxuXHRmdW5jdGlvbiBzZXRWYWx1ZTJmbSggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCB2LmVsZW1lbnRzIHx8IHYgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWUzZm0oIGdsLCB2ICkge1xuXG5cdFx0aWYgKCB2LmVsZW1lbnRzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hdDNhcnJheS5zZXQoIHYuZWxlbWVudHMgKTtcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIG1hdDNhcnJheSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZTRmbSggZ2wsIHYgKSB7XG5cblx0XHRpZiAoIHYuZWxlbWVudHMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgdiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0NGFycmF5LnNldCggdi5lbGVtZW50cyApO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgbWF0NGFycmF5ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFNpbmdsZSB0ZXh0dXJlICgyRCAvIEN1YmUpXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVUMSggZ2wsIHYsIHJlbmRlcmVyICkge1xuXG5cdFx0dmFyIHVuaXQgPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XG5cdFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcblx0XHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHYgfHwgZW1wdHlUZXh0dXJlLCB1bml0ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDYoIGdsLCB2LCByZW5kZXJlciApIHtcblxuXHRcdHZhciB1bml0ID0gcmVuZGVyZXIuYWxsb2NUZXh0dXJlVW5pdCgpO1xuXHRcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XG5cdFx0cmVuZGVyZXIuc2V0VGV4dHVyZUN1YmUoIHYgfHwgZW1wdHlDdWJlVGV4dHVyZSwgdW5pdCApO1xuXG5cdH1cblxuXHQvLyBJbnRlZ2VyIC8gQm9vbGVhbiB2ZWN0b3JzIG9yIGFycmF5cyB0aGVyZW9mIChhbHdheXMgZmxhdCBhcnJheXMpXG5cblx0ZnVuY3Rpb24gc2V0VmFsdWUyaXYoIGdsLCB2ICkge1xuXG5cdFx0Z2wudW5pZm9ybTJpdiggdGhpcy5hZGRyLCB2ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlM2l2KCBnbCwgdiApIHtcblxuXHRcdGdsLnVuaWZvcm0zaXYoIHRoaXMuYWRkciwgdiApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZTRpdiggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHR9XG5cblx0Ly8gSGVscGVyIHRvIHBpY2sgdGhlIHJpZ2h0IHNldHRlciBmb3IgdGhlIHNpbmd1bGFyIGNhc2VcblxuXHRmdW5jdGlvbiBnZXRTaW5ndWxhclNldHRlciggdHlwZSApIHtcblxuXHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdGNhc2UgMHgxNDA2OiByZXR1cm4gc2V0VmFsdWUxZjsgLy8gRkxPQVRcblx0XHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWUyZnY7IC8vIF9WRUMyXG5cdFx0XHRjYXNlIDB4OGI1MTogcmV0dXJuIHNldFZhbHVlM2Z2OyAvLyBfVkVDM1xuXHRcdFx0Y2FzZSAweDhiNTI6IHJldHVybiBzZXRWYWx1ZTRmdjsgLy8gX1ZFQzRcblxuXHRcdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZTJmbTsgLy8gX01BVDJcblx0XHRcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWUzZm07IC8vIF9NQVQzXG5cdFx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlNGZtOyAvLyBfTUFUNFxuXG5cdFx0XHRjYXNlIDB4OGI1ZTogY2FzZSAweDhkNjY6IHJldHVybiBzZXRWYWx1ZVQxOyAvLyBTQU1QTEVSXzJELCBTQU1QTEVSX0VYVEVSTkFMX09FU1xuXHRcdFx0Y2FzZSAweDhiNjA6IHJldHVybiBzZXRWYWx1ZVQ2OyAvLyBTQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDE0MDQ6IGNhc2UgMHg4YjU2OiByZXR1cm4gc2V0VmFsdWUxaTsgLy8gSU5ULCBCT09MXG5cdFx0XHRjYXNlIDB4OGI1MzogY2FzZSAweDhiNTc6IHJldHVybiBzZXRWYWx1ZTJpdjsgLy8gX1ZFQzJcblx0XHRcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlM2l2OyAvLyBfVkVDM1xuXHRcdFx0Y2FzZSAweDhiNTU6IGNhc2UgMHg4YjU5OiByZXR1cm4gc2V0VmFsdWU0aXY7IC8vIF9WRUM0XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEFycmF5IG9mIHNjYWxhcnNcblxuXHRmdW5jdGlvbiBzZXRWYWx1ZTFmdiggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtMWZ2KCB0aGlzLmFkZHIsIHYgKTtcblxuXHR9XG5cdGZ1bmN0aW9uIHNldFZhbHVlMWl2KCBnbCwgdiApIHtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdiApO1xuXG5cdH1cblxuXHQvLyBBcnJheSBvZiB2ZWN0b3JzIChmbGF0IG9yIGZyb20gVEhSRUUgY2xhc3NlcylcblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVYyYSggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMiApICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjNhKCBnbCwgdiApIHtcblxuXHRcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAzICkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VmFsdWVWNGEoIGdsLCB2ICkge1xuXG5cdFx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKSApO1xuXG5cdH1cblxuXHQvLyBBcnJheSBvZiBtYXRyaWNlcyAoZmxhdCBvciBmcm9tIFRIUkVFIGNsYXNlcylcblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU0yYSggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU0zYSggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDkgKSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRWYWx1ZU00YSggZ2wsIHYgKSB7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDE2ICkgKTtcblxuXHR9XG5cblx0Ly8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gQ3ViZSlcblxuXHRmdW5jdGlvbiBzZXRWYWx1ZVQxYSggZ2wsIHYsIHJlbmRlcmVyICkge1xuXG5cdFx0dmFyIG4gPSB2Lmxlbmd0aCxcblx0XHRcdHVuaXRzID0gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKTtcblxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB2WyBpIF0gfHwgZW1wdHlUZXh0dXJlLCB1bml0c1sgaSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDZhKCBnbCwgdiwgcmVuZGVyZXIgKSB7XG5cblx0XHR2YXIgbiA9IHYubGVuZ3RoLFxuXHRcdFx0dW5pdHMgPSBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApO1xuXG5cdFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB1bml0cyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlQ3ViZSggdlsgaSBdIHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gSGVscGVyIHRvIHBpY2sgdGhlIHJpZ2h0IHNldHRlciBmb3IgYSBwdXJlIChib3R0b20tbGV2ZWwpIGFycmF5XG5cblx0ZnVuY3Rpb24gZ2V0UHVyZUFycmF5U2V0dGVyKCB0eXBlICkge1xuXG5cdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0Y2FzZSAweDE0MDY6IHJldHVybiBzZXRWYWx1ZTFmdjsgLy8gRkxPQVRcblx0XHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWVWMmE7IC8vIF9WRUMyXG5cdFx0XHRjYXNlIDB4OGI1MTogcmV0dXJuIHNldFZhbHVlVjNhOyAvLyBfVkVDM1xuXHRcdFx0Y2FzZSAweDhiNTI6IHJldHVybiBzZXRWYWx1ZVY0YTsgLy8gX1ZFQzRcblxuXHRcdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZU0yYTsgLy8gX01BVDJcblx0XHRcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWVNM2E7IC8vIF9NQVQzXG5cdFx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTRhOyAvLyBfTUFUNFxuXG5cdFx0XHRjYXNlIDB4OGI1ZTogcmV0dXJuIHNldFZhbHVlVDFhOyAvLyBTQU1QTEVSXzJEXG5cdFx0XHRjYXNlIDB4OGI2MDogcmV0dXJuIHNldFZhbHVlVDZhOyAvLyBTQU1QTEVSX0NVQkVcblxuXHRcdFx0Y2FzZSAweDE0MDQ6IGNhc2UgMHg4YjU2OiByZXR1cm4gc2V0VmFsdWUxaXY7IC8vIElOVCwgQk9PTFxuXHRcdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXG5cdFx0XHRjYXNlIDB4OGI1NDogY2FzZSAweDhiNTg6IHJldHVybiBzZXRWYWx1ZTNpdjsgLy8gX1ZFQzNcblx0XHRcdGNhc2UgMHg4YjU1OiBjYXNlIDB4OGI1OTogcmV0dXJuIHNldFZhbHVlNGl2OyAvLyBfVkVDNFxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyAtLS0gVW5pZm9ybSBDbGFzc2VzIC0tLVxuXG5cdGZ1bmN0aW9uIFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkge1xuXG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuYWRkciA9IGFkZHI7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFNpbmd1bGFyU2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcblxuXHRcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcblxuXHR9XG5cblx0ZnVuY3Rpb24gUHVyZUFycmF5VW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XG5cblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy5hZGRyID0gYWRkcjtcblx0XHR0aGlzLnNpemUgPSBhY3RpdmVJbmZvLnNpemU7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFB1cmVBcnJheVNldHRlciggYWN0aXZlSW5mby50eXBlICk7XG5cblx0XHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXG5cblx0fVxuXG5cdGZ1bmN0aW9uIFN0cnVjdHVyZWRVbmlmb3JtKCBpZCApIHtcblxuXHRcdHRoaXMuaWQgPSBpZDtcblxuXHRcdFVuaWZvcm1Db250YWluZXIuY2FsbCggdGhpcyApOyAvLyBtaXgtaW5cblxuXHR9XG5cblx0U3RydWN0dXJlZFVuaWZvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCBnbCwgdmFsdWUgKSB7XG5cblx0XHQvLyBOb3RlOiBEb24ndCBuZWVkIGFuIGV4dHJhICdyZW5kZXJlcicgcGFyYW1ldGVyLCBzaW5jZSBzYW1wbGVyc1xuXHRcdC8vIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJ1Y3R1cmVkIHVuaWZvcm1zLlxuXG5cdFx0dmFyIHNlcSA9IHRoaXMuc2VxO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0dmFyIHUgPSBzZXFbIGkgXTtcblx0XHRcdHUuc2V0VmFsdWUoIGdsLCB2YWx1ZVsgdS5pZCBdICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyAtLS0gVG9wLWxldmVsIC0tLVxuXG5cdC8vIFBhcnNlciAtIGJ1aWxkcyB1cCB0aGUgcHJvcGVydHkgdHJlZSBmcm9tIHRoZSBwYXRoIHN0cmluZ3NcblxuXHR2YXIgUmVQYXRoUGFydCA9IC8oW1xcd1xcZF9dKykoXFxdKT8oXFxbfFxcLik/L2c7XG5cblx0Ly8gZXh0cmFjdHNcblx0Ly8gXHQtIHRoZSBpZGVudGlmaWVyIChtZW1iZXIgbmFtZSBvciBhcnJheSBpbmRleClcblx0Ly8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgcmlnaHQgYnJhY2tldCAoZm91bmQgd2hlbiBhcnJheSBpbmRleClcblx0Ly8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXG5cdC8vXG5cdC8vIE5vdGU6IFRoZXNlIHBvcnRpb25zIGNhbiBiZSByZWFkIGluIGEgbm9uLW92ZXJsYXBwaW5nIGZhc2hpb24gYW5kXG5cdC8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXG5cdC8vIGluIHRoZSB1bmlmb3JtIG5hbWVzLlxuXG5cdGZ1bmN0aW9uIGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgdW5pZm9ybU9iamVjdCApIHtcblxuXHRcdGNvbnRhaW5lci5zZXEucHVzaCggdW5pZm9ybU9iamVjdCApO1xuXHRcdGNvbnRhaW5lci5tYXBbIHVuaWZvcm1PYmplY3QuaWQgXSA9IHVuaWZvcm1PYmplY3Q7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlVW5pZm9ybSggYWN0aXZlSW5mbywgYWRkciwgY29udGFpbmVyICkge1xuXG5cdFx0dmFyIHBhdGggPSBhY3RpdmVJbmZvLm5hbWUsXG5cdFx0XHRwYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cblx0XHQvLyByZXNldCBSZWdFeHAgb2JqZWN0LCBiZWNhdXNlIG9mIHRoZSBlYXJseSBleGl0IG9mIGEgcHJldmlvdXMgcnVuXG5cdFx0UmVQYXRoUGFydC5sYXN0SW5kZXggPSAwO1xuXG5cdFx0Zm9yICggOyA7ICkge1xuXG5cdFx0XHR2YXIgbWF0Y2ggPSBSZVBhdGhQYXJ0LmV4ZWMoIHBhdGggKSxcblx0XHRcdFx0bWF0Y2hFbmQgPSBSZVBhdGhQYXJ0Lmxhc3RJbmRleCxcblxuXHRcdFx0XHRpZCA9IG1hdGNoWyAxIF0sXG5cdFx0XHRcdGlkSXNJbmRleCA9IG1hdGNoWyAyIF0gPT09ICddJyxcblx0XHRcdFx0c3Vic2NyaXB0ID0gbWF0Y2hbIDMgXTtcblxuXHRcdFx0aWYgKCBpZElzSW5kZXggKSBpZCA9IGlkIHwgMDsgLy8gY29udmVydCB0byBpbnRlZ2VyXG5cblx0XHRcdGlmICggc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgfHwgc3Vic2NyaXB0ID09PSAnWycgJiYgbWF0Y2hFbmQgKyAyID09PSBwYXRoTGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIGJhcmUgbmFtZSBvciBcInB1cmVcIiBib3R0b20tbGV2ZWwgYXJyYXkgXCJbMF1cIiBzdWZmaXhcblxuXHRcdFx0XHRhZGRVbmlmb3JtKCBjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHRuZXcgU2luZ2xlVW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSA6XG5cdFx0XHRcdFx0bmV3IFB1cmVBcnJheVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgKTtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBzdGVwIGludG8gaW5uZXIgbm9kZSAvIGNyZWF0ZSBpdCBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3RcblxuXHRcdFx0XHR2YXIgbWFwID0gY29udGFpbmVyLm1hcCwgbmV4dCA9IG1hcFsgaWQgXTtcblxuXHRcdFx0XHRpZiAoIG5leHQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5leHQgPSBuZXcgU3RydWN0dXJlZFVuaWZvcm0oIGlkICk7XG5cdFx0XHRcdFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBuZXh0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRhaW5lciA9IG5leHQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gUm9vdCBDb250YWluZXJcblxuXHRmdW5jdGlvbiBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSwgcmVuZGVyZXIgKSB7XG5cblx0XHRVbmlmb3JtQ29udGFpbmVyLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcblxuXHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKSxcblx0XHRcdFx0cGF0aCA9IGluZm8ubmFtZSxcblx0XHRcdFx0YWRkciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgcGF0aCApO1xuXG5cdFx0XHRwYXJzZVVuaWZvcm0oIGluZm8sIGFkZHIsIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0V2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoIGdsLCBuYW1lLCB2YWx1ZSApIHtcblxuXHRcdHZhciB1ID0gdGhpcy5tYXBbIG5hbWUgXTtcblxuXHRcdGlmICggdSAhPT0gdW5kZWZpbmVkICkgdS5zZXRWYWx1ZSggZ2wsIHZhbHVlLCB0aGlzLnJlbmRlcmVyICk7XG5cblx0fTtcblxuXHRXZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXRPcHRpb25hbCA9IGZ1bmN0aW9uICggZ2wsIG9iamVjdCwgbmFtZSApIHtcblxuXHRcdHZhciB2ID0gb2JqZWN0WyBuYW1lIF07XG5cblx0XHRpZiAoIHYgIT09IHVuZGVmaW5lZCApIHRoaXMuc2V0VmFsdWUoIGdsLCBuYW1lLCB2ICk7XG5cblx0fTtcblxuXG5cdC8vIFN0YXRpYyBpbnRlcmZhY2VcblxuXHRXZWJHTFVuaWZvcm1zLnVwbG9hZCA9IGZ1bmN0aW9uICggZ2wsIHNlcSwgdmFsdWVzLCByZW5kZXJlciApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHZhciB1ID0gc2VxWyBpIF0sXG5cdFx0XHRcdHYgPSB2YWx1ZXNbIHUuaWQgXTtcblxuXHRcdFx0aWYgKCB2Lm5lZWRzVXBkYXRlICE9PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBub3RlOiBhbHdheXMgdXBkYXRpbmcgd2hlbiAubmVlZHNVcGRhdGUgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdHUuc2V0VmFsdWUoIGdsLCB2LnZhbHVlLCByZW5kZXJlciApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSA9IGZ1bmN0aW9uICggc2VxLCB2YWx1ZXMgKSB7XG5cblx0XHR2YXIgciA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0dmFyIHUgPSBzZXFbIGkgXTtcblx0XHRcdGlmICggdS5pZCBpbiB2YWx1ZXMgKSByLnB1c2goIHUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdHZhciBDb2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXG5cdFx0J2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuXHRcdCdicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcblx0XHQnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4Qixcblx0XHQnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4Qixcblx0XHQnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxuXHRcdCdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG5cdFx0J2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXG5cdFx0J2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXG5cdFx0J2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxuXHRcdCdpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXG5cdFx0J2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcblx0XHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcblx0XHQnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxuXHRcdCdsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcblx0XHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG5cdFx0J21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG5cdFx0J25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcblx0XHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcblx0XHQncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWJlY2NhcHVycGxlJzogMHg2NjMzOTksICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxuXHRcdCdyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxuXHRcdCdzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxuXHRcdCdzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXG5cdFx0J3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcblxuXHRmdW5jdGlvbiBDb2xvciggciwgZywgYiApIHtcblxuXHRcdGlmICggZyA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gciBpcyBUSFJFRS5Db2xvciwgaGV4IG9yIHN0cmluZ1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCByICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoIHIsIGcsIGIgKTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggQ29sb3IucHJvdG90eXBlLCB7XG5cblx0XHRpc0NvbG9yOiB0cnVlLFxuXG5cdFx0cjogMSwgZzogMSwgYjogMSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc0NvbG9yICkge1xuXG5cdFx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblxuXHRcdFx0XHR0aGlzLnNldEhleCggdmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHR0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHRoaXMuciA9IHNjYWxhcjtcblx0XHRcdHRoaXMuZyA9IHNjYWxhcjtcblx0XHRcdHRoaXMuYiA9IHNjYWxhcjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcblxuXHRcdFx0aGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XG5cblx0XHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG5cdFx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XG5cdFx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcblxuXHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdHRoaXMuZyA9IGc7XG5cdFx0XHR0aGlzLmIgPSBiO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0ZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcblxuXHRcdFx0XHRpZiAoIHQgPCAwICkgdCArPSAxO1xuXHRcdFx0XHRpZiAoIHQgPiAxICkgdCAtPSAxO1xuXHRcdFx0XHRpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XG5cdFx0XHRcdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XG5cdFx0XHRcdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcblx0XHRcdFx0cmV0dXJuIHA7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEhTTCggaCwgcywgbCApIHtcblxuXHRcdFx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXHRcdFx0XHRoID0gX01hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XG5cdFx0XHRcdHMgPSBfTWF0aC5jbGFtcCggcywgMCwgMSApO1xuXHRcdFx0XHRsID0gX01hdGguY2xhbXAoIGwsIDAsIDEgKTtcblxuXHRcdFx0XHRpZiAoIHMgPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xuXHRcdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcblxuXHRcdFx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xuXHRcdFx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcblx0XHRcdFx0XHR0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlQWxwaGEoIHN0cmluZyApIHtcblxuXHRcdFx0XHRpZiAoIHN0cmluZyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0dmFyIG07XG5cblx0XHRcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0XHQvLyByZ2IgLyBoc2xcblxuXHRcdFx0XHR2YXIgY29sb3I7XG5cdFx0XHRcdHZhciBuYW1lID0gbVsgMSBdO1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IG1bIDIgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncmdiJzpcblx0XHRcdFx0XHRjYXNlICdyZ2JhJzpcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcblx0XHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcblx0XHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcblx0XHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcblxuXHRcdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG5cdFx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2hzbCc6XG5cdFx0XHRcdFx0Y2FzZSAnaHNsYSc6XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihbMC05XSpcXC4/WzAtOV0rKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcblx0XHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XG5cdFx0XHRcdFx0XHRcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XG5cblx0XHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0XHQvLyBoZXggY29sb3JcblxuXHRcdFx0XHR2YXIgaGV4ID0gbVsgMSBdO1xuXHRcdFx0XHR2YXIgc2l6ZSA9IGhleC5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBzaXplID09PSAzICkge1xuXG5cdFx0XHRcdFx0Ly8gI2ZmMFxuXHRcdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAwICksIDE2ICkgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcblx0XHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMjU1O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcblxuXHRcdFx0XHRcdC8vICNmZjAwMDBcblx0XHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xuXHRcdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XG5cdFx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDQgKSArIGhleC5jaGFyQXQoIDUgKSwgMTYgKSAvIDI1NTtcblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcblx0XHRcdFx0dmFyIGhleCA9IENvbG9yS2V5d29yZHNbIHN0eWxlIF07XG5cblx0XHRcdFx0aWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIHJlZFxuXHRcdFx0XHRcdHRoaXMuc2V0SGV4KCBoZXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gdW5rbm93biBjb2xvclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xuXG5cdFx0XHR0aGlzLnIgPSBjb2xvci5yO1xuXHRcdFx0dGhpcy5nID0gY29sb3IuZztcblx0XHRcdHRoaXMuYiA9IGNvbG9yLmI7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuXHRcdFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cblx0XHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xuXHRcdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIGdhbW1hRmFjdG9yICk7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG5cdFx0XHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcblxuXHRcdFx0dmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcblxuXHRcdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcblx0XHRcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuXHRcdFx0dGhpcy5yID0gciAqIHI7XG5cdFx0XHR0aGlzLmcgPSBnICogZztcblx0XHRcdHRoaXMuYiA9IGIgKiBiO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xuXHRcdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcblx0XHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldEhleDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gKCB0aGlzLnIgKiAyNTUgKSA8PCAxNiBeICggdGhpcy5nICogMjU1ICkgPDwgOCBeICggdGhpcy5iICogMjU1ICkgPDwgMDtcblxuXHRcdH0sXG5cblx0XHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC0gNiApO1xuXG5cdFx0fSxcblxuXHRcdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcblxuXHRcdFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xuXG5cdFx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG5cdFx0XHR2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcblxuXHRcdFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcblx0XHRcdHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xuXG5cdFx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xuXG5cdFx0XHRcdGh1ZSA9IDA7XG5cdFx0XHRcdHNhdHVyYXRpb24gPSAwO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblxuXHRcdFx0XHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cblx0XHRcdFx0c3dpdGNoICggbWF4ICkge1xuXG5cdFx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcblx0XHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRodWUgLz0gNjtcblxuXHRcdFx0fVxuXG5cdFx0XHRoc2wuaCA9IGh1ZTtcblx0XHRcdGhzbC5zID0gc2F0dXJhdGlvbjtcblx0XHRcdGhzbC5sID0gbGlnaHRuZXNzO1xuXG5cdFx0XHRyZXR1cm4gaHNsO1xuXG5cdFx0fSxcblxuXHRcdGdldFN0eWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XG5cblx0XHR9LFxuXG5cdFx0b2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XG5cblx0XHRcdHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xuXG5cdFx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xuXG5cdFx0XHR0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHRcdHRoaXMuciArPSBjb2xvci5yO1xuXHRcdFx0dGhpcy5nICs9IGNvbG9yLmc7XG5cdFx0XHR0aGlzLmIgKz0gY29sb3IuYjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdFx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuXHRcdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcblx0XHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR0aGlzLnIgKz0gcztcblx0XHRcdHRoaXMuZyArPSBzO1xuXHRcdFx0dGhpcy5iICs9IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHN1YjogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdFx0dGhpcy5yID0gTWF0aC5tYXgoIDAsIHRoaXMuciAtIGNvbG9yLnIgKTtcblx0XHRcdHRoaXMuZyA9IE1hdGgubWF4KCAwLCB0aGlzLmcgLSBjb2xvci5nICk7XG5cdFx0XHR0aGlzLmIgPSBNYXRoLm1heCggMCwgdGhpcy5iIC0gY29sb3IuYiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdFx0dGhpcy5yICo9IGNvbG9yLnI7XG5cdFx0XHR0aGlzLmcgKj0gY29sb3IuZztcblx0XHRcdHRoaXMuYiAqPSBjb2xvci5iO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0XHR0aGlzLnIgKj0gcztcblx0XHRcdHRoaXMuZyAqPSBzO1xuXHRcdFx0dGhpcy5iICo9IHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGxlcnA6IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xuXG5cdFx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcblx0XHRcdHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xuXHRcdFx0dGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBjICkge1xuXG5cdFx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0XHR0aGlzLnIgPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0XHR0aGlzLmcgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0dGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9LFxuXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldEhleCgpO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcblx0ICovXG5cblx0dmFyIFVuaWZvcm1zTGliID0ge1xuXG5cdFx0Y29tbW9uOiB7XG5cblx0XHRcdGRpZmZ1c2U6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhlZWVlZWUgKSB9LFxuXHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXG5cblx0XHRcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0dXZUcmFuc2Zvcm06IHsgdmFsdWU6IG5ldyBNYXRyaXgzKCkgfSxcblxuXHRcdFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcblxuXHRcdH0sXG5cblx0XHRzcGVjdWxhcm1hcDoge1xuXG5cdFx0XHRzcGVjdWxhck1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXG5cdFx0fSxcblxuXHRcdGVudm1hcDoge1xuXG5cdFx0XHRlbnZNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGZsaXBFbnZNYXA6IHsgdmFsdWU6IC0gMSB9LFxuXHRcdFx0cmVmbGVjdGl2aXR5OiB7IHZhbHVlOiAxLjAgfSxcblx0XHRcdHJlZnJhY3Rpb25SYXRpbzogeyB2YWx1ZTogMC45OCB9XG5cblx0XHR9LFxuXG5cdFx0YW9tYXA6IHtcblxuXHRcdFx0YW9NYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGFvTWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH1cblxuXHRcdH0sXG5cblx0XHRsaWdodG1hcDoge1xuXG5cdFx0XHRsaWdodE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0bGlnaHRNYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxuXG5cdFx0fSxcblxuXHRcdGVtaXNzaXZlbWFwOiB7XG5cblx0XHRcdGVtaXNzaXZlTWFwOiB7IHZhbHVlOiBudWxsIH1cblxuXHRcdH0sXG5cblx0XHRidW1wbWFwOiB7XG5cblx0XHRcdGJ1bXBNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGJ1bXBTY2FsZTogeyB2YWx1ZTogMSB9XG5cblx0XHR9LFxuXG5cdFx0bm9ybWFsbWFwOiB7XG5cblx0XHRcdG5vcm1hbE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0bm9ybWFsU2NhbGU6IHsgdmFsdWU6IG5ldyBWZWN0b3IyKCAxLCAxICkgfVxuXG5cdFx0fSxcblxuXHRcdGRpc3BsYWNlbWVudG1hcDoge1xuXG5cdFx0XHRkaXNwbGFjZW1lbnRNYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdGRpc3BsYWNlbWVudFNjYWxlOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRkaXNwbGFjZW1lbnRCaWFzOiB7IHZhbHVlOiAwIH1cblxuXHRcdH0sXG5cblx0XHRyb3VnaG5lc3NtYXA6IHtcblxuXHRcdFx0cm91Z2huZXNzTWFwOiB7IHZhbHVlOiBudWxsIH1cblxuXHRcdH0sXG5cblx0XHRtZXRhbG5lc3NtYXA6IHtcblxuXHRcdFx0bWV0YWxuZXNzTWFwOiB7IHZhbHVlOiBudWxsIH1cblxuXHRcdH0sXG5cblx0XHRncmFkaWVudG1hcDoge1xuXG5cdFx0XHRncmFkaWVudE1hcDogeyB2YWx1ZTogbnVsbCB9XG5cblx0XHR9LFxuXG5cdFx0Zm9nOiB7XG5cblx0XHRcdGZvZ0RlbnNpdHk6IHsgdmFsdWU6IDAuMDAwMjUgfSxcblx0XHRcdGZvZ05lYXI6IHsgdmFsdWU6IDEgfSxcblx0XHRcdGZvZ0ZhcjogeyB2YWx1ZTogMjAwMCB9LFxuXHRcdFx0Zm9nQ29sb3I6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhmZmZmZmYgKSB9XG5cblx0XHR9LFxuXG5cdFx0bGlnaHRzOiB7XG5cblx0XHRcdGFtYmllbnRMaWdodENvbG9yOiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0XHRkaXJlY3Rpb25hbExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0Y29sb3I6IHt9LFxuXG5cdFx0XHRcdHNoYWRvdzoge30sXG5cdFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuXHRcdFx0fSB9LFxuXG5cdFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcblx0XHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0XHRzcG90TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuXHRcdFx0XHRjb2xvcjoge30sXG5cdFx0XHRcdHBvc2l0aW9uOiB7fSxcblx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0ZGlzdGFuY2U6IHt9LFxuXHRcdFx0XHRjb25lQ29zOiB7fSxcblx0XHRcdFx0cGVudW1icmFDb3M6IHt9LFxuXHRcdFx0XHRkZWNheToge30sXG5cblx0XHRcdFx0c2hhZG93OiB7fSxcblx0XHRcdFx0c2hhZG93Qmlhczoge30sXG5cdFx0XHRcdHNoYWRvd1JhZGl1czoge30sXG5cdFx0XHRcdHNoYWRvd01hcFNpemU6IHt9XG5cdFx0XHR9IH0sXG5cblx0XHRcdHNwb3RTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG5cdFx0XHRzcG90U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxuXG5cdFx0XHRwb2ludExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdFx0Y29sb3I6IHt9LFxuXHRcdFx0XHRwb3NpdGlvbjoge30sXG5cdFx0XHRcdGRlY2F5OiB7fSxcblx0XHRcdFx0ZGlzdGFuY2U6IHt9LFxuXG5cdFx0XHRcdHNoYWRvdzoge30sXG5cdFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxuXHRcdFx0XHRzaGFkb3dNYXBTaXplOiB7fSxcblx0XHRcdFx0c2hhZG93Q2FtZXJhTmVhcjoge30sXG5cdFx0XHRcdHNoYWRvd0NhbWVyYUZhcjoge31cblx0XHRcdH0gfSxcblxuXHRcdFx0cG9pbnRTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXG5cdFx0XHRwb2ludFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcblxuXHRcdFx0aGVtaXNwaGVyZUxpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdFx0ZGlyZWN0aW9uOiB7fSxcblx0XHRcdFx0c2t5Q29sb3I6IHt9LFxuXHRcdFx0XHRncm91bmRDb2xvcjoge31cblx0XHRcdH0gfSxcblxuXHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgQlJERiBkYXRhIG5lZWRzIHRvIGJlIG1vdmVkIGZyb20gZXhhbXBsZSB0byBtYWluIHNyY1xuXHRcdFx0cmVjdEFyZWFMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcdGNvbG9yOiB7fSxcblx0XHRcdFx0cG9zaXRpb246IHt9LFxuXHRcdFx0XHR3aWR0aDoge30sXG5cdFx0XHRcdGhlaWdodDoge31cblx0XHRcdH0gfVxuXG5cdFx0fSxcblxuXHRcdHBvaW50czoge1xuXG5cdFx0XHRkaWZmdXNlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZWVlZWVlICkgfSxcblx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxuXHRcdFx0c2l6ZTogeyB2YWx1ZTogMS4wIH0sXG5cdFx0XHRzY2FsZTogeyB2YWx1ZTogMS4wIH0sXG5cdFx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcblx0XHRcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiBuZXcgTWF0cml4MygpIH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVbmlmb3JtIFV0aWxpdGllc1xuXHQgKi9cblxuXHR2YXIgVW5pZm9ybXNVdGlscyA9IHtcblxuXHRcdG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xuXG5cdFx0XHR2YXIgbWVyZ2VkID0ge307XG5cblx0XHRcdGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcblxuXHRcdFx0XHR2YXIgdG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBwIGluIHRtcCApIHtcblxuXHRcdFx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZXJnZWQ7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICggdW5pZm9ybXNfc3JjICkge1xuXG5cdFx0XHR2YXIgdW5pZm9ybXNfZHN0ID0ge307XG5cblx0XHRcdGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcblxuXHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXSA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xuXG5cdFx0XHRcdFx0dmFyIHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJfc3JjICYmICggcGFyYW1ldGVyX3NyYy5pc0NvbG9yIHx8XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJfc3JjLmlzTWF0cml4MyB8fCBwYXJhbWV0ZXJfc3JjLmlzTWF0cml4NCB8fFxuXHRcdFx0XHRcdFx0cGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjIgfHwgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjMgfHwgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjQgfHxcblx0XHRcdFx0XHRcdHBhcmFtZXRlcl9zcmMuaXNUZXh0dXJlICkgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuaWZvcm1zX2RzdDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHZhciBhbHBoYW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcclxcblxcclxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGFscGhhbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgYWxwaGF0ZXN0X2ZyYWdtZW50ID0gXCIjaWZkZWYgQUxQSEFURVNUXFxyXFxuXFxyXFxuXFx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGFvbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxyXFxuXFxyXFxuXFx0Ly8gcmVhZHMgY2hhbm5lbCBSLCBjb21wYXRpYmxlIHdpdGggYSBjb21iaW5lZCBPY2NsdXNpb25Sb3VnaG5lc3NNZXRhbGxpYyAoUkdCKSB0ZXh0dXJlXFxyXFxuXFx0ZmxvYXQgYW1iaWVudE9jY2x1c2lvbiA9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcclxcblxcclxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uO1xcclxcblxcclxcblxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKVxcclxcblxcclxcblxcdFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICo9IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggZG90TlYsIGFtYmllbnRPY2NsdXNpb24sIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGFvbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQU9NQVBcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciBiZWdpbl92ZXJ0ZXggPSBcIlxcclxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcclxcblwiO1xuXG5cdHZhciBiZWdpbm5vcm1hbF92ZXJ0ZXggPSBcIlxcclxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxyXFxuXCI7XG5cblx0dmFyIGJzZGZzID0gXCJmbG9hdCBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXHJcXG5cXHJcXG5cXHRpZiggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXHJcXG5cXHJcXG4jaWYgZGVmaW5lZCAoIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMgKVxcclxcblxcclxcblxcdFxcdC8vIGJhc2VkIHVwb24gRnJvc3RiaXRlIDMgTW92aW5nIHRvIFBoeXNpY2FsbHktYmFzZWQgUmVuZGVyaW5nXFxyXFxuXFx0XFx0Ly8gcGFnZSAzMiwgZXF1YXRpb24gMjY6IEVbd2luZG93MV1cXHJcXG5cXHRcXHQvLyBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXFxyXFxuXFx0XFx0Ly8gdGhpcyBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIG9uIHNwb3QgYW5kIHBvaW50IGxpZ2h0cyB3aG8gYXJlIHJlcHJlc2VudGVkIGFzIGx1bWlub3VzIGludGVuc2l0eVxcclxcblxcdFxcdC8vIGJ1dCB3aG8gbXVzdCBiZSBjb252ZXJ0ZWQgdG8gbHVtaW5vdXMgaXJyYWRpYW5jZSBmb3Igc3VyZmFjZSBsaWdodGluZyBjYWxjdWxhdGlvblxcclxcblxcdFxcdGZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTtcXHJcXG5cXHRcXHRmbG9hdCBtYXhEaXN0YW5jZUN1dG9mZkZhY3RvciA9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7XFxyXFxuXFx0XFx0cmV0dXJuIGRpc3RhbmNlRmFsbG9mZiAqIG1heERpc3RhbmNlQ3V0b2ZmRmFjdG9yO1xcclxcblxcclxcbiNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHBvdyggc2F0dXJhdGUoIC1saWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRyZXR1cm4gMS4wO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG52ZWMzIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGRpZmZ1c2VDb2xvcjtcXHJcXG5cXHJcXG59IC8vIHZhbGlkYXRlZFxcclxcblxcclxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IGRvdExIICkge1xcclxcblxcclxcblxcdC8vIE9yaWdpbmFsIGFwcHJveGltYXRpb24gYnkgQ2hyaXN0b3BoZSBTY2hsaWNrICc5NFxcclxcblxcdC8vIGZsb2F0IGZyZXNuZWwgPSBwb3coIDEuMCAtIGRvdExILCA1LjAgKTtcXHJcXG5cXHJcXG5cXHQvLyBPcHRpbWl6ZWQgdmFyaWFudCAocHJlc2VudGVkIGJ5IEVwaWMgYXQgU0lHR1JBUEggJzEzKVxcclxcblxcdC8vIGh0dHBzOi8vY2RuMi51bnJlYWxlbmdpbmUuY29tL1Jlc291cmNlcy9maWxlcy8yMDEzU2lnZ3JhcGhQcmVzZW50YXRpb25zTm90ZXMtMjY5MTU3MzgucGRmXFxyXFxuXFx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0NzMgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuICggMS4wIC0gc3BlY3VsYXJDb2xvciApICogZnJlc25lbCArIHNwZWN1bGFyQ29sb3I7XFxyXFxuXFxyXFxufSAvLyB2YWxpZGF0ZWRcXHJcXG5cXHJcXG4vLyBNaWNyb2ZhY2V0IE1vZGVscyBmb3IgUmVmcmFjdGlvbiB0aHJvdWdoIFJvdWdoIFN1cmZhY2VzIC0gZXF1YXRpb24gKDM0KVxcclxcbi8vIGh0dHA6Ly9ncmFwaGljcmFudHMuYmxvZ3Nwb3QuY29tLzIwMTMvMDgvc3BlY3VsYXItYnJkZi1yZWZlcmVuY2UuaHRtbFxcclxcbi8vIGFscGhhIGlzIFxcXCJyb3VnaG5lc3Mgc3F1YXJlZFxcXCIgaW4gRGlzbmV54oCZcyByZXBhcmFtZXRlcml6YXRpb25cXHJcXG5mbG9hdCBHX0dHWF9TbWl0aCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXHJcXG5cXHJcXG5cXHQvLyBnZW9tZXRyeSB0ZXJtIChub3JtYWxpemVkKSA9IEcobCnii4VHKHYpIC8gNChu4ouFbCkobuKLhXYpXFxyXFxuXFx0Ly8gYWxzbyBzZWUgIzEyMTUxXFxyXFxuXFxyXFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcclxcblxcclxcblxcdGZsb2F0IGdsID0gZG90TkwgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXHJcXG5cXHRmbG9hdCBndiA9IGRvdE5WICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIDEuMCAvICggZ2wgKiBndiApO1xcclxcblxcclxcbn0gLy8gdmFsaWRhdGVkXFxyXFxuXFxyXFxuLy8gTW92aW5nIEZyb3N0Yml0ZSB0byBQaHlzaWNhbGx5IEJhc2VkIFJlbmRlcmluZyAzLjAgLSBwYWdlIDEyLCBsaXN0aW5nIDJcXHJcXG4vLyBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXFxyXFxuZmxvYXQgR19HR1hfU21pdGhDb3JyZWxhdGVkKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcclxcblxcclxcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXHJcXG5cXHJcXG5cXHQvLyBkb3ROTCBhbmQgZG90TlYgYXJlIGV4cGxpY2l0bHkgc3dhcHBlZC4gVGhpcyBpcyBub3QgYSBtaXN0YWtlLlxcclxcblxcdGZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXHJcXG5cXHRmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4vLyBNaWNyb2ZhY2V0IE1vZGVscyBmb3IgUmVmcmFjdGlvbiB0aHJvdWdoIFJvdWdoIFN1cmZhY2VzIC0gZXF1YXRpb24gKDMzKVxcclxcbi8vIGh0dHA6Ly9ncmFwaGljcmFudHMuYmxvZ3Nwb3QuY29tLzIwMTMvMDgvc3BlY3VsYXItYnJkZi1yZWZlcmVuY2UuaHRtbFxcclxcbi8vIGFscGhhIGlzIFxcXCJyb3VnaG5lc3Mgc3F1YXJlZFxcXCIgaW4gRGlzbmV54oCZcyByZXBhcmFtZXRlcml6YXRpb25cXHJcXG5mbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcclxcblxcclxcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXHJcXG5cXHJcXG5cXHRmbG9hdCBkZW5vbSA9IHBvdzIoIGRvdE5IICkgKiAoIGEyIC0gMS4wICkgKyAxLjA7IC8vIGF2b2lkIGFscGhhID0gMCB3aXRoIGRvdE5IID0gMVxcclxcblxcclxcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4vLyBHR1ggRGlzdHJpYnV0aW9uLCBTY2hsaWNrIEZyZXNuZWwsIEdHWC1TbWl0aCBWaXNpYmlsaXR5XFxyXFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXHJcXG5cXHJcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApOyAvLyBVRTQncyByb3VnaG5lc3NcXHJcXG5cXHJcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcclxcblxcclxcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiApICk7XFxyXFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcclxcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXHJcXG5cXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXHJcXG5cXHJcXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgRyA9IEdfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xcclxcblxcclxcblxcdGZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxyXFxuXFxyXFxufSAvLyB2YWxpZGF0ZWRcXHJcXG5cXHJcXG4vLyBSZWN0IEFyZWEgTGlnaHRcXHJcXG5cXHJcXG4vLyBSZWFsLVRpbWUgUG9seWdvbmFsLUxpZ2h0IFNoYWRpbmcgd2l0aCBMaW5lYXJseSBUcmFuc2Zvcm1lZCBDb3NpbmVzXFxyXFxuLy8gYnkgRXJpYyBIZWl0eiwgSm9uYXRoYW4gRHVwdXksIFN0ZXBoZW4gSGlsbCBhbmQgRGF2aWQgTmV1YmVsdFxcclxcbi8vIGNvZGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zZWxmc2hhZG93L2x0Y19jb2RlL1xcclxcblxcclxcbnZlYzIgTFRDX1V2KCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcclxcblxcclxcblxcdGNvbnN0IGZsb2F0IExVVF9TSVpFICA9IDY0LjA7XFxyXFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKCBMVVRfU0laRSAtIDEuMCApIC8gTFVUX1NJWkU7XFxyXFxuXFx0Y29uc3QgZmxvYXQgTFVUX0JJQVMgID0gMC41IC8gTFVUX1NJWkU7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBOLCBWICkgKTtcXHJcXG5cXHJcXG5cXHQvLyB0ZXh0dXJlIHBhcmFtZXRlcml6ZWQgYnkgc3FydCggR0dYIGFscGhhICkgYW5kIHNxcnQoIDEgLSBjb3MoIHRoZXRhICkgKVxcclxcblxcdHZlYzIgdXYgPSB2ZWMyKCByb3VnaG5lc3MsIHNxcnQoIDEuMCAtIGRvdE5WICkgKTtcXHJcXG5cXHJcXG5cXHR1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIHV2O1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgZiApIHtcXHJcXG5cXHJcXG5cXHQvLyBSZWFsLVRpbWUgQXJlYSBMaWdodGluZzogYSBKb3VybmV5IGZyb20gUmVzZWFyY2ggdG8gUHJvZHVjdGlvbiAocC4xMDIpXFxyXFxuXFx0Ly8gQW4gYXBwcm94aW1hdGlvbiBvZiB0aGUgZm9ybSBmYWN0b3Igb2YgYSBob3Jpem9uLWNsaXBwZWQgcmVjdGFuZ2xlLlxcclxcblxcclxcblxcdGZsb2F0IGwgPSBsZW5ndGgoIGYgKTtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gbWF4KCAoIGwgKiBsICsgZi56ICkgLyAoIGwgKyAxLjAgKSwgMC4wICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZlYzMgTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIHYxLCBjb25zdCBpbiB2ZWMzIHYyICkge1xcclxcblxcclxcblxcdGZsb2F0IHggPSBkb3QoIHYxLCB2MiApO1xcclxcblxcclxcblxcdGZsb2F0IHkgPSBhYnMoIHggKTtcXHJcXG5cXHJcXG5cXHQvLyByYXRpb25hbCBwb2x5bm9taWFsIGFwcHJveGltYXRpb24gdG8gdGhldGEgLyBzaW4oIHRoZXRhICkgLyAyUElcXHJcXG5cXHRmbG9hdCBhID0gMC44NTQzOTg1ICsgKCAwLjQ5NjUxNTUgKyAwLjAxNDUyMDYgKiB5ICkgKiB5O1xcclxcblxcdGZsb2F0IGIgPSAzLjQxNzU5NDAgKyAoIDQuMTYxNjcyNCArIHkgKSAqIHk7XFxyXFxuXFx0ZmxvYXQgdiA9IGEgLyBiO1xcclxcblxcclxcblxcdGZsb2F0IHRoZXRhX3NpbnRoZXRhID0gKCB4ID4gMC4wICkgPyB2IDogMC41ICogaW52ZXJzZXNxcnQoIG1heCggMS4wIC0geCAqIHgsIDFlLTcgKSApIC0gdjtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gY3Jvc3MoIHYxLCB2MiApICogdGhldGFfc2ludGhldGE7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZlYzMgTFRDX0V2YWx1YXRlKCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gdmVjMyBQLCBjb25zdCBpbiBtYXQzIG1JbnYsIGNvbnN0IGluIHZlYzMgcmVjdENvb3Jkc1sgNCBdICkge1xcclxcblxcclxcblxcdC8vIGJhaWwgaWYgcG9pbnQgaXMgb24gYmFjayBzaWRlIG9mIHBsYW5lIG9mIGxpZ2h0XFxyXFxuXFx0Ly8gYXNzdW1lcyBjY3cgd2luZGluZyBvcmRlciBvZiBsaWdodCB2ZXJ0aWNlc1xcclxcblxcdHZlYzMgdjEgPSByZWN0Q29vcmRzWyAxIF0gLSByZWN0Q29vcmRzWyAwIF07XFxyXFxuXFx0dmVjMyB2MiA9IHJlY3RDb29yZHNbIDMgXSAtIHJlY3RDb29yZHNbIDAgXTtcXHJcXG5cXHR2ZWMzIGxpZ2h0Tm9ybWFsID0gY3Jvc3MoIHYxLCB2MiApO1xcclxcblxcclxcblxcdGlmKCBkb3QoIGxpZ2h0Tm9ybWFsLCBQIC0gcmVjdENvb3Jkc1sgMCBdICkgPCAwLjAgKSByZXR1cm4gdmVjMyggMC4wICk7XFxyXFxuXFxyXFxuXFx0Ly8gY29uc3RydWN0IG9ydGhvbm9ybWFsIGJhc2lzIGFyb3VuZCBOXFxyXFxuXFx0dmVjMyBUMSwgVDI7XFxyXFxuXFx0VDEgPSBub3JtYWxpemUoIFYgLSBOICogZG90KCBWLCBOICkgKTtcXHJcXG5cXHRUMiA9IC0gY3Jvc3MoIE4sIFQxICk7IC8vIG5lZ2F0ZWQgZnJvbSBwYXBlcjsgcG9zc2libHkgZHVlIHRvIGEgZGlmZmVyZW50IGhhbmRlZG5lc3Mgb2Ygd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW1cXHJcXG5cXHJcXG5cXHQvLyBjb21wdXRlIHRyYW5zZm9ybVxcclxcblxcdG1hdDMgbWF0ID0gbUludiAqIHRyYW5zcG9zZU1hdDMoIG1hdDMoIFQxLCBUMiwgTiApICk7XFxyXFxuXFxyXFxuXFx0Ly8gdHJhbnNmb3JtIHJlY3RcXHJcXG5cXHR2ZWMzIGNvb3Jkc1sgNCBdO1xcclxcblxcdGNvb3Jkc1sgMCBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAwIF0gLSBQICk7XFxyXFxuXFx0Y29vcmRzWyAxIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDEgXSAtIFAgKTtcXHJcXG5cXHRjb29yZHNbIDIgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMiBdIC0gUCApO1xcclxcblxcdGNvb3Jkc1sgMyBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAzIF0gLSBQICk7XFxyXFxuXFxyXFxuXFx0Ly8gcHJvamVjdCByZWN0IG9udG8gc3BoZXJlXFxyXFxuXFx0Y29vcmRzWyAwIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMCBdICk7XFxyXFxuXFx0Y29vcmRzWyAxIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMSBdICk7XFxyXFxuXFx0Y29vcmRzWyAyIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMiBdICk7XFxyXFxuXFx0Y29vcmRzWyAzIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMyBdICk7XFxyXFxuXFxyXFxuXFx0Ly8gY2FsY3VsYXRlIHZlY3RvciBmb3JtIGZhY3RvclxcclxcblxcdHZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApO1xcclxcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDAgXSwgY29vcmRzWyAxIF0gKTtcXHJcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAxIF0sIGNvb3Jkc1sgMiBdICk7XFxyXFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApO1xcclxcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDMgXSwgY29vcmRzWyAwIF0gKTtcXHJcXG5cXHJcXG5cXHQvLyBhZGp1c3QgZm9yIGhvcml6b24gY2xpcHBpbmdcXHJcXG5cXHRmbG9hdCByZXN1bHQgPSBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIHZlY3RvckZvcm1GYWN0b3IgKTtcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHRyZXR1cm4gdmVjMyggcmVzdWx0ICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi8vIEVuZCBSZWN0IEFyZWEgTGlnaHRcXHJcXG5cXHJcXG4vLyByZWY6IGh0dHBzOi8vd3d3LnVucmVhbGVuZ2luZS5jb20vYmxvZy9waHlzaWNhbGx5LWJhc2VkLXNoYWRpbmctb24tbW9iaWxlIC0gZW52aXJvbm1lbnRCUkRGIGZvciBHR1ggb24gbW9iaWxlXFxyXFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcclxcblxcclxcblxcdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xcclxcblxcclxcblxcdGNvbnN0IHZlYzQgYzEgPSB2ZWM0KCAxLCAwLjA0MjUsIDEuMDQsIC0gMC4wNCApO1xcclxcblxcclxcblxcdHZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XFxyXFxuXFxyXFxuXFx0dmVjMiBBQiA9IHZlYzIoIC0xLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXHJcXG5cXHJcXG5cXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIEFCLnggKyBBQi55O1xcclxcblxcclxcbn0gLy8gdmFsaWRhdGVkXFxyXFxuXFxyXFxuXFxyXFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCApIHtcXHJcXG5cXHJcXG5cXHQvLyBnZW9tZXRyeSB0ZXJtIGlzIChuIGRvdCBsKShuIGRvdCB2KSAvIDQobiBkb3QgbCkobiBkb3QgdilcXHJcXG5cXHRyZXR1cm4gMC4yNTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgRF9CbGlublBob25nKCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcclxcblxcclxcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG52ZWMzIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXHJcXG5cXHJcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcclxcblxcclxcblxcdC8vZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICkgKTtcXHJcXG5cXHQvL2Zsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXHJcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxyXFxuXFx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxyXFxuXFxyXFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcclxcblxcclxcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcclxcblxcclxcblxcdHJldHVybiBGICogKCBHICogRCApO1xcclxcblxcclxcbn0gLy8gdmFsaWRhdGVkXFxyXFxuXFxyXFxuLy8gc291cmNlOiBodHRwOi8vc2ltb25zdGVjaGJsb2cuYmxvZ3Nwb3QuY2EvMjAxMS8xMi9taWNyb2ZhY2V0LWJyZGYuaHRtbFxcclxcbmZsb2F0IEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggY29uc3QgaW4gZmxvYXQgZ2d4Um91Z2huZXNzICkge1xcclxcblxcdHJldHVybiAoIDIuMCAvIHBvdzIoIGdneFJvdWdobmVzcyArIDAuMDAwMSApIC0gMi4wICk7XFxyXFxufVxcclxcblxcclxcbmZsb2F0IEJsaW5uRXhwb25lbnRUb0dHWFJvdWdobmVzcyggY29uc3QgaW4gZmxvYXQgYmxpbm5FeHBvbmVudCApIHtcXHJcXG5cXHRyZXR1cm4gc3FydCggMi4wIC8gKCBibGlubkV4cG9uZW50ICsgMi4wICkgKTtcXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIGJ1bXBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXHJcXG5cXHJcXG5cXHQvLyBEZXJpdmF0aXZlIG1hcHMgLSBidW1wIG1hcHBpbmcgdW5wYXJhbWV0cml6ZWQgc3VyZmFjZXMgYnkgTW9ydGVuIE1pa2tlbHNlblxcclxcblxcdC8vIGh0dHA6Ly9tbWlra2Vsc2VuM2QuYmxvZ3Nwb3Quc2svMjAxMS8wNy9kZXJpdmF0aXZlLW1hcHMuaHRtbFxcclxcblxcclxcblxcdC8vIEV2YWx1YXRlIHRoZSBkZXJpdmF0aXZlIG9mIHRoZSBoZWlnaHQgdy5yLnQuIHNjcmVlbi1zcGFjZSB1c2luZyBmb3J3YXJkIGRpZmZlcmVuY2luZyAobGlzdGluZyAyKVxcclxcblxcclxcblxcdHZlYzIgZEhkeHlfZndkKCkge1xcclxcblxcclxcblxcdFxcdHZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcXHJcXG5cXHRcXHR2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1xcclxcblxcdFxcdGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcclxcblxcdFxcdGZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1xcclxcblxcclxcblxcdFxcdHJldHVybiB2ZWMyKCBkQngsIGRCeSApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1xcclxcblxcclxcblxcdFxcdC8vIFdvcmthcm91bmQgZm9yIEFkcmVubyAzWFggZEZkKiggdmVjMyApIGJ1Zy4gU2VlICM5OTg4XFxyXFxuXFxyXFxuXFx0XFx0dmVjMyB2U2lnbWFYID0gdmVjMyggZEZkeCggc3VyZl9wb3MueCApLCBkRmR4KCBzdXJmX3Bvcy55ICksIGRGZHgoIHN1cmZfcG9zLnogKSApO1xcclxcblxcdFxcdHZlYzMgdlNpZ21hWSA9IHZlYzMoIGRGZHkoIHN1cmZfcG9zLnggKSwgZEZkeSggc3VyZl9wb3MueSApLCBkRmR5KCBzdXJmX3Bvcy56ICkgKTtcXHJcXG5cXHRcXHR2ZWMzIHZOID0gc3VyZl9ub3JtO1xcdFxcdC8vIG5vcm1hbGl6ZWRcXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxyXFxuXFx0XFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcclxcblxcclxcblxcdFxcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxyXFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXHJcXG5cXHJcXG5cXHR2ZWM0IHBsYW5lO1xcclxcblxcclxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BcXHJcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBVTklPTl9DTElQUElOR19QTEFORVM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0cGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcclxcblxcdFxcdGlmICggZG90KCB2Vmlld1Bvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FU1xcclxcblxcclxcblxcdFxcdGJvb2wgY2xpcHBlZCA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcFxcclxcblxcdFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxyXFxuXFx0XFx0XFx0Y2xpcHBlZCA9ICggZG90KCB2Vmlld1Bvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGNsaXBwZWQgKSBkaXNjYXJkO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxyXFxuXFxyXFxuXFx0I2lmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXHJcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAgJiYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcclxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBjbGlwcGluZ19wbGFuZXNfdmVydGV4ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDAgJiYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICEgZGVmaW5lZCggUEhPTkcgKVxcclxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcclxcbiNlbmRpZlxcclxcblxcclxcblwiO1xuXG5cdHZhciBjb2xvcl9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcclxcblxcclxcblxcdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciBjb2xvcl9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxyXFxuXFxyXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgY29sb3JfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfQ09MT1JcXHJcXG5cXHJcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciBjb2xvcl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfQ09MT1JcXHJcXG5cXHJcXG5cXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciBjb21tb24gPSBcIiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxcclxcbiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MThcXHJcXG4jZGVmaW5lIFBJX0hBTEYgMS41NzA3OTYzMjY3OTQ5XFxyXFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MThcXHJcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXHJcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXHJcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcclxcblxcclxcbiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXHJcXG4jZGVmaW5lIHdoaXRlQ29tcGxpbWVudChhKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcclxcblxcclxcbmZsb2F0IHBvdzIoIGNvbnN0IGluIGZsb2F0IHggKSB7IHJldHVybiB4Kng7IH1cXHJcXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXHJcXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxyXFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXHJcXG4vLyBleHBlY3RzIHZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgWzAsMV14WzAsMV0sIHJldHVybnMgdmFsdWVzIGluIHRoZSBbMCwxXSByYW5nZS5cXHJcXG4vLyBkbyBub3QgY29sbGFwc2UgaW50byBhIHNpbmdsZSBmdW5jdGlvbiBwZXI6IGh0dHA6Ly9ieXRlYmxhY2tzbWl0aC5jb20vaW1wcm92ZW1lbnRzLXRvLXRoZS1jYW5vbmljYWwtb25lLWxpbmVyLWdsc2wtcmFuZC1mb3Itb3BlbmdsLWVzLTItMC9cXHJcXG5oaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkge1xcclxcblxcdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcXHJcXG5cXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcXHJcXG5cXHRyZXR1cm4gZnJhY3Qoc2luKHNuKSAqIGMpO1xcclxcbn1cXHJcXG5cXHJcXG5zdHJ1Y3QgSW5jaWRlbnRMaWdodCB7XFxyXFxuXFx0dmVjMyBjb2xvcjtcXHJcXG5cXHR2ZWMzIGRpcmVjdGlvbjtcXHJcXG5cXHRib29sIHZpc2libGU7XFxyXFxufTtcXHJcXG5cXHJcXG5zdHJ1Y3QgUmVmbGVjdGVkTGlnaHQge1xcclxcblxcdHZlYzMgZGlyZWN0RGlmZnVzZTtcXHJcXG5cXHR2ZWMzIGRpcmVjdFNwZWN1bGFyO1xcclxcblxcdHZlYzMgaW5kaXJlY3REaWZmdXNlO1xcclxcblxcdHZlYzMgaW5kaXJlY3RTcGVjdWxhcjtcXHJcXG59O1xcclxcblxcclxcbnN0cnVjdCBHZW9tZXRyaWNDb250ZXh0IHtcXHJcXG5cXHR2ZWMzIHBvc2l0aW9uO1xcclxcblxcdHZlYzMgbm9ybWFsO1xcclxcblxcdHZlYzMgdmlld0RpcjtcXHJcXG59O1xcclxcblxcclxcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi8vIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvR0xTTF9Qcm9ncmFtbWluZy9BcHBseWluZ19NYXRyaXhfVHJhbnNmb3JtYXRpb25zXFxyXFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcclxcblxcclxcblxcdHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcclxcblxcclxcblxcdHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcclxcblxcclxcblxcdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxubWF0MyB0cmFuc3Bvc2VNYXQzKCBjb25zdCBpbiBtYXQzIG0gKSB7XFxyXFxuXFxyXFxuXFx0bWF0MyB0bXA7XFxyXFxuXFxyXFxuXFx0dG1wWyAwIF0gPSB2ZWMzKCBtWyAwIF0ueCwgbVsgMSBdLngsIG1bIDIgXS54ICk7XFxyXFxuXFx0dG1wWyAxIF0gPSB2ZWMzKCBtWyAwIF0ueSwgbVsgMSBdLnksIG1bIDIgXS55ICk7XFxyXFxuXFx0dG1wWyAyIF0gPSB2ZWMzKCBtWyAwIF0ueiwgbVsgMSBdLnosIG1bIDIgXS56ICk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIHRtcDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVsYXRpdmVfbHVtaW5hbmNlXFxyXFxuZmxvYXQgbGluZWFyVG9SZWxhdGl2ZUx1bWluYW5jZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHtcXHJcXG5cXHJcXG5cXHR2ZWMzIHdlaWdodHMgPSB2ZWMzKCAwLjIxMjYsIDAuNzE1MiwgMC4wNzIyICk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIGRvdCggd2VpZ2h0cywgY29sb3IucmdiICk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xuXG5cdHZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxyXFxuXFxyXFxuI2RlZmluZSBjdWJlVVZfdGV4dHVyZVNpemUgKDEwMjQuMClcXHJcXG5cXHJcXG5pbnQgZ2V0RmFjZUZyb21EaXJlY3Rpb24odmVjMyBkaXJlY3Rpb24pIHtcXHJcXG5cXHR2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyhkaXJlY3Rpb24pO1xcclxcblxcdGludCBmYWNlID0gLTE7XFxyXFxuXFx0aWYoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnogKSB7XFxyXFxuXFx0XFx0aWYoYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxyXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMCA6IDM7XFxyXFxuXFx0XFx0ZWxzZVxcclxcblxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEgOiA0O1xcclxcblxcdH1cXHJcXG5cXHRlbHNlIHtcXHJcXG5cXHRcXHRpZihhYnNEaXJlY3Rpb24ueiA+IGFic0RpcmVjdGlvbi55IClcXHJcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyIDogNTtcXHJcXG5cXHRcXHRlbHNlXFxyXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMSA6IDQ7XFxyXFxuXFx0fVxcclxcblxcdHJldHVybiBmYWNlO1xcclxcbn1cXHJcXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMSAgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMS4wKVxcclxcbiNkZWZpbmUgY3ViZVVWX3JhbmdlQ2xhbXAgKGV4cDIoKDYuMCAtIDEuMCkgKiAyLjApKVxcclxcblxcclxcbnZlYzIgTWlwTGV2ZWxJbmZvKCB2ZWMzIHZlYywgZmxvYXQgcm91Z2huZXNzTGV2ZWwsIGZsb2F0IHJvdWdobmVzcyApIHtcXHJcXG5cXHRmbG9hdCBzY2FsZSA9IGV4cDIoY3ViZVVWX21heExvZHMxIC0gcm91Z2huZXNzTGV2ZWwpO1xcclxcblxcdGZsb2F0IGR4Um91Z2huZXNzID0gZEZkeChyb3VnaG5lc3MpO1xcclxcblxcdGZsb2F0IGR5Um91Z2huZXNzID0gZEZkeShyb3VnaG5lc3MpO1xcclxcblxcdHZlYzMgZHggPSBkRmR4KCB2ZWMgKiBzY2FsZSAqIGR4Um91Z2huZXNzICk7XFxyXFxuXFx0dmVjMyBkeSA9IGRGZHkoIHZlYyAqIHNjYWxlICogZHlSb3VnaG5lc3MgKTtcXHJcXG5cXHRmbG9hdCBkID0gbWF4KCBkb3QoIGR4LCBkeCApLCBkb3QoIGR5LCBkeSApICk7XFxyXFxuXFx0Ly8gQ2xhbXAgdGhlIHZhbHVlIHRvIHRoZSBtYXggbWlwIGxldmVsIGNvdW50cy4gaGFyZCBjb2RlZCB0byA2IG1pcHNcXHJcXG5cXHRkID0gY2xhbXAoZCwgMS4wLCBjdWJlVVZfcmFuZ2VDbGFtcCk7XFxyXFxuXFx0ZmxvYXQgbWlwTGV2ZWwgPSAwLjUgKiBsb2cyKGQpO1xcclxcblxcdHJldHVybiB2ZWMyKGZsb29yKG1pcExldmVsKSwgZnJhY3QobWlwTGV2ZWwpKTtcXHJcXG59XFxyXFxuXFxyXFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczIgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMi4wKVxcclxcbiNkZWZpbmUgY3ViZVVWX3JjcFRleHR1cmVTaXplICgxLjAgLyBjdWJlVVZfdGV4dHVyZVNpemUpXFxyXFxuXFxyXFxudmVjMiBnZXRDdWJlVVYodmVjMyBkaXJlY3Rpb24sIGZsb2F0IHJvdWdobmVzc0xldmVsLCBmbG9hdCBtaXBMZXZlbCkge1xcclxcblxcdG1pcExldmVsID0gcm91Z2huZXNzTGV2ZWwgPiBjdWJlVVZfbWF4TG9kczIgLSAzLjAgPyAwLjAgOiBtaXBMZXZlbDtcXHJcXG5cXHRmbG9hdCBhID0gMTYuMCAqIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZTtcXHJcXG5cXHJcXG5cXHR2ZWMyIGV4cDJfcGFja2VkID0gZXhwMiggdmVjMiggcm91Z2huZXNzTGV2ZWwsIG1pcExldmVsICkgKTtcXHJcXG5cXHR2ZWMyIHJjcF9leHAyX3BhY2tlZCA9IHZlYzIoIDEuMCApIC8gZXhwMl9wYWNrZWQ7XFxyXFxuXFx0Ly8gZmxvYXQgcG93U2NhbGUgPSBleHAyKHJvdWdobmVzc0xldmVsICsgbWlwTGV2ZWwpO1xcclxcblxcdGZsb2F0IHBvd1NjYWxlID0gZXhwMl9wYWNrZWQueCAqIGV4cDJfcGFja2VkLnk7XFxyXFxuXFx0Ly8gZmxvYXQgc2NhbGUgPSAgMS4wIC8gZXhwMihyb3VnaG5lc3NMZXZlbCArIDIuMCArIG1pcExldmVsKTtcXHJcXG5cXHRmbG9hdCBzY2FsZSA9IHJjcF9leHAyX3BhY2tlZC54ICogcmNwX2V4cDJfcGFja2VkLnkgKiAwLjI1O1xcclxcblxcdC8vIGZsb2F0IG1pcE9mZnNldCA9IDAuNzUqKDEuMCAtIDEuMC9leHAyKG1pcExldmVsKSkvZXhwMihyb3VnaG5lc3NMZXZlbCk7XFxyXFxuXFx0ZmxvYXQgbWlwT2Zmc2V0ID0gMC43NSooMS4wIC0gcmNwX2V4cDJfcGFja2VkLnkpICogcmNwX2V4cDJfcGFja2VkLng7XFxyXFxuXFxyXFxuXFx0Ym9vbCBiUmVzID0gbWlwTGV2ZWwgPT0gMC4wO1xcclxcblxcdHNjYWxlID0gIGJSZXMgJiYgKHNjYWxlIDwgYSkgPyBhIDogc2NhbGU7XFxyXFxuXFxyXFxuXFx0dmVjMyByO1xcclxcblxcdHZlYzIgb2Zmc2V0O1xcclxcblxcdGludCBmYWNlID0gZ2V0RmFjZUZyb21EaXJlY3Rpb24oZGlyZWN0aW9uKTtcXHJcXG5cXHJcXG5cXHRmbG9hdCByY3BQb3dTY2FsZSA9IDEuMCAvIHBvd1NjYWxlO1xcclxcblxcclxcblxcdGlmKCBmYWNlID09IDApIHtcXHJcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueCwgLWRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSk7XFxyXFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigwLjArbWlwT2Zmc2V0LDAuNzUgKiByY3BQb3dTY2FsZSk7XFxyXFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXHJcXG5cXHR9XFxyXFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAxKSB7XFxyXFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueik7XFxyXFxuXFx0XFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNzUgKiByY3BQb3dTY2FsZSk7XFxyXFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXHJcXG5cXHR9XFxyXFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAyKSB7XFxyXFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSk7XFxyXFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigyLjAqc2NhbGUrbWlwT2Zmc2V0LCAwLjc1ICogcmNwUG93U2NhbGUpO1xcclxcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyBhIDogb2Zmc2V0Lnk7XFxyXFxuXFx0fVxcclxcblxcdGVsc2UgaWYoIGZhY2UgPT0gMykge1xcclxcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkpO1xcclxcblxcdFxcdG9mZnNldCA9IHZlYzIoMC4wK21pcE9mZnNldCwwLjUgKiByY3BQb3dTY2FsZSk7XFxyXFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IDAuMCA6IG9mZnNldC55O1xcclxcblxcdH1cXHJcXG5cXHRlbHNlIGlmKCBmYWNlID09IDQpIHtcXHJcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngsIC1kaXJlY3Rpb24ueik7XFxyXFxuXFx0XFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXHJcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxyXFxuXFx0fVxcclxcblxcdGVsc2Uge1xcclxcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi56LCAtZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55KTtcXHJcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDIuMCpzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXHJcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxyXFxuXFx0fVxcclxcblxcdHIgPSBub3JtYWxpemUocik7XFxyXFxuXFx0ZmxvYXQgdGV4ZWxPZmZzZXQgPSAwLjUgKiBjdWJlVVZfcmNwVGV4dHVyZVNpemU7XFxyXFxuXFx0dmVjMiBzID0gKCByLnl6IC8gYWJzKCByLnggKSArIHZlYzIoIDEuMCApICkgKiAwLjU7XFxyXFxuXFx0dmVjMiBiYXNlID0gb2Zmc2V0ICsgdmVjMiggdGV4ZWxPZmZzZXQgKTtcXHJcXG5cXHRyZXR1cm4gYmFzZSArIHMgKiAoIHNjYWxlIC0gMi4wICogdGV4ZWxPZmZzZXQgKTtcXHJcXG59XFxyXFxuXFxyXFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczMgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMy4wKVxcclxcblxcclxcbnZlYzQgdGV4dHVyZUN1YmVVVih2ZWMzIHJlZmxlY3RlZERpcmVjdGlvbiwgZmxvYXQgcm91Z2huZXNzICkge1xcclxcblxcdGZsb2F0IHJvdWdobmVzc1ZhbCA9IHJvdWdobmVzcyogY3ViZVVWX21heExvZHMzO1xcclxcblxcdGZsb2F0IHIxID0gZmxvb3Iocm91Z2huZXNzVmFsKTtcXHJcXG5cXHRmbG9hdCByMiA9IHIxICsgMS4wO1xcclxcblxcdGZsb2F0IHQgPSBmcmFjdChyb3VnaG5lc3NWYWwpO1xcclxcblxcdHZlYzIgbWlwSW5mbyA9IE1pcExldmVsSW5mbyhyZWZsZWN0ZWREaXJlY3Rpb24sIHIxLCByb3VnaG5lc3MpO1xcclxcblxcdGZsb2F0IHMgPSBtaXBJbmZvLnk7XFxyXFxuXFx0ZmxvYXQgbGV2ZWwwID0gbWlwSW5mby54O1xcclxcblxcdGZsb2F0IGxldmVsMSA9IGxldmVsMCArIDEuMDtcXHJcXG5cXHRsZXZlbDEgPSBsZXZlbDEgPiA1LjAgPyA1LjAgOiBsZXZlbDE7XFxyXFxuXFxyXFxuXFx0Ly8gcm91bmQgdG8gbmVhcmVzdCBtaXBtYXAgaWYgd2UgYXJlIG5vdCBpbnRlcnBvbGF0aW5nLlxcclxcblxcdGxldmVsMCArPSBtaW4oIGZsb29yKCBzICsgMC41ICksIDUuMCApO1xcclxcblxcclxcblxcdC8vIFRyaSBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cXHJcXG5cXHR2ZWMyIHV2XzEwID0gZ2V0Q3ViZVVWKHJlZmxlY3RlZERpcmVjdGlvbiwgcjEsIGxldmVsMCk7XFxyXFxuXFx0dmVjNCBjb2xvcjEwID0gZW52TWFwVGV4ZWxUb0xpbmVhcih0ZXh0dXJlMkQoZW52TWFwLCB1dl8xMCkpO1xcclxcblxcclxcblxcdHZlYzIgdXZfMjAgPSBnZXRDdWJlVVYocmVmbGVjdGVkRGlyZWN0aW9uLCByMiwgbGV2ZWwwKTtcXHJcXG5cXHR2ZWM0IGNvbG9yMjAgPSBlbnZNYXBUZXhlbFRvTGluZWFyKHRleHR1cmUyRChlbnZNYXAsIHV2XzIwKSk7XFxyXFxuXFxyXFxuXFx0dmVjNCByZXN1bHQgPSBtaXgoY29sb3IxMCwgY29sb3IyMCwgdCk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIHZlYzQocmVzdWx0LnJnYiwgMS4wKTtcXHJcXG59XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGRlZmF1bHRub3JtYWxfdmVydGV4ID0gXCJ2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcclxcblxcclxcbiNpZmRlZiBGTElQX1NJREVEXFxyXFxuXFxyXFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgPSAtIHRyYW5zZm9ybWVkTm9ybWFsO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcclxcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7XFxyXFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBkaXNwbGFjZW1lbnRtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcclxcblxcclxcblxcdHRyYW5zZm9ybWVkICs9IG5vcm1hbGl6ZSggb2JqZWN0Tm9ybWFsICkgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB1diApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgZW1pc3NpdmVtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXHJcXG5cXHJcXG5cXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXHJcXG5cXHJcXG5cXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGVtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhciggZW1pc3NpdmVDb2xvciApLnJnYjtcXHJcXG5cXHJcXG5cXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgZW5jb2RpbmdzX2ZyYWdtZW50ID0gXCIgIGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xcclxcblwiO1xuXG5cdHZhciBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCA9IFwiLy8gRm9yIGEgZGlzY3Vzc2lvbiBvZiB3aGF0IHRoaXMgaXMsIHBsZWFzZSByZWFkIHRoaXM6IGh0dHA6Ly9sb3Vzb2Ryb21lLm5ldC9ibG9nL2xpZ2h0LzIwMTMvMDUvMjYvZ2FtbWEtY29ycmVjdC1hbmQtaGRyLXJlbmRlcmluZy1pbi1hLTMyLWJpdHMtYnVmZmVyL1xcclxcblxcclxcbnZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxyXFxuXFx0cmV0dXJuIHZhbHVlO1xcclxcbn1cXHJcXG5cXHJcXG52ZWM0IEdhbW1hVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcclxcblxcdHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnh5eiwgdmVjMyggZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS53ICk7XFxyXFxufVxcclxcbnZlYzQgTGluZWFyVG9HYW1tYSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxyXFxuXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCAxLjAgLyBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcXHJcXG59XFxyXFxuXFxyXFxudmVjNCBzUkdCVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxyXFxuXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUudyApO1xcclxcbn1cXHJcXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXHJcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS53ICk7XFxyXFxufVxcclxcblxcclxcbnZlYzQgUkdCRVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcclxcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiBleHAyKCB2YWx1ZS5hICogMjU1LjAgLSAxMjguMCApLCAxLjAgKTtcXHJcXG59XFxyXFxudmVjNCBMaW5lYXJUb1JHQkUoIGluIHZlYzQgdmFsdWUgKSB7XFxyXFxuXFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4KCBtYXgoIHZhbHVlLnIsIHZhbHVlLmcgKSwgdmFsdWUuYiApO1xcclxcblxcdGZsb2F0IGZFeHAgPSBjbGFtcCggY2VpbCggbG9nMiggbWF4Q29tcG9uZW50ICkgKSwgLTEyOC4wLCAxMjcuMCApO1xcclxcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyBleHAyKCBmRXhwICksICggZkV4cCArIDEyOC4wICkgLyAyNTUuMCApO1xcclxcbi8vICByZXR1cm4gdmVjNCggdmFsdWUuYnJnLCAoIDMuMCArIDEyOC4wICkgLyAyNTYuMCApO1xcclxcbn1cXHJcXG5cXHJcXG4vLyByZWZlcmVuY2U6IGh0dHA6Ly9pd2FzYmVpbmdpcm9ueS5ibG9nc3BvdC5jYS8yMDEwLzA2L2RpZmZlcmVuY2UtYmV0d2Vlbi1yZ2JtLWFuZC1yZ2JkLmh0bWxcXHJcXG52ZWM0IFJHQk1Ub0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxyXFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnh5eiAqIHZhbHVlLncgKiBtYXhSYW5nZSwgMS4wICk7XFxyXFxufVxcclxcbnZlYzQgTGluZWFyVG9SR0JNKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXHJcXG5cXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLngsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxyXFxuXFx0ZmxvYXQgTSAgICAgID0gY2xhbXAoIG1heFJHQiAvIG1heFJhbmdlLCAwLjAsIDEuMCApO1xcclxcblxcdE0gICAgICAgICAgICA9IGNlaWwoIE0gKiAyNTUuMCApIC8gMjU1LjA7XFxyXFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAvICggTSAqIG1heFJhbmdlICksIE0gKTtcXHJcXG59XFxyXFxuXFxyXFxuLy8gcmVmZXJlbmNlOiBodHRwOi8vaXdhc2JlaW5naXJvbnkuYmxvZ3Nwb3QuY2EvMjAxMC8wNi9kaWZmZXJlbmNlLWJldHdlZW4tcmdibS1hbmQtcmdiZC5odG1sXFxyXFxudmVjNCBSR0JEVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcclxcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoICggbWF4UmFuZ2UgLyAyNTUuMCApIC8gdmFsdWUuYSApLCAxLjAgKTtcXHJcXG59XFxyXFxudmVjNCBMaW5lYXJUb1JHQkQoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcclxcblxcdGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUueCwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXHJcXG5cXHRmbG9hdCBEICAgICAgPSBtYXgoIG1heFJhbmdlIC8gbWF4UkdCLCAxLjAgKTtcXHJcXG5cXHREICAgICAgICAgICAgPSBtaW4oIGZsb29yKCBEICkgLyAyNTUuMCwgMS4wICk7XFxyXFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggRCAqICggMjU1LjAgLyBtYXhSYW5nZSApICksIEQgKTtcXHJcXG59XFxyXFxuXFxyXFxuLy8gTG9nTHV2IHJlZmVyZW5jZTogaHR0cDovL2dyYXBoaWNyYW50cy5ibG9nc3BvdC5jYS8yMDA5LzA0L3JnYm0tY29sb3ItZW5jb2RpbmcuaHRtbFxcclxcblxcclxcbi8vIE0gbWF0cml4LCBmb3IgZW5jb2RpbmdcXHJcXG5jb25zdCBtYXQzIGNMb2dMdXZNID0gbWF0MyggMC4yMjA5LCAwLjMzOTAsIDAuNDE4NCwgMC4xMTM4LCAwLjY3ODAsIDAuNzMxOSwgMC4wMTAyLCAwLjExMzAsIDAuMjk2OSApO1xcclxcbnZlYzQgTGluZWFyVG9Mb2dMdXYoIGluIHZlYzQgdmFsdWUgKSAge1xcclxcblxcdHZlYzMgWHBfWV9YWVpwID0gdmFsdWUucmdiICogY0xvZ0x1dk07XFxyXFxuXFx0WHBfWV9YWVpwID0gbWF4KFhwX1lfWFlacCwgdmVjMygxZS02LCAxZS02LCAxZS02KSk7XFxyXFxuXFx0dmVjNCB2UmVzdWx0O1xcclxcblxcdHZSZXN1bHQueHkgPSBYcF9ZX1hZWnAueHkgLyBYcF9ZX1hZWnAuejtcXHJcXG5cXHRmbG9hdCBMZSA9IDIuMCAqIGxvZzIoWHBfWV9YWVpwLnkpICsgMTI3LjA7XFxyXFxuXFx0dlJlc3VsdC53ID0gZnJhY3QoTGUpO1xcclxcblxcdHZSZXN1bHQueiA9IChMZSAtIChmbG9vcih2UmVzdWx0LncqMjU1LjApKS8yNTUuMCkvMjU1LjA7XFxyXFxuXFx0cmV0dXJuIHZSZXN1bHQ7XFxyXFxufVxcclxcblxcclxcbi8vIEludmVyc2UgTSBtYXRyaXgsIGZvciBkZWNvZGluZ1xcclxcbmNvbnN0IG1hdDMgY0xvZ0x1dkludmVyc2VNID0gbWF0MyggNi4wMDE0LCAtMi43MDA4LCAtMS43OTk2LCAtMS4zMzIwLCAzLjEwMjksIC01Ljc3MjEsIDAuMzAwOCwgLTEuMDg4MiwgNS42MjY4ICk7XFxyXFxudmVjNCBMb2dMdXZUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXHJcXG5cXHRmbG9hdCBMZSA9IHZhbHVlLnogKiAyNTUuMCArIHZhbHVlLnc7XFxyXFxuXFx0dmVjMyBYcF9ZX1hZWnA7XFxyXFxuXFx0WHBfWV9YWVpwLnkgPSBleHAyKChMZSAtIDEyNy4wKSAvIDIuMCk7XFxyXFxuXFx0WHBfWV9YWVpwLnogPSBYcF9ZX1hZWnAueSAvIHZhbHVlLnk7XFxyXFxuXFx0WHBfWV9YWVpwLnggPSB2YWx1ZS54ICogWHBfWV9YWVpwLno7XFxyXFxuXFx0dmVjMyB2UkdCID0gWHBfWV9YWVpwLnJnYiAqIGNMb2dMdXZJbnZlcnNlTTtcXHJcXG5cXHRyZXR1cm4gdmVjNCggbWF4KHZSR0IsIDAuMCksIDEuMCApO1xcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgZW52bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcclxcblxcclxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxyXFxuXFxyXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcclxcblxcclxcblxcdFxcdC8vIFRyYW5zZm9ybWluZyBOb3JtYWwgVmVjdG9ycyB3aXRoIHRoZSBJbnZlcnNlIFRyYW5zZm9ybWF0aW9uXFxyXFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxyXFxuXFxyXFxuXFx0XFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcclxcblxcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXHJcXG5cXHJcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxyXFxuXFxyXFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxyXFxuXFxyXFxuXFx0XFx0dmVjMiBzYW1wbGVVVjtcXHJcXG5cXHJcXG5cXHRcXHRyZWZsZWN0VmVjID0gbm9ybWFsaXplKCByZWZsZWN0VmVjICk7XFxyXFxuXFxyXFxuXFx0XFx0c2FtcGxlVVYueSA9IGFzaW4oIGNsYW1wKCByZWZsZWN0VmVjLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXHJcXG5cXHJcXG5cXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggcmVmbGVjdFZlYy56LCByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcclxcblxcclxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXHJcXG5cXHJcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcclxcblxcclxcblxcdFxcdHJlZmxlY3RWZWMgPSBub3JtYWxpemUoIHJlZmxlY3RWZWMgKTtcXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWaWV3ID0gbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSApLnh5eiArIHZlYzMoIDAuMCwgMC4wLCAxLjAgKSApO1xcclxcblxcclxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRlbnZDb2xvciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudkNvbG9yICk7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxcclxcblxcclxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXHJcXG5cXHJcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXHJcXG5cXHJcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXHJcXG5cXHJcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXHJcXG5cXHJcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGVudm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIWVNJQ0FMIClcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWZkZWYgVVNFX0VOVk1BUFxcclxcblxcclxcblxcdCNpZiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgKCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIClcXHJcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXHJcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXHJcXG5cXHQjZWxzZVxcclxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxyXFxuXFxyXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggUEhZU0lDQUwgKVxcclxcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcclxcblxcdCNlbHNlXFxyXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcclxcblxcdCNlbmRpZlxcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBlbnZtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxyXFxuXFxyXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXHJcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxyXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGVudm1hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxyXFxuXFxyXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXHJcXG5cXHJcXG5cXHRcXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcclxcblxcclxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxyXFxuXFxyXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHQjZWxzZVxcclxcblxcclxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgZm9nX3ZlcnRleCA9IFwiXFxyXFxuI2lmZGVmIFVTRV9GT0dcXHJcXG5mb2dEZXB0aCA9IC1tdlBvc2l0aW9uLno7XFxyXFxuI2VuZGlmXCI7XG5cblx0dmFyIGZvZ19wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9GT0dcXHJcXG5cXHJcXG4gIHZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGZvZ19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXHJcXG5cXHJcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBmb2dEZXB0aCAqIGZvZ0RlcHRoICogTE9HMiApICk7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGZvZ0RlcHRoICk7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBmb2dfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxyXFxuXFx0dmFyeWluZyBmbG9hdCBmb2dEZXB0aDtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXHJcXG5cXHJcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxyXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBUT09OXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnRNYXA7XFxyXFxuXFxyXFxuXFx0dmVjMyBnZXRHcmFkaWVudElycmFkaWFuY2UoIHZlYzMgbm9ybWFsLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uICkge1xcclxcblxcclxcblxcdFxcdC8vIGRvdE5MIHdpbGwgYmUgZnJvbSAtMS4wIHRvIDEuMFxcclxcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7XFxyXFxuXFx0XFx0dmVjMiBjb29yZCA9IHZlYzIoIGRvdE5MICogMC41ICsgMC41LCAwLjAgKTtcXHJcXG5cXHJcXG5cXHRcXHQjaWZkZWYgVVNFX0dSQURJRU5UTUFQXFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRCggZ3JhZGllbnRNYXAsIGNvb3JkICkucmdiO1xcclxcblxcclxcblxcdFxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0cmV0dXJuICggY29vcmQueCA8IDAuNyApID8gdmVjMyggMC43ICkgOiB2ZWMzKCAxLjAgKTtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGxpZ2h0bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxyXFxuXFxyXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IFBJICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5OyAvLyBmYWN0b3Igb2YgUEkgc2hvdWxkIG5vdCBiZSBwcmVzZW50OyBpbmNsdWRlZCBoZXJlIHRvIHByZXZlbnQgYnJlYWthZ2VcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcclxcblxcclxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcclxcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxyXFxuXFxyXFxuI2VuZGlmXCI7XG5cblx0dmFyIGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCA9IFwidmVjMyBkaWZmdXNlID0gdmVjMyggMS4wICk7XFxyXFxuXFxyXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXHJcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xcclxcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXHJcXG5nZW9tZXRyeS52aWV3RGlyID0gbm9ybWFsaXplKCAtbXZQb3NpdGlvbi54eXogKTtcXHJcXG5cXHJcXG5HZW9tZXRyaWNDb250ZXh0IGJhY2tHZW9tZXRyeTtcXHJcXG5iYWNrR2VvbWV0cnkucG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXHJcXG5iYWNrR2VvbWV0cnkubm9ybWFsID0gLWdlb21ldHJ5Lm5vcm1hbDtcXHJcXG5iYWNrR2VvbWV0cnkudmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxyXFxuXFxyXFxudkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXHJcXG5cXHJcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxyXFxuXFx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcclxcbiNlbmRpZlxcclxcblxcclxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxyXFxuZmxvYXQgZG90Tkw7XFxyXFxudmVjMyBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxyXFxuXFxyXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcFxcclxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Z2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIHBvaW50TGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcclxcblxcclxcblxcdFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcclxcblxcdFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxyXFxuXFxyXFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxyXFxuXFxyXFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcclxcblxcclxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcclxcblxcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcclxcblxcclxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BcXHJcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Z2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXHJcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcclxcblxcclxcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXHJcXG5cXHJcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcclxcblxcclxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BcXHJcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggZGlyZWN0aW9uYWxMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxyXFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXHJcXG5cXHJcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXHJcXG5cXHJcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxyXFxuXFxyXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxyXFxuXFxyXFxuXFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcFxcclxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxyXFxuXFxyXFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcclxcblxcclxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBiYWNrR2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGxpZ2h0c19wYXJzID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxyXFxuXFxyXFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcclxcblxcclxcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xcclxcblxcclxcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcclxcblxcclxcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxyXFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxyXFxuXFx0XFx0dmVjMyBjb2xvcjtcXHJcXG5cXHJcXG5cXHRcXHRpbnQgc2hhZG93O1xcclxcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxyXFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcclxcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXHJcXG5cXHR9O1xcclxcblxcclxcblxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTtcXHJcXG5cXHJcXG5cXHR2b2lkIGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcclxcblxcclxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXHJcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcXHJcXG5cXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuXFxyXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0c3RydWN0IFBvaW50TGlnaHQge1xcclxcblxcdFxcdHZlYzMgcG9zaXRpb247XFxyXFxuXFx0XFx0dmVjMyBjb2xvcjtcXHJcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXHJcXG5cXHRcXHRmbG9hdCBkZWNheTtcXHJcXG5cXHJcXG5cXHRcXHRpbnQgc2hhZG93O1xcclxcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxyXFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcclxcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXHJcXG5cXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFOZWFyO1xcclxcblxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcXHJcXG5cXHR9O1xcclxcblxcclxcblxcdHVuaWZvcm0gUG9pbnRMaWdodCBwb2ludExpZ2h0c1sgTlVNX1BPSU5UX0xJR0hUUyBdO1xcclxcblxcclxcblxcdC8vIGRpcmVjdExpZ2h0IGlzIGFuIG91dCBwYXJhbWV0ZXIgYXMgaGF2aW5nIGl0IGFzIGEgcmV0dXJuIHZhbHVlIGNhdXNlZCBjb21waWxlciBlcnJvcnMgb24gc29tZSBkZXZpY2VzXFxyXFxuXFx0dm9pZCBnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gUG9pbnRMaWdodCBwb2ludExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxyXFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcclxcblxcclxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gcG9pbnRMaWdodC5jb2xvcjtcXHJcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlLCBwb2ludExpZ2h0LmRlY2F5ICk7XFxyXFxuXFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9ICggZGlyZWN0TGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuXFxyXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHRzdHJ1Y3QgU3BvdExpZ2h0IHtcXHJcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcclxcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcclxcblxcdFxcdHZlYzMgY29sb3I7XFxyXFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxyXFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxyXFxuXFx0XFx0ZmxvYXQgY29uZUNvcztcXHJcXG5cXHRcXHRmbG9hdCBwZW51bWJyYUNvcztcXHJcXG5cXHJcXG5cXHRcXHRpbnQgc2hhZG93O1xcclxcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxyXFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcclxcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXHJcXG5cXHR9O1xcclxcblxcclxcblxcdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcclxcblxcclxcblxcdC8vIGRpcmVjdExpZ2h0IGlzIGFuIG91dCBwYXJhbWV0ZXIgYXMgaGF2aW5nIGl0IGFzIGEgcmV0dXJuIHZhbHVlIGNhdXNlZCBjb21waWxlciBlcnJvcnMgb24gc29tZSBkZXZpY2VzXFxyXFxuXFx0dm9pZCBnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCAgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gc3BvdExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxyXFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcclxcblxcdFxcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIGFuZ2xlQ29zID4gc3BvdExpZ2h0LmNvbmVDb3MgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZmxvYXQgc3BvdEVmZmVjdCA9IHNtb290aHN0ZXAoIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3I7XFxyXFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gc3BvdEVmZmVjdCAqIHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7XFxyXFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcclxcblxcdFxcdFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSBmYWxzZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcblxcclxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHRzdHJ1Y3QgUmVjdEFyZWFMaWdodCB7XFxyXFxuXFx0XFx0dmVjMyBjb2xvcjtcXHJcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcclxcblxcdFxcdHZlYzMgaGFsZldpZHRoO1xcclxcblxcdFxcdHZlYzMgaGFsZkhlaWdodDtcXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8vIFByZS1jb21wdXRlZCB2YWx1ZXMgb2YgTGluZWFyVHJhbnNmb3JtZWRDb3NpbmUgYXBwcm94aW1hdGlvbiBvZiBCUkRGXFxyXFxuXFx0Ly8gQlJERiBhcHByb3hpbWF0aW9uIFRleHR1cmUgaXMgNjR4NjRcXHJcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMTsgLy8gUkdCQSBGbG9hdFxcclxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y18yOyAvLyBSR0JBIEZsb2F0XFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHRzWyBOVU1fUkVDVF9BUkVBX0xJR0hUUyBdO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcblxcclxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxyXFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxyXFxuXFx0XFx0dmVjMyBza3lDb2xvcjtcXHJcXG5cXHRcXHR2ZWMzIGdyb3VuZENvbG9yO1xcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XFxyXFxuXFxyXFxuXFx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcclxcblxcclxcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTtcXHJcXG5cXHRcXHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xcclxcblxcclxcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxyXFxuXFxyXFxuXFx0XFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuXFxyXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApXFxyXFxuXFxyXFxuXFx0dmVjMyBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGdlb21ldHJ5Lm5vcm1hbCwgdmlld01hdHJpeCApO1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcclxcblxcclxcblxcdFxcdFxcdC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBwcm9wZXJseSBmaWx0ZXJlZCBjdWJlbWFwcyBhbmQgYWNjZXNzIHRoZSBpcnJhZGlhbmNlIExPRCBsZXZlbCwgYmUgaXQgdGhlIGxhc3QgTE9EIGxldmVsXFxyXFxuXFx0XFx0XFx0Ly8gb2YgYSBzcGVjdWxhciBjdWJlbWFwLCBvciBqdXN0IHRoZSBkZWZhdWx0IGxldmVsIG9mIGEgc3BlY2lhbGx5IGNyZWF0ZWQgaXJyYWRpYW5jZSBjdWJlbWFwLlxcclxcblxcclxcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQvLyBmb3JjZSB0aGUgYmlhcyBoaWdoIHRvIGdldCB0aGUgbGFzdCBMT0QgbGV2ZWwgYXMgaXQgaXMgdGhlIG1vc3QgYmx1cnJlZC5cXHJcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0XFx0XFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxyXFxuXFxyXFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcclxcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBxdWVyeVZlYywgMS4wICk7XFxyXFxuXFxyXFxuXFx0XFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdmVjNCggMC4wICk7XFxyXFxuXFxyXFxuXFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyB0YWtlbiBmcm9tIGhlcmU6IGh0dHA6Ly9jYXN1YWwtZWZmZWN0cy5ibG9nc3BvdC5jYS8yMDExLzA4L3BsYXVzaWJsZS1lbnZpcm9ubWVudC1saWdodGluZy1pbi10d28uaHRtbFxcclxcblxcdGZsb2F0IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXHJcXG5cXHJcXG5cXHRcXHQvL2Zsb2F0IGVudk1hcFdpZHRoID0gcG93KCAyLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxyXFxuXFx0XFx0Ly9mbG9hdCBkZXNpcmVkTUlQTGV2ZWwgPSBsb2cyKCBlbnZNYXBXaWR0aCAqIHNxcnQoIDMuMCApICkgLSAwLjUgKiBsb2cyKCBwb3cyKCBibGlublNoaW5pbmVzc0V4cG9uZW50ICkgKyAxLjAgKTtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBtYXhNSVBMZXZlbFNjYWxhciA9IGZsb2F0KCBtYXhNSVBMZXZlbCApO1xcclxcblxcdFxcdGZsb2F0IGRlc2lyZWRNSVBMZXZlbCA9IG1heE1JUExldmVsU2NhbGFyICsgMC43OTI0OCAtIDAuNSAqIGxvZzIoIHBvdzIoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQgKSArIDEuMCApO1xcclxcblxcclxcblxcdFxcdC8vIGNsYW1wIHRvIGFsbG93YWJsZSBMT0QgcmFuZ2VzLlxcclxcblxcdFxcdHJldHVybiBjbGFtcCggZGVzaXJlZE1JUExldmVsLCAwLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdHZlYzMgZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXHJcXG5cXHJcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcclxcblxcclxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwgKTtcXHJcXG5cXHJcXG5cXHRcXHQjZWxzZVxcclxcblxcclxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcclxcblxcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdFxcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJNSVBMZXZlbCA9IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIG1heE1JUExldmVsICk7XFxyXFxuXFxyXFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5UmVmbGVjdFZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlTG9kRVhUKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcclxcblxcclxcblxcdFxcdFxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcclxcblxcclxcblxcdFxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcclxcblxcclxcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcclxcblxcclxcblxcdFxcdFxcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApO1xcclxcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKHF1ZXJ5UmVmbGVjdFZlYywgQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKGJsaW5uU2hpbmluZXNzRXhwb25lbnQpKTtcXHJcXG5cXHJcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWMyIHNhbXBsZVVWO1xcclxcblxcdFxcdFxcdHNhbXBsZVVWLnkgPSBhc2luKCBjbGFtcCggcmVmbGVjdFZlYy55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7XFxyXFxuXFx0XFx0XFx0c2FtcGxlVVYueCA9IGF0YW4oIHJlZmxlY3RWZWMueiwgcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcclxcblxcclxcblxcdFxcdFxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcclxcblxcclxcblxcdFxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcclxcblxcclxcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IG5vcm1hbGl6ZSggKCB2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkgKS54eXogKyB2ZWMzKCAwLjAsMC4wLDEuMCApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQjZWxzZVxcclxcblxcclxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgbGlnaHRzX3Bob25nX2ZyYWdtZW50ID0gXCJCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7XFxyXFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcXHJcXG5tYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gc3BlY3VsYXI7XFxyXFxubWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7XFxyXFxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XFxyXFxuXCI7XG5cblx0dmFyIGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXHJcXG5cXHJcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxyXFxuXFxyXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuXFxyXFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxyXFxuXFxyXFxuXFx0dmVjM1xcdGRpZmZ1c2VDb2xvcjtcXHJcXG5cXHR2ZWMzXFx0c3BlY3VsYXJDb2xvcjtcXHJcXG5cXHRmbG9hdFxcdHNwZWN1bGFyU2hpbmluZXNzO1xcclxcblxcdGZsb2F0XFx0c3BlY3VsYXJTdHJlbmd0aDtcXHJcXG5cXHJcXG59O1xcclxcblxcclxcbnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFRPT05cXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcclxcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxyXFxuXFxyXFxuXFx0XFx0aXJyYWRpYW5jZSAqPSBQSTsgLy8gcHVuY3R1YWwgbGlnaHRcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxyXFxuXFxyXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApICogbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcclxcblxcclxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9CbGlublBob25nXFxyXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZ1xcclxcblxcclxcbiNkZWZpbmUgTWF0ZXJpYWxfTGlnaHRQcm9iZUxPRCggbWF0ZXJpYWwgKVxcdCgwKVxcclxcblwiO1xuXG5cdHZhciBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQgPSBcIlBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XFxyXFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7XFxyXFxubWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgPSBjbGFtcCggcm91Z2huZXNzRmFjdG9yLCAwLjA0LCAxLjAgKTtcXHJcXG4jaWZkZWYgU1RBTkRBUkRcXHJcXG5cXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcclxcbiNlbHNlXFxyXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAqIHBvdzIoIHJlZmxlY3Rpdml0eSApICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcclxcblxcdG1hdGVyaWFsLmNsZWFyQ29hdCA9IHNhdHVyYXRlKCBjbGVhckNvYXQgKTsgLy8gQnVybGV5IGNsZWFyY29hdCBtb2RlbFxcclxcblxcdG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyA9IGNsYW1wKCBjbGVhckNvYXRSb3VnaG5lc3MsIDAuMDQsIDEuMCApO1xcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcclxcblxcclxcblxcdHZlYzNcXHRkaWZmdXNlQ29sb3I7XFxyXFxuXFx0ZmxvYXRcXHRzcGVjdWxhclJvdWdobmVzcztcXHJcXG5cXHR2ZWMzXFx0c3BlY3VsYXJDb2xvcjtcXHJcXG5cXHJcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxyXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0O1xcclxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG59O1xcclxcblxcclxcbiNkZWZpbmUgTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjE2XFxyXFxuI2RlZmluZSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UIDAuMDRcXHJcXG5cXHJcXG4vLyBDbGVhciBjb2F0IGRpcmVjdGlvbmFsIGhlbWlzaHBlcmljYWwgcmVmbGVjdGFuY2UgKHRoaXMgYXBwcm94aW1hdGlvbiBzaG91bGQgYmUgaW1wcm92ZWQpXFxyXFxuZmxvYXQgY2xlYXJDb2F0REhSQXBwcm94KCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5MICkge1xcclxcblxcclxcblxcdHJldHVybiBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICsgKCAxLjAgLSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICkgKiAoIHBvdyggMS4wIC0gZG90TkwsIDUuMCApICogcG93KCAxLjAgLSByb3VnaG5lc3MsIDIuMCApICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Lm5vcm1hbDtcXHJcXG5cXHRcXHR2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcclxcblxcdFxcdHZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXHJcXG5cXHRcXHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcXHJcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoO1xcclxcblxcdFxcdHZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDtcXHJcXG5cXHRcXHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcclxcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzO1xcclxcblxcclxcblxcdFxcdHZlYzMgcmVjdENvb3Jkc1sgNCBdO1xcclxcblxcdFxcdHJlY3RDb29yZHNbIDAgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDsgLy8gY291bnRlcmNsb2Nrd2lzZVxcclxcblxcdFxcdHJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zICsgaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXHJcXG5cXHRcXHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxyXFxuXFx0XFx0cmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xcclxcblxcclxcblxcdFxcdHZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxyXFxuXFxyXFxuXFx0XFx0dmVjNCB0MSA9IHRleHR1cmUyRCggbHRjXzEsIHV2ICk7XFxyXFxuXFx0XFx0dmVjNCB0MiA9IHRleHR1cmUyRCggbHRjXzIsIHV2ICk7XFxyXFxuXFxyXFxuXFx0XFx0bWF0MyBtSW52ID0gbWF0MyhcXHJcXG5cXHRcXHRcXHR2ZWMzKCB0MS54LCAwLCB0MS55ICksXFxyXFxuXFx0XFx0XFx0dmVjMyggICAgMCwgMSwgICAgMCApLFxcclxcblxcdFxcdFxcdHZlYzMoIHQxLnosIDAsIHQxLncgKVxcclxcblxcdFxcdCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gTFRDIEZyZXNuZWwgQXBwcm94aW1hdGlvbiBieSBTdGVwaGVuIEhpbGxcXHJcXG5cXHRcXHQvLyBodHRwOi8vYmxvZy5zZWxmc2hhZG93LmNvbS9wdWJsaWNhdGlvbnMvczIwMTYtYWR2YW5jZXMvczIwMTZfbHRjX2ZyZXNuZWwucGRmXFxyXFxuXFx0XFx0dmVjMyBmcmVzbmVsID0gKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogdDIueCArICggdmVjMyggMS4wICkgLSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICkgKiB0Mi55ICk7XFxyXFxuXFxyXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIGZyZXNuZWwgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTtcXHJcXG5cXHJcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEuMCApLCByZWN0Q29vcmRzICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXHJcXG5cXHJcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXHJcXG5cXHJcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcclxcblxcclxcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcclxcblxcclxcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7IC8vIHB1bmN0dWFsIGxpZ2h0XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcclxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IG1hdGVyaWFsLmNsZWFyQ29hdCAqIGNsZWFyQ29hdERIUkFwcHJveCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzLCBkb3ROTCApO1xcclxcblxcdCNlbHNlXFxyXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gMC4wO1xcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXHJcXG5cXHJcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcclxcblxcclxcblxcdCNpZm5kZWYgU1RBTkRBUkRcXHJcXG5cXHJcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogbWF0ZXJpYWwuY2xlYXJDb2F0ICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZvaWQgUkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhckNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxyXFxuXFxyXFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcclxcblxcdFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXHJcXG5cXHRcXHRmbG9hdCBkb3ROTCA9IGRvdE5WO1xcclxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IG1hdGVyaWFsLmNsZWFyQ29hdCAqIGNsZWFyQ29hdERIUkFwcHJveCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzLCBkb3ROTCApO1xcclxcblxcdCNlbHNlXFxyXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gMC4wO1xcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIHJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcclxcblxcclxcblxcdCNpZm5kZWYgU1RBTkRBUkRcXHJcXG5cXHJcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IGNsZWFyQ29hdFJhZGlhbmNlICogbWF0ZXJpYWwuY2xlYXJDb2F0ICogQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGdlb21ldHJ5LCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcbn1cXHJcXG5cXHJcXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9QaHlzaWNhbFxcclxcbiNkZWZpbmUgUkVfRGlyZWN0X1JlY3RBcmVhXFx0XFx0UkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsXFxyXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWxcXHJcXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcXHRcXHRSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsXFxyXFxuXFxyXFxuI2RlZmluZSBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApXFxyXFxuI2RlZmluZSBNYXRlcmlhbF9DbGVhckNvYXRfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSAgIEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzIClcXHJcXG5cXHJcXG4vLyByZWY6IGh0dHBzOi8vc2VibGFnYXJkZS5maWxlcy53b3JkcHJlc3MuY29tLzIwMTUvMDcvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyX3YzMi5wZGZcXHJcXG5mbG9hdCBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGNvbnN0IGluIGZsb2F0IGRvdE5WLCBjb25zdCBpbiBmbG9hdCBhbWJpZW50T2NjbHVzaW9uLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBwb3coIGRvdE5WICsgYW1iaWVudE9jY2x1c2lvbiwgZXhwMiggLSAxNi4wICogcm91Z2huZXNzIC0gMS4wICkgKSAtIDEuMCArIGFtYmllbnRPY2NsdXNpb24gKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIGxpZ2h0c190ZW1wbGF0ZSA9IFwiXFxyXFxuXFxyXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXHJcXG5cXHJcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjtcXHJcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XFxyXFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcclxcblxcclxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxyXFxuXFxyXFxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcclxcblxcclxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXHJcXG5cXHJcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wXFxyXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXHJcXG5cXHJcXG5cXHRcXHRnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggcG9pbnRMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXHJcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBwb2ludExpZ2h0LnNoYWRvdywgZGlyZWN0TGlnaHQudmlzaWJsZSApICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7XFxyXFxuXFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWYgKCBOVU1fU1BPVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXHJcXG5cXHJcXG5cXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcclxcblxcclxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BcXHJcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcclxcblxcclxcblxcdFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0XFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXHJcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBzcG90TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXHJcXG5cXHJcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxyXFxuXFxyXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcFxcclxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcclxcblxcclxcblxcdFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXHJcXG5cXHJcXG5cXHRcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcclxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxyXFxuXFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKVxcclxcblxcclxcblxcdFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodDtcXHJcXG5cXHJcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wXFxyXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1JFQ1RfQVJFQV9MSUdIVFM7IGkgKysgKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmVjdEFyZWFMaWdodCA9IHJlY3RBcmVhTGlnaHRzWyBpIF07XFxyXFxuXFx0XFx0UkVfRGlyZWN0X1JlY3RBcmVhKCByZWN0QXJlYUxpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcclxcblxcclxcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcclxcblxcclxcblxcdFxcdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcclxcblxcclxcblxcdFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcclxcblxcclxcblxcdFxcdFxcdGxpZ2h0TWFwSXJyYWRpYW5jZSAqPSBQSTsgLy8gZmFjdG9yIG9mIFBJIHNob3VsZCBub3QgYmUgcHJlc2VudDsgaW5jbHVkZWQgaGVyZSB0byBwcmV2ZW50IGJyZWFrYWdlXFxyXFxuXFxyXFxuXFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0XFx0aXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApXFxyXFxuXFxyXFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcFxcclxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpcnJhZGlhbmNlICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApICYmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcclxcblxcclxcblxcdFxcdC8vIFRPRE8sIHJlcGxhY2UgOCB3aXRoIHRoZSByZWFsIG1heE1JUExldmVsXFxyXFxuXFx0XFx0aXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBnZW9tZXRyeSwgOCApO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxyXFxuXFxyXFxuXFx0Ly8gVE9ETywgcmVwbGFjZSA4IHdpdGggdGhlIHJlYWwgbWF4TUlQTGV2ZWxcXHJcXG5cXHR2ZWMzIHJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LCBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApLCA4ICk7XFxyXFxuXFxyXFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcclxcblxcdFxcdHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UgPSBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggZ2VvbWV0cnksIE1hdGVyaWFsX0NsZWFyQ29hdF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApLCA4ICk7XFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHRcXHR2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0UkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGNsZWFyQ29hdFJhZGlhbmNlLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGxvZ2RlcHRoYnVmX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGICkgJiYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGX0VYVCApXFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0RlcHRoRVhUID0gbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXHJcXG5cXHJcXG4jZW5kaWZcIjtcblxuXHR2YXIgbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXHJcXG5cXHJcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcclxcblxcclxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXHJcXG5cXHJcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcclxcblxcclxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxyXFxuXFxyXFxuI2VuZGlmXCI7XG5cblx0dmFyIGxvZ2RlcHRoYnVmX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcclxcblxcclxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxyXFxuXFxyXFxuXFx0XFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRnbF9Qb3NpdGlvbi56ID0gbG9nMiggbWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkgKSAqIGxvZ0RlcHRoQnVmRkMgLSAxLjA7XFxyXFxuXFxyXFxuXFx0XFx0Z2xfUG9zaXRpb24ueiAqPSBnbF9Qb3NpdGlvbi53O1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxyXFxuXFxyXFxuXFx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcclxcblxcclxcblxcdHRleGVsQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhlbENvbG9yICk7XFxyXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcclxcblxcclxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgbWFwX3BhcnRpY2xlX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcclxcblxcclxcblxcdHZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5O1xcclxcblxcdHZlYzQgbWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKTtcXHJcXG5cXHRkaWZmdXNlQ29sb3IgKj0gbWFwVGV4ZWxUb0xpbmVhciggbWFwVGV4ZWwgKTtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcclxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgbWV0YWxuZXNzbWFwX2ZyYWdtZW50ID0gXCJmbG9hdCBtZXRhbG5lc3NGYWN0b3IgPSBtZXRhbG5lc3M7XFxyXFxuXFxyXFxuI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXHJcXG5cXHJcXG5cXHR2ZWM0IHRleGVsTWV0YWxuZXNzID0gdGV4dHVyZTJEKCBtZXRhbG5lc3NNYXAsIHZVdiApO1xcclxcblxcclxcblxcdC8vIHJlYWRzIGNoYW5uZWwgQiwgY29tcGF0aWJsZSB3aXRoIGEgY29tYmluZWQgT2NjbHVzaW9uUm91Z2huZXNzTWV0YWxsaWMgKFJHQikgdGV4dHVyZVxcclxcblxcdG1ldGFsbmVzc0ZhY3RvciAqPSB0ZXhlbE1ldGFsbmVzcy5iO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxyXFxuXFxyXFxuI2VuZGlmXCI7XG5cblx0dmFyIG1vcnBobm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXHJcXG5cXHJcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcclxcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxyXFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXHJcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXHJcXG5cXHJcXG5cXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG4jZW5kaWZcIjtcblxuXHR2YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcclxcblxcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcclxcblxcclxcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcclxcblxcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcclxcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBub3JtYWxfZnJhZ21lbnQgPSBcIiNpZmRlZiBGTEFUX1NIQURFRFxcclxcblxcclxcblxcdC8vIFdvcmthcm91bmQgZm9yIEFkcmVuby9OZXh1czUgbm90IGFibGUgYWJsZSB0byBkbyBkRmR4KCB2Vmlld1Bvc2l0aW9uICkgLi4uXFxyXFxuXFxyXFxuXFx0dmVjMyBmZHggPSB2ZWMzKCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeCggdlZpZXdQb3NpdGlvbi55ICksIGRGZHgoIHZWaWV3UG9zaXRpb24ueiApICk7XFxyXFxuXFx0dmVjMyBmZHkgPSB2ZWMzKCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeSggdlZpZXdQb3NpdGlvbi55ICksIGRGZHkoIHZWaWV3UG9zaXRpb24ueiApICk7XFxyXFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBmZHgsIGZkeSApICk7XFxyXFxuXFxyXFxuI2Vsc2VcXHJcXG5cXHJcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcclxcblxcclxcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXHJcXG5cXHJcXG5cXHRcXHRub3JtYWwgPSBub3JtYWwgKiAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXHJcXG5cXHJcXG5cXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCApO1xcclxcblxcclxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXHJcXG5cXHJcXG5cXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBub3JtYWxtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxyXFxuXFx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcclxcblxcclxcblxcdC8vIFBlci1QaXhlbCBUYW5nZW50IFNwYWNlIE5vcm1hbCBNYXBwaW5nXFxyXFxuXFx0Ly8gaHR0cDovL2hhY2tzb2ZsaWZlLmJsb2dzcG90LmNoLzIwMDkvMTEvcGVyLXBpeGVsLXRhbmdlbnQtc3BhY2Utbm9ybWFsLW1hcHBpbmcuaHRtbFxcclxcblxcclxcblxcdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gV29ya2Fyb3VuZCBmb3IgQWRyZW5vIDNYWCBkRmQqKCB2ZWMzICkgYnVnLiBTZWUgIzk5ODhcXHJcXG5cXHJcXG5cXHRcXHR2ZWMzIHEwID0gdmVjMyggZEZkeCggZXllX3Bvcy54ICksIGRGZHgoIGV5ZV9wb3MueSApLCBkRmR4KCBleWVfcG9zLnogKSApO1xcclxcblxcdFxcdHZlYzMgcTEgPSB2ZWMzKCBkRmR5KCBleWVfcG9zLnggKSwgZEZkeSggZXllX3Bvcy55ICksIGRGZHkoIGV5ZV9wb3MueiApICk7XFxyXFxuXFx0XFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXHJcXG5cXHRcXHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcclxcblxcclxcblxcdFxcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXHJcXG5cXHRcXHR2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1xcclxcblxcdFxcdHZlYzMgTiA9IG5vcm1hbGl6ZSggc3VyZl9ub3JtICk7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXHJcXG5cXHRcXHRtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1xcclxcblxcdFxcdG1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1xcclxcblxcdFxcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIHBhY2tpbmcgPSBcInZlYzMgcGFja05vcm1hbFRvUkdCKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXHJcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCBub3JtYWwgKSAqIDAuNSArIDAuNTtcXHJcXG59XFxyXFxuXFxyXFxudmVjMyB1bnBhY2tSR0JUb05vcm1hbCggY29uc3QgaW4gdmVjMyByZ2IgKSB7XFxyXFxuXFx0cmV0dXJuIDIuMCAqIHJnYi54eXogLSAxLjA7XFxyXFxufVxcclxcblxcclxcbmNvbnN0IGZsb2F0IFBhY2tVcHNjYWxlID0gMjU2LiAvIDI1NS47IC8vIGZyYWN0aW9uIC0+IDAuLjEgKGluY2x1ZGluZyAxKVxcclxcbmNvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuOyAvLyAwLi4xIC0+IGZyYWN0aW9uIChleGNsdWRpbmcgMSlcXHJcXG5cXHJcXG5jb25zdCB2ZWMzIFBhY2tGYWN0b3JzID0gdmVjMyggMjU2LiAqIDI1Ni4gKiAyNTYuLCAyNTYuICogMjU2LiwgIDI1Ni4gKTtcXHJcXG5jb25zdCB2ZWM0IFVucGFja0ZhY3RvcnMgPSBVbnBhY2tEb3duc2NhbGUgLyB2ZWM0KCBQYWNrRmFjdG9ycywgMS4gKTtcXHJcXG5cXHJcXG5jb25zdCBmbG9hdCBTaGlmdFJpZ2h0OCA9IDEuIC8gMjU2LjtcXHJcXG5cXHJcXG52ZWM0IHBhY2tEZXB0aFRvUkdCQSggY29uc3QgaW4gZmxvYXQgdiApIHtcXHJcXG5cXHR2ZWM0IHIgPSB2ZWM0KCBmcmFjdCggdiAqIFBhY2tGYWN0b3JzICksIHYgKTtcXHJcXG5cXHRyLnl6dyAtPSByLnh5eiAqIFNoaWZ0UmlnaHQ4OyAvLyB0aWR5IG92ZXJmbG93XFxyXFxuXFx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXHJcXG5cXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XFxyXFxufVxcclxcblxcclxcbi8vIE5PVEU6IHZpZXdaL2V5ZVogaXMgPCAwIHdoZW4gaW4gZnJvbnQgb2YgdGhlIGNhbWVyYSBwZXIgT3BlbkdMIGNvbnZlbnRpb25zXFxyXFxuXFxyXFxuZmxvYXQgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcclxcblxcdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxyXFxufVxcclxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXHJcXG5cXHRyZXR1cm4gbGluZWFyQ2xpcFogKiAoIG5lYXIgLSBmYXIgKSAtIG5lYXI7XFxyXFxufVxcclxcblxcclxcbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcclxcblxcdHJldHVybiAoKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCggZmFyIC0gbmVhciApICogdmlld1ogKTtcXHJcXG59XFxyXFxuZmxvYXQgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGludkNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxyXFxuXFx0cmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGludkNsaXBaIC0gZmFyICk7XFxyXFxufVxcclxcblwiO1xuXG5cdHZhciBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50ID0gXCIjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQVxcclxcblxcclxcblxcdC8vIEdldCBnZXQgbm9ybWFsIGJsZW5kaW5nIHdpdGggcHJlbXVsdGlwbGVkLCB1c2Ugd2l0aCBDdXN0b21CbGVuZGluZywgT25lRmFjdG9yLCBPbmVNaW51c1NyY0FscGhhRmFjdG9yLCBBZGRFcXVhdGlvbi5cXHJcXG5cXHRnbF9GcmFnQ29sb3IucmdiICo9IGdsX0ZyYWdDb2xvci5hO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciBwcm9qZWN0X3ZlcnRleCA9IFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcclxcblxcclxcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxyXFxuXCI7XG5cblx0dmFyIGRpdGhlcmluZ19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIERJVEhFUklORyApXFxyXFxuXFxyXFxuICBnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggRElUSEVSSU5HIClcXHJcXG5cXHJcXG5cXHQvLyBiYXNlZCBvbiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvTXNsR1I4XFxyXFxuXFx0dmVjMyBkaXRoZXJpbmcoIHZlYzMgY29sb3IgKSB7XFxyXFxuXFx0XFx0Ly9DYWxjdWxhdGUgZ3JpZCBwb3NpdGlvblxcclxcblxcdFxcdGZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTtcXHJcXG5cXHJcXG5cXHRcXHQvL1NoaWZ0IHRoZSBpbmRpdmlkdWFsIGNvbG9ycyBkaWZmZXJlbnRseSwgdGh1cyBtYWtpbmcgaXQgZXZlbiBoYXJkZXIgdG8gc2VlIHRoZSBkaXRoZXJpbmcgcGF0dGVyblxcclxcblxcdFxcdHZlYzMgZGl0aGVyX3NoaWZ0X1JHQiA9IHZlYzMoIDAuMjUgLyAyNTUuMCwgLTAuMjUgLyAyNTUuMCwgMC4yNSAvIDI1NS4wICk7XFxyXFxuXFxyXFxuXFx0XFx0Ly9tb2RpZnkgc2hpZnQgYWNvcmRpbmcgdG8gZ3JpZCBwb3NpdGlvbi5cXHJcXG5cXHRcXHRkaXRoZXJfc2hpZnRfUkdCID0gbWl4KCAyLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCAtMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgZ3JpZF9wb3NpdGlvbiApO1xcclxcblxcclxcblxcdFxcdC8vc2hpZnQgdGhlIGNvbG9yIGJ5IGRpdGhlcl9zaGlmdFxcclxcblxcdFxcdHJldHVybiBjb2xvciArIGRpdGhlcl9zaGlmdF9SR0I7XFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXHJcXG5cXHJcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcclxcblxcclxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxyXFxuXFxyXFxuXFx0Ly8gcmVhZHMgY2hhbm5lbCBHLCBjb21wYXRpYmxlIHdpdGggYSBjb21iaW5lZCBPY2NsdXNpb25Sb3VnaG5lc3NNZXRhbGxpYyAoUkdCKSB0ZXh0dXJlXFxyXFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcclxcblxcclxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcXHJcXG5cXHJcXG4jZW5kaWZcIjtcblxuXHR2YXIgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxyXFxuXFxyXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcclxcblxcclxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBOVU1fRElSX0xJR0hUUyBdO1xcclxcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVFMgXTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcclxcblxcclxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUUyBdO1xcclxcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFNoYWRvd01hcFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcclxcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcclxcblxcclxcblxcdGZsb2F0IHRleHR1cmUyRENvbXBhcmUoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHN0ZXAoIGNvbXBhcmUsIHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIGRlcHRocywgdXYgKSApICk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZsb2F0IHRleHR1cmUyRFNoYWRvd0xlcnAoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgc2l6ZSwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRjb25zdCB2ZWMyIG9mZnNldCA9IHZlYzIoIDAuMCwgMS4wICk7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNpemU7XFxyXFxuXFx0XFx0dmVjMiBjZW50cm9pZFVWID0gZmxvb3IoIHV2ICogc2l6ZSArIDAuNSApIC8gc2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBsYiA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC54eCwgY29tcGFyZSApO1xcclxcblxcdFxcdGZsb2F0IGx0ID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnh5LCBjb21wYXJlICk7XFxyXFxuXFx0XFx0ZmxvYXQgcmIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXgsIGNvbXBhcmUgKTtcXHJcXG5cXHRcXHRmbG9hdCBydCA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC55eSwgY29tcGFyZSApO1xcclxcblxcclxcblxcdFxcdHZlYzIgZiA9IGZyYWN0KCB1diAqIHNpemUgKyAwLjUgKTtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBhID0gbWl4KCBsYiwgbHQsIGYueSApO1xcclxcblxcdFxcdGZsb2F0IGIgPSBtaXgoIHJiLCBydCwgZi55ICk7XFxyXFxuXFx0XFx0ZmxvYXQgYyA9IG1peCggYSwgYiwgZi54ICk7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGM7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGZsb2F0IGdldFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQgKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgc2hhZG93ID0gMS4wO1xcclxcblxcclxcblxcdFxcdHNoYWRvd0Nvb3JkLnh5eiAvPSBzaGFkb3dDb29yZC53O1xcclxcblxcdFxcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhcztcXHJcXG5cXHJcXG5cXHRcXHQvLyBpZiAoIHNvbWV0aGluZyAmJiBzb21ldGhpbmcgKSBicmVha3MgQVRJIE9wZW5HTCBzaGFkZXIgY29tcGlsZXJcXHJcXG5cXHRcXHQvLyBpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApIHVzaW5nIHRoaXMgaW5zdGVhZFxcclxcblxcclxcblxcdFxcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXHJcXG5cXHRcXHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxyXFxuXFxyXFxuXFx0XFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcclxcblxcclxcblxcdFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxyXFxuXFxyXFxuXFx0XFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXHJcXG5cXHJcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcclxcblxcdFxcdFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxyXFxuXFx0XFx0XFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXHJcXG5cXHRcXHRcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcclxcblxcclxcblxcdFxcdFxcdHNoYWRvdyA9IChcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcclxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcclxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcclxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcclxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXHJcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXHJcXG5cXHJcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxyXFxuXFxyXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXHJcXG5cXHRcXHRcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcclxcblxcdFxcdFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxyXFxuXFx0XFx0XFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXHJcXG5cXHJcXG5cXHRcXHRcXHRzaGFkb3cgPSAoXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxyXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxyXFxuXFxyXFxuXFx0XFx0I2Vsc2UgLy8gbm8gcGVyY2VudGFnZS1jbG9zZXIgZmlsdGVyaW5nOlxcclxcblxcclxcblxcdFxcdFxcdHNoYWRvdyA9IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHNoYWRvdztcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Ly8gY3ViZVRvVVYoKSBtYXBzIGEgM0QgZGlyZWN0aW9uIHZlY3RvciBzdWl0YWJsZSBmb3IgY3ViZSB0ZXh0dXJlIG1hcHBpbmcgdG8gYSAyRFxcclxcblxcdC8vIHZlY3RvciBzdWl0YWJsZSBmb3IgMkQgdGV4dHVyZSBtYXBwaW5nLiBUaGlzIGNvZGUgdXNlcyB0aGUgZm9sbG93aW5nIGxheW91dCBmb3IgdGhlXFxyXFxuXFx0Ly8gMkQgdGV4dHVyZTpcXHJcXG5cXHQvL1xcclxcblxcdC8vIHh6WFpcXHJcXG5cXHQvLyAgeSBZXFxyXFxuXFx0Ly9cXHJcXG5cXHQvLyBZIC0gUG9zaXRpdmUgeSBkaXJlY3Rpb25cXHJcXG5cXHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cXHJcXG5cXHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cXHJcXG5cXHQvLyB4IC0gTmVnYXRpdmUgeCBkaXJlY3Rpb25cXHJcXG5cXHQvLyBaIC0gUG9zaXRpdmUgeiBkaXJlY3Rpb25cXHJcXG5cXHQvLyB6IC0gTmVnYXRpdmUgeiBkaXJlY3Rpb25cXHJcXG5cXHQvL1xcclxcblxcdC8vIFNvdXJjZSBhbmQgdGVzdCBiZWQ6XFxyXFxuXFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdHNjaHcvZGExMGM0M2M0NjdjZThhZmQwYzRcXHJcXG5cXHJcXG5cXHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gTnVtYmVyIG9mIHRleGVscyB0byBhdm9pZCBhdCB0aGUgZWRnZSBvZiBlYWNoIHNxdWFyZVxcclxcblxcclxcblxcdFxcdHZlYzMgYWJzViA9IGFicyggdiApO1xcclxcblxcclxcblxcdFxcdC8vIEludGVyc2VjdCB1bml0IGN1YmVcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXHJcXG5cXHRcXHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcclxcblxcclxcblxcdFxcdC8vIEFwcGx5IHNjYWxlIHRvIGF2b2lkIHNlYW1zXFxyXFxuXFxyXFxuXFx0XFx0Ly8gdHdvIHRleGVscyBsZXNzIHBlciBzcXVhcmUgKG9uZSB0ZXhlbCB3aWxsIGRvIGZvciBORUFSRVNUKVxcclxcblxcdFxcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBVbndyYXBcXHJcXG5cXHJcXG5cXHRcXHQvLyBzcGFjZTogLTEgLi4uIDEgcmFuZ2UgZm9yIGVhY2ggc3F1YXJlXFxyXFxuXFx0XFx0Ly9cXHJcXG5cXHRcXHQvLyAjWCMjXFx0XFx0ZGltICAgIDo9ICggNCAsIDIgKVxcclxcblxcdFxcdC8vICAjICNcXHRcXHRjZW50ZXIgOj0gKCAxICwgMSApXFxyXFxuXFxyXFxuXFx0XFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xcclxcblxcclxcblxcdFxcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XFxyXFxuXFx0XFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcclxcblxcclxcblxcdFxcdGlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRpZiAoIHYueiA+IDAuMCApXFxyXFxuXFx0XFx0XFx0XFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxyXFxuXFxyXFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xcclxcblxcdFxcdFxcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcclxcblxcclxcblxcdFxcdFxcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XFxyXFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcXHJcXG5cXHRcXHRcXHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBUcmFuc2Zvcm0gdG8gVVYgc3BhY2VcXHJcXG5cXHJcXG5cXHRcXHQvLyBzY2FsZSA6PSAwLjUgLyBkaW1cXHJcXG5cXHRcXHQvLyB0cmFuc2xhdGUgOj0gKCBjZW50ZXIgKyAwLjUgKSAvIGRpbVxcclxcblxcdFxcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBmb3IgcG9pbnQgbGlnaHRzLCB0aGUgdW5pZm9ybSBAdlNoYWRvd0Nvb3JkIGlzIHJlLXB1cnBvc2VkIHRvIGhvbGRcXHJcXG5cXHRcXHQvLyB0aGUgdmVjdG9yIGZyb20gdGhlIGxpZ2h0IHRvIHRoZSB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiB0aGUgZnJhZ21lbnQuXFxyXFxuXFx0XFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gZHAgPSBub3JtYWxpemVkIGRpc3RhbmNlIGZyb20gbGlnaHQgdG8gZnJhZ21lbnQgcG9zaXRpb25cXHJcXG5cXHRcXHRmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0NhbWVyYU5lYXIgKSAvICggc2hhZG93Q2FtZXJhRmFyIC0gc2hhZG93Q2FtZXJhTmVhciApOyAvLyBuZWVkIHRvIGNsYW1wP1xcclxcblxcdFxcdGRwICs9IHNoYWRvd0JpYXM7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gYmQzRCA9IGJhc2UgZGlyZWN0aW9uIDNEXFxyXFxuXFx0XFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXHJcXG5cXHJcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcclxcblxcclxcblxcdFxcdFxcdHZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gKFxcclxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcclxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxyXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcclxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXHJcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcclxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcclxcblxcclxcblxcdFxcdCNlbHNlIC8vIG5vIHBlcmNlbnRhZ2UtY2xvc2VyIGZpbHRlcmluZ1xcclxcblxcclxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApO1xcclxcblxcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgc2hhZG93bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcclxcblxcclxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHRcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRTIF07XFxyXFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IHNwb3RTaGFkb3dNYXRyaXhbIE5VTV9TUE9UX0xJR0hUUyBdO1xcclxcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHRcXHR1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXHJcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgc2hhZG93bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXHJcXG5cXHJcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcFxcclxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXHJcXG5cXHJcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wXFxyXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdHZTcG90U2hhZG93Q29vcmRbIGkgXSA9IHNwb3RTaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcclxcblxcclxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BcXHJcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCA9IFwiZmxvYXQgZ2V0U2hhZG93TWFzaygpIHtcXHJcXG5cXHJcXG5cXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXHJcXG5cXHJcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcclxcblxcclxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BcXHJcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXHJcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxyXFxuXFxyXFxuXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXHJcXG5cXHJcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wXFxyXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcclxcblxcclxcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXHJcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggc3BvdExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcclxcblxcclxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXHJcXG5cXHJcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wXFxyXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXHJcXG5cXHJcXG5cXHRcXHRwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXHJcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggcG9pbnRMaWdodC5zaGFkb3cgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0cmV0dXJuIHNoYWRvdztcXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIHNraW5iYXNlX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcclxcblxcclxcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcclxcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcclxcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcclxcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciBza2lubmluZ19wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcclxcblxcclxcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcclxcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxyXFxuXFxyXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxyXFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVTaXplO1xcclxcblxcclxcblxcdFxcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmbG9hdCBqID0gaSAqIDQuMDtcXHJcXG5cXHRcXHRcXHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXHJcXG5cXHRcXHRcXHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXHJcXG5cXHRcXHRcXHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxyXFxuXFx0XFx0XFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcclxcblxcdFxcdFxcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXHJcXG5cXHRcXHRcXHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXHJcXG5cXHJcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHR1bmlmb3JtIG1hdDQgYm9uZU1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXHJcXG5cXHJcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0bWF0NCBib25lID0gYm9uZU1hdHJpY2VzWyBpbnQoaSkgXTtcXHJcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIHNraW5uaW5nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcclxcblxcclxcblxcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxyXFxuXFxyXFxuXFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxyXFxuXFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxyXFxuXFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxyXFxuXFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxyXFxuXFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxyXFxuXFxyXFxuXFx0dHJhbnNmb3JtZWQgPSAoIGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZCApLnh5ejtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgc2tpbm5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXHJcXG5cXHJcXG5cXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXHJcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcclxcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxyXFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXHJcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcclxcblxcdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXHJcXG5cXHJcXG5cXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgc3BlY3VsYXJtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxyXFxuXFxyXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcclxcblxcclxcblxcdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcclxcblxcdHNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxyXFxuXFxyXFxuI2Vsc2VcXHJcXG5cXHJcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxyXFxuXFxyXFxuI2VuZGlmXCI7XG5cblx0dmFyIHRvbmVtYXBwaW5nX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcXHJcXG5cXHJcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcclxcblxcclxcbiNlbmRpZlxcclxcblwiO1xuXG5cdHZhciB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZuZGVmIHNhdHVyYXRlXFxyXFxuXFx0I2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcclxcbiNlbmRpZlxcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTtcXHJcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nV2hpdGVQb2ludDtcXHJcXG5cXHJcXG4vLyBleHBvc3VyZSBvbmx5XFxyXFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG4vLyBzb3VyY2U6IGh0dHBzOi8vd3d3LmNzLnV0YWguZWR1L35yZWluaGFyZC9jZHJvbS9cXHJcXG52ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXHJcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuLy8gc291cmNlOiBodHRwOi8vZmlsbWljZ2FtZXMuY29tL2FyY2hpdmVzLzc1XFxyXFxuI2RlZmluZSBVbmNoYXJ0ZWQySGVscGVyKCB4ICkgbWF4KCAoICggeCAqICggMC4xNSAqIHggKyAwLjEwICogMC41MCApICsgMC4yMCAqIDAuMDIgKSAvICggeCAqICggMC4xNSAqIHggKyAwLjUwICkgKyAwLjIwICogMC4zMCApICkgLSAwLjAyIC8gMC4zMCwgdmVjMyggMC4wICkgKVxcclxcbnZlYzMgVW5jaGFydGVkMlRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcclxcblxcclxcblxcdC8vIEpvaG4gSGFibGUncyBmaWxtaWMgb3BlcmF0b3IgZnJvbSBVbmNoYXJ0ZWQgMiB2aWRlbyBnYW1lXFxyXFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXHJcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIFVuY2hhcnRlZDJIZWxwZXIoIGNvbG9yICkgLyBVbmNoYXJ0ZWQySGVscGVyKCB2ZWMzKCB0b25lTWFwcGluZ1doaXRlUG9pbnQgKSApICk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi8vIHNvdXJjZTogaHR0cDovL2ZpbG1pY2dhbWVzLmNvbS9hcmNoaXZlcy83NVxcclxcbnZlYzMgT3B0aW1pemVkQ2luZW9uVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxyXFxuXFxyXFxuXFx0Ly8gb3B0aW1pemVkIGZpbG1pYyBvcGVyYXRvciBieSBKaW0gSGVqbCBhbmQgUmljaGFyZCBCdXJnZXNzLURhd3NvblxcclxcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxyXFxuXFx0Y29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7XFxyXFxuXFx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIHV2X3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcclxcblxcclxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxuI2VuZGlmXCI7XG5cblx0dmFyIHV2X3BhcnNfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXHJcXG5cXHJcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cIjtcblxuXHR2YXIgdXZfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXHJcXG5cXHJcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciB1djJfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxyXFxuXFxyXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxyXFxuXFxyXFxuI2VuZGlmXCI7XG5cblx0dmFyIHV2Ml9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxyXFxuXFxyXFxuXFx0YXR0cmlidXRlIHZlYzIgdXYyO1xcclxcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciB1djJfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXHJcXG5cXHJcXG5cXHR2VXYyID0gdXYyO1xcclxcblxcclxcbiNlbmRpZlwiO1xuXG5cdHZhciB3b3JsZHBvc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggRElTVEFOQ0UgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxyXFxuXFxyXFxuXFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXCI7XG5cblx0dmFyIGN1YmVfZnJhZyA9IFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcXHJcXG51bmlmb3JtIGZsb2F0IHRGbGlwO1xcclxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XFxyXFxuXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIGN1YmVfdmVydCA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHJcXG5cXHRnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udzsgLy8gc2V0IHogdG8gY2FtZXJhLmZhclxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgZGVwdGhfZnJhZyA9IFwiI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaW5jbHVkZSA8Y29tbW9uPlxcclxcbiNpbmNsdWRlIDxwYWNraW5nPlxcclxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXHJcXG5cXHJcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxyXFxuXFxyXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcclxcblxcclxcblxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXHJcXG5cXHJcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBnbF9GcmFnQ29vcmQueiApLCBvcGFjaXR5ICk7XFxyXFxuXFxyXFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxyXFxuXFxyXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBnbF9GcmFnQ29vcmQueiApO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgZGVwdGhfdmVydCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXHJcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXHJcXG5cXHJcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcclxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxyXFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4Plxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgZGlzdGFuY2VSR0JBX2ZyYWcgPSBcIiNkZWZpbmUgRElTVEFOQ0VcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247XFxyXFxudW5pZm9ybSBmbG9hdCBuZWFyRGlzdGFuY2U7XFxyXFxudW5pZm9ybSBmbG9hdCBmYXJEaXN0YW5jZTtcXHJcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxyXFxuXFxyXFxuI2luY2x1ZGUgPGNvbW1vbj5cXHJcXG4jaW5jbHVkZSA8cGFja2luZz5cXHJcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcclxcblxcclxcbnZvaWQgbWFpbiAoKSB7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXHJcXG5cXHJcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0ZmxvYXQgZGlzdCA9IGxlbmd0aCggdldvcmxkUG9zaXRpb24gLSByZWZlcmVuY2VQb3NpdGlvbiApO1xcclxcblxcdGRpc3QgPSAoIGRpc3QgLSBuZWFyRGlzdGFuY2UgKSAvICggZmFyRGlzdGFuY2UgLSBuZWFyRGlzdGFuY2UgKTtcXHJcXG5cXHRkaXN0ID0gc2F0dXJhdGUoIGRpc3QgKTsgLy8gY2xhbXAgdG8gWyAwLCAxIF1cXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGRpc3QgKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIGRpc3RhbmNlUkdCQV92ZXJ0ID0gXCIjZGVmaW5lIERJU1RBTkNFXFxyXFxuXFxyXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXHJcXG5cXHJcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcclxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxyXFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcclxcblxcclxcblxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxyXFxuXFxyXFxufVxcclxcblwiO1xuXG5cdHZhciBlcXVpcmVjdF9mcmFnID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xcclxcblxcclxcblxcdHZlYzIgc2FtcGxlVVY7XFxyXFxuXFxyXFxuXFx0c2FtcGxlVVYueSA9IGFzaW4oIGNsYW1wKCBkaXJlY3Rpb24ueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xcclxcblxcclxcblxcdHNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgZXF1aXJlY3RfdmVydCA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIGxpbmVkYXNoZWRfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxyXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XFxyXFxudW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XFxyXFxuXFxyXFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXHJcXG5cXHJcXG5cXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcXHJcXG5cXHJcXG5cXHRcXHRkaXNjYXJkO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXHJcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcclxcblxcclxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiOyAvLyBzaW1wbGUgc2hhZGVyXFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgbGluZWRhc2hlZF92ZXJ0ID0gXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcclxcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxyXFxuXFxyXFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xcclxcblxcclxcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxyXFxuXFxyXFxufVxcclxcblwiO1xuXG5cdHZhciBtZXNoYmFzaWNfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxyXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcclxcblxcclxcbiNpZm5kZWYgRkxBVF9TSEFERURcXHJcXG5cXHJcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaW5jbHVkZSA8Y29tbW9uPlxcclxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXHJcXG5cXHJcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcclxcblxcclxcblxcdC8vIGFjY3VtdWxhdGlvbiAoYmFrZWQgaW5kaXJlY3QgbGlnaHRpbmcgb25seSlcXHJcXG5cXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxyXFxuXFxyXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB2ZWMzKCAxLjAgKTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQvLyBtb2R1bGF0aW9uXFxyXFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcclxcblxcclxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiO1xcclxcblxcclxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIG1lc2hiYXNpY192ZXJ0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcclxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFVTRV9FTlZNQVBcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgbWVzaGxhbWJlcnRfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxyXFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcclxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxyXFxuXFxyXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcclxcblxcclxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxyXFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxic2Rmcz5cXHJcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxyXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXHJcXG5cXHJcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXHJcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcclxcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0Ly8gYWNjdW11bGF0aW9uXFxyXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlID0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8bGlnaHRtYXBfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICk7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcclxcblxcclxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSAoIGdsX0Zyb250RmFjaW5nICkgPyB2TGlnaHRGcm9udCA6IHZMaWdodEJhY2s7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gdkxpZ2h0RnJvbnQ7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSAqPSBCUkRGX0RpZmZ1c2VfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApICogZ2V0U2hhZG93TWFzaygpO1xcclxcblxcclxcblxcdC8vIG1vZHVsYXRpb25cXHJcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgbWVzaGxhbWJlcnRfdmVydCA9IFwiI2RlZmluZSBMQU1CRVJUXFxyXFxuXFxyXFxudmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1xcclxcblxcclxcbiNpZmRlZiBET1VCTEVfU0lERURcXHJcXG5cXHJcXG5cXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaW5jbHVkZSA8Y29tbW9uPlxcclxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGJzZGZzPlxcclxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXHJcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcclxcblxcclxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIG1lc2hwaG9uZ19mcmFnID0gXCIjZGVmaW5lIFBIT05HXFxyXFxuXFxyXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxyXFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcclxcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXHJcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXHJcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxyXFxuXFxyXFxuI2luY2x1ZGUgPGNvbW1vbj5cXHJcXG4jaW5jbHVkZSA8cGFja2luZz5cXHJcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxic2Rmcz5cXHJcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxyXFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxyXFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXHJcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0Ly8gYWNjdW11bGF0aW9uXFxyXFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waG9uZ19mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3RlbXBsYXRlPlxcclxcblxcclxcblxcdC8vIG1vZHVsYXRpb25cXHJcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50Plxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgbWVzaHBob25nX3ZlcnQgPSBcIiNkZWZpbmUgUEhPTkdcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXHJcXG5cXHJcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxyXFxuXFxyXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuI2luY2x1ZGUgPGNvbW1vbj5cXHJcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXHJcXG5cXHJcXG4jaWZuZGVmIEZMQVRfU0hBREVEIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcXHJcXG5cXHJcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcclxcblxcclxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcclxcblxcclxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxyXFxuXFxyXFxufVxcclxcblwiO1xuXG5cdHZhciBtZXNocGh5c2ljYWxfZnJhZyA9IFwiI2RlZmluZSBQSFlTSUNBTFxcclxcblxcclxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcclxcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXHJcXG51bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcXHJcXG51bmlmb3JtIGZsb2F0IG1ldGFsbmVzcztcXHJcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxyXFxuXFxyXFxuI2lmbmRlZiBTVEFOREFSRFxcclxcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJDb2F0O1xcclxcblxcdHVuaWZvcm0gZmxvYXQgY2xlYXJDb2F0Um91Z2huZXNzO1xcclxcbiNlbmRpZlxcclxcblxcclxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcclxcblxcclxcbiNpZm5kZWYgRkxBVF9TSEFERURcXHJcXG5cXHJcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaW5jbHVkZSA8Y29tbW9uPlxcclxcbiNpbmNsdWRlIDxwYWNraW5nPlxcclxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGJzZGZzPlxcclxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcclxcbiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxyXFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXHJcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8cm91Z2huZXNzbWFwX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0Ly8gYWNjdW11bGF0aW9uXFxyXFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3RlbXBsYXRlPlxcclxcblxcclxcblxcdC8vIG1vZHVsYXRpb25cXHJcXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcclxcblxcclxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIG1lc2hwaHlzaWNhbF92ZXJ0ID0gXCIjZGVmaW5lIFBIWVNJQ0FMXFxyXFxuXFxyXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxyXFxuXFxyXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcclxcblxcclxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcclxcblxcclxcbiNpZm5kZWYgRkxBVF9TSEFERUQgLy8gTm9ybWFsIGNvbXB1dGVkIHdpdGggZGVyaXZhdGl2ZXMgd2hlbiBGTEFUX1NIQURFRFxcclxcblxcclxcblxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIG5vcm1hbF9mcmFnID0gXCIjZGVmaW5lIE5PUk1BTFxcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXHJcXG5cXHJcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVxcclxcblxcclxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZm5kZWYgRkxBVF9TSEFERURcXHJcXG5cXHJcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaW5jbHVkZSA8cGFja2luZz5cXHJcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnQ+XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCBub3JtYWwgKSwgb3BhY2l0eSApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgbm9ybWFsX3ZlcnQgPSBcIiNkZWZpbmUgTk9STUFMXFxyXFxuXFxyXFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXHJcXG5cXHJcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxyXFxuXFxyXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXHJcXG5cXHJcXG4jaWZuZGVmIEZMQVRfU0hBREVEIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcXHJcXG5cXHJcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcclxcblxcclxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxyXFxuXFxyXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxufVxcclxcblwiO1xuXG5cdHZhciBwb2ludHNfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxyXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxyXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXHJcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxyXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcclxcblxcclxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcclxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXHJcXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcclxcblxcclxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcclxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxyXFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIHBvaW50c192ZXJ0ID0gXCJ1bmlmb3JtIGZsb2F0IHNpemU7XFxyXFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcXHJcXG5cXHJcXG4jaW5jbHVkZSA8Y29tbW9uPlxcclxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxyXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcclxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXHJcXG5cXHRcXHRnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7XFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHRcXHRnbF9Qb2ludFNpemUgPSBzaXplO1xcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxyXFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXHJcXG5cXHJcXG59XFxyXFxuXCI7XG5cblx0dmFyIHNoYWRvd19mcmFnID0gXCJ1bmlmb3JtIHZlYzMgY29sb3I7XFxyXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcclxcblxcclxcbiNpbmNsdWRlIDxjb21tb24+XFxyXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxyXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxic2Rmcz5cXHJcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxyXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcclxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcclxcblxcclxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxyXFxuXFxyXFxufVxcclxcblwiO1xuXG5cdHZhciBzaGFkb3dfdmVydCA9IFwiI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXHJcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXHJcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcclxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcclxcblxcclxcbn1cXHJcXG5cIjtcblxuXHR2YXIgU2hhZGVyQ2h1bmsgPSB7XG5cdFx0YWxwaGFtYXBfZnJhZ21lbnQ6IGFscGhhbWFwX2ZyYWdtZW50LFxuXHRcdGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0YWxwaGF0ZXN0X2ZyYWdtZW50OiBhbHBoYXRlc3RfZnJhZ21lbnQsXG5cdFx0YW9tYXBfZnJhZ21lbnQ6IGFvbWFwX2ZyYWdtZW50LFxuXHRcdGFvbWFwX3BhcnNfZnJhZ21lbnQ6IGFvbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0YmVnaW5fdmVydGV4OiBiZWdpbl92ZXJ0ZXgsXG5cdFx0YmVnaW5ub3JtYWxfdmVydGV4OiBiZWdpbm5vcm1hbF92ZXJ0ZXgsXG5cdFx0YnNkZnM6IGJzZGZzLFxuXHRcdGJ1bXBtYXBfcGFyc19mcmFnbWVudDogYnVtcG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50LFxuXHRcdGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCxcblx0XHRjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCxcblx0XHRjbGlwcGluZ19wbGFuZXNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfdmVydGV4LFxuXHRcdGNvbG9yX2ZyYWdtZW50OiBjb2xvcl9mcmFnbWVudCxcblx0XHRjb2xvcl9wYXJzX2ZyYWdtZW50OiBjb2xvcl9wYXJzX2ZyYWdtZW50LFxuXHRcdGNvbG9yX3BhcnNfdmVydGV4OiBjb2xvcl9wYXJzX3ZlcnRleCxcblx0XHRjb2xvcl92ZXJ0ZXg6IGNvbG9yX3ZlcnRleCxcblx0XHRjb21tb246IGNvbW1vbixcblx0XHRjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6IGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCxcblx0XHRkZWZhdWx0bm9ybWFsX3ZlcnRleDogZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXG5cdFx0ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgsXG5cdFx0ZGlzcGxhY2VtZW50bWFwX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3ZlcnRleCxcblx0XHRlbWlzc2l2ZW1hcF9mcmFnbWVudDogZW1pc3NpdmVtYXBfZnJhZ21lbnQsXG5cdFx0ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudDogZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCxcblx0XHRlbmNvZGluZ3NfZnJhZ21lbnQ6IGVuY29kaW5nc19mcmFnbWVudCxcblx0XHRlbmNvZGluZ3NfcGFyc19mcmFnbWVudDogZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQsXG5cdFx0ZW52bWFwX2ZyYWdtZW50OiBlbnZtYXBfZnJhZ21lbnQsXG5cdFx0ZW52bWFwX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdGVudm1hcF9wYXJzX3ZlcnRleDogZW52bWFwX3BhcnNfdmVydGV4LFxuXHRcdGVudm1hcF92ZXJ0ZXg6IGVudm1hcF92ZXJ0ZXgsXG5cdFx0Zm9nX3ZlcnRleDogZm9nX3ZlcnRleCxcblx0XHRmb2dfcGFyc192ZXJ0ZXg6IGZvZ19wYXJzX3ZlcnRleCxcblx0XHRmb2dfZnJhZ21lbnQ6IGZvZ19mcmFnbWVudCxcblx0XHRmb2dfcGFyc19mcmFnbWVudDogZm9nX3BhcnNfZnJhZ21lbnQsXG5cdFx0Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudDogZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodG1hcF9mcmFnbWVudDogbGlnaHRtYXBfZnJhZ21lbnQsXG5cdFx0bGlnaHRtYXBfcGFyc19mcmFnbWVudDogbGlnaHRtYXBfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxcblx0XHRsaWdodHNfcGFyczogbGlnaHRzX3BhcnMsXG5cdFx0bGlnaHRzX3Bob25nX2ZyYWdtZW50OiBsaWdodHNfcGhvbmdfZnJhZ21lbnQsXG5cdFx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudDogbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50LFxuXHRcdGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCxcblx0XHRsaWdodHNfdGVtcGxhdGU6IGxpZ2h0c190ZW1wbGF0ZSxcblx0XHRsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXG5cdFx0bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDogbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcblx0XHRsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXG5cdFx0bG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG5cdFx0bWFwX2ZyYWdtZW50OiBtYXBfZnJhZ21lbnQsXG5cdFx0bWFwX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxuXHRcdG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCxcblx0XHRtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9mcmFnbWVudCxcblx0XHRtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0bW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXG5cdFx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxuXHRcdG1vcnBodGFyZ2V0X3ZlcnRleDogbW9ycGh0YXJnZXRfdmVydGV4LFxuXHRcdG5vcm1hbF9mcmFnbWVudDogbm9ybWFsX2ZyYWdtZW50LFxuXHRcdG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OiBub3JtYWxtYXBfcGFyc19mcmFnbWVudCxcblx0XHRwYWNraW5nOiBwYWNraW5nLFxuXHRcdHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6IHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQsXG5cdFx0cHJvamVjdF92ZXJ0ZXg6IHByb2plY3RfdmVydGV4LFxuXHRcdGRpdGhlcmluZ19mcmFnbWVudDogZGl0aGVyaW5nX2ZyYWdtZW50LFxuXHRcdGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50OiBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCxcblx0XHRyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9mcmFnbWVudCxcblx0XHRyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudDogcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG5cdFx0c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFxuXHRcdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogc2hhZG93bWFwX3BhcnNfdmVydGV4LFxuXHRcdHNoYWRvd21hcF92ZXJ0ZXg6IHNoYWRvd21hcF92ZXJ0ZXgsXG5cdFx0c2hhZG93bWFza19wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQsXG5cdFx0c2tpbmJhc2VfdmVydGV4OiBza2luYmFzZV92ZXJ0ZXgsXG5cdFx0c2tpbm5pbmdfcGFyc192ZXJ0ZXg6IHNraW5uaW5nX3BhcnNfdmVydGV4LFxuXHRcdHNraW5uaW5nX3ZlcnRleDogc2tpbm5pbmdfdmVydGV4LFxuXHRcdHNraW5ub3JtYWxfdmVydGV4OiBza2lubm9ybWFsX3ZlcnRleCxcblx0XHRzcGVjdWxhcm1hcF9mcmFnbWVudDogc3BlY3VsYXJtYXBfZnJhZ21lbnQsXG5cdFx0c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDogc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCxcblx0XHR0b25lbWFwcGluZ19mcmFnbWVudDogdG9uZW1hcHBpbmdfZnJhZ21lbnQsXG5cdFx0dG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDogdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCxcblx0XHR1dl9wYXJzX2ZyYWdtZW50OiB1dl9wYXJzX2ZyYWdtZW50LFxuXHRcdHV2X3BhcnNfdmVydGV4OiB1dl9wYXJzX3ZlcnRleCxcblx0XHR1dl92ZXJ0ZXg6IHV2X3ZlcnRleCxcblx0XHR1djJfcGFyc19mcmFnbWVudDogdXYyX3BhcnNfZnJhZ21lbnQsXG5cdFx0dXYyX3BhcnNfdmVydGV4OiB1djJfcGFyc192ZXJ0ZXgsXG5cdFx0dXYyX3ZlcnRleDogdXYyX3ZlcnRleCxcblx0XHR3b3JsZHBvc192ZXJ0ZXg6IHdvcmxkcG9zX3ZlcnRleCxcblxuXHRcdGN1YmVfZnJhZzogY3ViZV9mcmFnLFxuXHRcdGN1YmVfdmVydDogY3ViZV92ZXJ0LFxuXHRcdGRlcHRoX2ZyYWc6IGRlcHRoX2ZyYWcsXG5cdFx0ZGVwdGhfdmVydDogZGVwdGhfdmVydCxcblx0XHRkaXN0YW5jZVJHQkFfZnJhZzogZGlzdGFuY2VSR0JBX2ZyYWcsXG5cdFx0ZGlzdGFuY2VSR0JBX3ZlcnQ6IGRpc3RhbmNlUkdCQV92ZXJ0LFxuXHRcdGVxdWlyZWN0X2ZyYWc6IGVxdWlyZWN0X2ZyYWcsXG5cdFx0ZXF1aXJlY3RfdmVydDogZXF1aXJlY3RfdmVydCxcblx0XHRsaW5lZGFzaGVkX2ZyYWc6IGxpbmVkYXNoZWRfZnJhZyxcblx0XHRsaW5lZGFzaGVkX3ZlcnQ6IGxpbmVkYXNoZWRfdmVydCxcblx0XHRtZXNoYmFzaWNfZnJhZzogbWVzaGJhc2ljX2ZyYWcsXG5cdFx0bWVzaGJhc2ljX3ZlcnQ6IG1lc2hiYXNpY192ZXJ0LFxuXHRcdG1lc2hsYW1iZXJ0X2ZyYWc6IG1lc2hsYW1iZXJ0X2ZyYWcsXG5cdFx0bWVzaGxhbWJlcnRfdmVydDogbWVzaGxhbWJlcnRfdmVydCxcblx0XHRtZXNocGhvbmdfZnJhZzogbWVzaHBob25nX2ZyYWcsXG5cdFx0bWVzaHBob25nX3ZlcnQ6IG1lc2hwaG9uZ192ZXJ0LFxuXHRcdG1lc2hwaHlzaWNhbF9mcmFnOiBtZXNocGh5c2ljYWxfZnJhZyxcblx0XHRtZXNocGh5c2ljYWxfdmVydDogbWVzaHBoeXNpY2FsX3ZlcnQsXG5cdFx0bm9ybWFsX2ZyYWc6IG5vcm1hbF9mcmFnLFxuXHRcdG5vcm1hbF92ZXJ0OiBub3JtYWxfdmVydCxcblx0XHRwb2ludHNfZnJhZzogcG9pbnRzX2ZyYWcsXG5cdFx0cG9pbnRzX3ZlcnQ6IHBvaW50c192ZXJ0LFxuXHRcdHNoYWRvd19mcmFnOiBzaGFkb3dfZnJhZyxcblx0XHRzaGFkb3dfdmVydDogc2hhZG93X3ZlcnRcblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICovXG5cblx0dmFyIFNoYWRlckxpYiA9IHtcblxuXHRcdGJhc2ljOiB7XG5cblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cdFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5mb2dcblx0XHRcdF0gKSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfZnJhZ1xuXG5cdFx0fSxcblxuXHRcdGxhbWJlcnQ6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIuZW52bWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5mb2csXG5cdFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfVxuXHRcdFx0XHR9XG5cdFx0XHRdICksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXG5cblx0XHR9LFxuXG5cdFx0cGhvbmc6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIuZW52bWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIuZ3JhZGllbnRtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxuXHRcdFx0XHRcdHNwZWN1bGFyOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MTExMTExICkgfSxcblx0XHRcdFx0XHRzaGluaW5lc3M6IHsgdmFsdWU6IDMwIH1cblx0XHRcdFx0fVxuXHRcdFx0XSApLFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ192ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXG5cblx0XHR9LFxuXG5cdFx0c3RhbmRhcmQ6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5lbnZtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5yb3VnaG5lc3NtYXAsXG5cdFx0XHRcdFVuaWZvcm1zTGliLm1ldGFsbmVzc21hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbWlzc2l2ZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRcdFx0cm91Z2huZXNzOiB7IHZhbHVlOiAwLjUgfSxcblx0XHRcdFx0XHRtZXRhbG5lc3M6IHsgdmFsdWU6IDAuNSB9LFxuXHRcdFx0XHRcdGVudk1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9IC8vIHRlbXBvcmFyeVxuXHRcdFx0XHR9XG5cdFx0XHRdICksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblxuXHRcdH0sXG5cblx0XHRwb2ludHM6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFx0VW5pZm9ybXNMaWIucG9pbnRzLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5mb2dcblx0XHRcdF0gKSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfZnJhZ1xuXG5cdFx0fSxcblxuXHRcdGRhc2hlZDoge1xuXG5cdFx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXHRcdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG5cdFx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNjYWxlOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRcdFx0ZGFzaFNpemU6IHsgdmFsdWU6IDEgfSxcblx0XHRcdFx0XHR0b3RhbFNpemU6IHsgdmFsdWU6IDIgfVxuXHRcdFx0XHR9XG5cdFx0XHRdICksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfZnJhZ1xuXG5cdFx0fSxcblxuXHRcdGRlcHRoOiB7XG5cblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cdFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwXG5cdFx0XHRdICksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF9mcmFnXG5cblx0XHR9LFxuXG5cdFx0bm9ybWFsOiB7XG5cblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cdFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcblx0XHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcblx0XHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxuXHRcdFx0XHR9XG5cdFx0XHRdICksXG5cblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubm9ybWFsX3ZlcnQsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubm9ybWFsX2ZyYWdcblxuXHRcdH0sXG5cblx0XHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHRcdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0XHRjdWJlOiB7XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdHRDdWJlOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRcdHRGbGlwOiB7IHZhbHVlOiAtIDEgfSxcblx0XHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cblx0XHRcdH0sXG5cblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfZnJhZ1xuXG5cdFx0fSxcblxuXHRcdGVxdWlyZWN0OiB7XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0fSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVJHQkE6IHtcblxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZWZlcmVuY2VQb3NpdGlvbjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKSB9LFxuXHRcdFx0XHRcdG5lYXJEaXN0YW5jZTogeyB2YWx1ZTogMSB9LFxuXHRcdFx0XHRcdGZhckRpc3RhbmNlOiB7IHZhbHVlOiAxMDAwIH1cblx0XHRcdFx0fVxuXHRcdFx0XSApLFxuXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV92ZXJ0LFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV9mcmFnXG5cblx0XHR9LFxuXG5cdFx0c2hhZG93OiB7XG5cblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cdFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcblx0XHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29sb3I6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMCApIH0sXG5cdFx0XHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cblx0XHRcdFx0fSxcblx0XHRcdF0gKSxcblxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfdmVydCxcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfZnJhZ1xuXG5cdFx0fVxuXG5cdH07XG5cblx0U2hhZGVyTGliLnBoeXNpY2FsID0ge1xuXG5cdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblx0XHRcdFNoYWRlckxpYi5zdGFuZGFyZC51bmlmb3Jtcyxcblx0XHRcdHtcblx0XHRcdFx0Y2xlYXJDb2F0OiB7IHZhbHVlOiAwIH0sXG5cdFx0XHRcdGNsZWFyQ29hdFJvdWdobmVzczogeyB2YWx1ZTogMCB9XG5cdFx0XHR9XG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBDYW52YXNUZXh0dXJlKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuXHRcdFRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRDYW52YXNUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XG5cdENhbnZhc1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzVGV4dHVyZTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xTcHJpdGVSZW5kZXJlciggcmVuZGVyZXIsIGdsLCBzdGF0ZSwgdGV4dHVyZXMsIGNhcGFiaWxpdGllcyApIHtcblxuXHRcdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XG5cdFx0dmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xuXG5cdFx0dmFyIHRleHR1cmU7XG5cblx0XHQvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcblxuXHRcdHZhciBzcHJpdGVQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHNwcml0ZVJvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHR2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gaW5pdCgpIHtcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXHRcdFx0XHQtIDAuNSwgLSAwLjUsIDAsIDAsXG5cdFx0XHRcdCAgMC41LCAtIDAuNSwgMSwgMCxcblx0XHRcdFx0ICAwLjUsIDAuNSwgMSwgMSxcblx0XHRcdFx0LSAwLjUsIDAuNSwgMCwgMVxuXHRcdFx0XSApO1xuXG5cdFx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcblx0XHRcdFx0MCwgMSwgMixcblx0XHRcdFx0MCwgMiwgM1xuXHRcdFx0XSApO1xuXG5cdFx0XHR2ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcblx0XHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cdFx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCk7XG5cblx0XHRcdGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHRcdHBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxuXHRcdFx0XHR1djogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICd1dicgKVxuXHRcdFx0fTtcblxuXHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdHV2T2Zmc2V0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dk9mZnNldCcgKSxcblx0XHRcdFx0dXZTY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZTY2FsZScgKSxcblxuXHRcdFx0XHRyb3RhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXG5cdFx0XHRcdGNlbnRlcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY2VudGVyJyApLFxuXHRcdFx0XHRzY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXG5cblx0XHRcdFx0Y29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxuXHRcdFx0XHRtYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcblx0XHRcdFx0b3BhY2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcblxuXHRcdFx0XHRtb2RlbFZpZXdNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcblx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcblxuXHRcdFx0XHRmb2dUeXBlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxuXHRcdFx0XHRmb2dEZW5zaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dEZW5zaXR5JyApLFxuXHRcdFx0XHRmb2dOZWFyOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxuXHRcdFx0XHRmb2dGYXI6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcblx0XHRcdFx0Zm9nQ29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0NvbG9yJyApLFxuXHRcdFx0XHRmb2dEZXB0aDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVwdGgnICksXG5cblx0XHRcdFx0YWxwaGFUZXN0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdhbHBoYVRlc3QnIClcblx0XHRcdH07XG5cblx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcblx0XHRcdGNhbnZhcy53aWR0aCA9IDg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gODtcblxuXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuXHRcdFx0Y29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xuXG5cdFx0XHR0ZXh0dXJlID0gbmV3IENhbnZhc1RleHR1cmUoIGNhbnZhcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNwcml0ZXMsIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cblx0XHRcdC8vIHNldHVwIGdsXG5cblx0XHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGluaXQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuXHRcdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cblx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcblxuXHRcdFx0dmFyIG9sZEZvZ1R5cGUgPSAwO1xuXHRcdFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XG5cdFx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG5cdFx0XHRpZiAoIGZvZyApIHtcblxuXHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cblx0XHRcdFx0aWYgKCBmb2cuaXNGb2cgKSB7XG5cblx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ05lYXIsIGZvZy5uZWFyICk7XG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuXHRcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xuXHRcdFx0XHRcdG9sZEZvZ1R5cGUgPSAxO1xuXHRcdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcblxuXHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRGVuc2l0eSwgZm9nLmRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuXHRcdFx0XHRcdG9sZEZvZ1R5cGUgPSAyO1xuXHRcdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xuXHRcdFx0XHRvbGRGb2dUeXBlID0gMDtcblx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMDtcblxuXHRcdFx0fVxuXG5cblx0XHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XG5cblx0XHRcdFx0c3ByaXRlLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcblx0XHRcdFx0c3ByaXRlLnogPSAtIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XG5cblx0XHRcdH1cblxuXHRcdFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG5cdFx0XHQvLyByZW5kZXIgYWxsIHNwcml0ZXNcblxuXHRcdFx0dmFyIHNjYWxlID0gW107XG5cdFx0XHR2YXIgY2VudGVyID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHNwcml0ZS5vbkJlZm9yZVJlbmRlciggcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIHVuZGVmaW5lZCwgbWF0ZXJpYWwsIHVuZGVmaW5lZCApO1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKTtcblx0XHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0XHRcdHNwcml0ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHNwcml0ZVBvc2l0aW9uLCBzcHJpdGVSb3RhdGlvbiwgc3ByaXRlU2NhbGUgKTtcblxuXHRcdFx0XHRzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcblx0XHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XG5cblx0XHRcdFx0Y2VudGVyWyAwIF0gPSBzcHJpdGUuY2VudGVyLnggLSAwLjU7XG5cdFx0XHRcdGNlbnRlclsgMSBdID0gc3ByaXRlLmNlbnRlci55IC0gMC41O1xuXG5cdFx0XHRcdHZhciBmb2dUeXBlID0gMDtcblxuXHRcdFx0XHRpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cblx0XHRcdFx0XHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XG5cblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcblx0XHRcdFx0XHRvbGRGb2dUeXBlID0gZm9nVHlwZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xuXHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgbWF0ZXJpYWwubWFwLnJlcGVhdC54LCBtYXRlcmlhbC5tYXAucmVwZWF0LnkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xuXHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgMSwgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgbWF0ZXJpYWwuY29sb3IuciwgbWF0ZXJpYWwuY29sb3IuZywgbWF0ZXJpYWwuY29sb3IuYiApO1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG5cdFx0XHRcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLmNlbnRlciwgY2VudGVyICk7XG5cdFx0XHRcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xuXG5cdFx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApO1xuXHRcdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuXHRcdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblx0XHRcdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XG5cblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCBtYXRlcmlhbC5tYXAgfHwgdGV4dHVyZSwgMCApO1xuXG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cdFx0XHRcdHNwcml0ZS5vbkFmdGVyUmVuZGVyKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgdW5kZWZpbmVkLCBtYXRlcmlhbCwgdW5kZWZpbmVkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzdG9yZSBnbFxuXG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0XHRzdGF0ZS5yZXNldCgpO1xuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oKSB7XG5cblx0XHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cdFx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuXG5cdFx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xuXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIGNhcGFiaWxpdGllcy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXG5cblx0XHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArICdTcHJpdGVNYXRlcmlhbCcsXG5cblx0XHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7Jyxcblx0XHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG5cdFx0XHRcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzIgY2VudGVyOycsXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7Jyxcblx0XHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxuXHRcdFx0XHQndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcblxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247Jyxcblx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cblx0XHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7Jyxcblx0XHRcdFx0J3ZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7JyxcblxuXHRcdFx0XHQndm9pZCBtYWluKCkgeycsXG5cblx0XHRcdFx0J1x0dlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcblxuXHRcdFx0XHQnXHR2ZWMyIGFsaWduZWRQb3NpdGlvbiA9ICggcG9zaXRpb24gLSBjZW50ZXIgKSAqIHNjYWxlOycsXG5cblx0XHRcdFx0J1x0dmVjMiByb3RhdGVkUG9zaXRpb247Jyxcblx0XHRcdFx0J1x0cm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG5cdFx0XHRcdCdcdHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuXG5cdFx0XHRcdCdcdHZlYzQgbXZQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdCdcdG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxuXHRcdFx0XHQnXHRtdlBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdCdcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247JyxcblxuXHRcdFx0XHQnXHRmb2dEZXB0aCA9IC0gbXZQb3NpdGlvbi56OycsXG5cblx0XHRcdFx0J30nXG5cblx0XHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBbXG5cblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgY2FwYWJpbGl0aWVzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcblxuXHRcdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgJ1Nwcml0ZU1hdGVyaWFsJyxcblxuXHRcdFx0XHQndW5pZm9ybSB2ZWMzIGNvbG9yOycsXG5cdFx0XHRcdCd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7Jyxcblx0XHRcdFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxuXG5cdFx0XHRcdCd1bmlmb3JtIGludCBmb2dUeXBlOycsXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzMgZm9nQ29sb3I7Jyxcblx0XHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTsnLFxuXHRcdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dOZWFyOycsXG5cdFx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsnLFxuXHRcdFx0XHQndW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7JyxcblxuXHRcdFx0XHQndmFyeWluZyB2ZWMyIHZVVjsnLFxuXHRcdFx0XHQndmFyeWluZyBmbG9hdCBmb2dEZXB0aDsnLFxuXG5cdFx0XHRcdCd2b2lkIG1haW4oKSB7JyxcblxuXHRcdFx0XHQnXHR2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcblxuXHRcdFx0XHQnXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcblxuXHRcdFx0XHQnXHRpZiAoIGdsX0ZyYWdDb2xvci5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxuXG5cdFx0XHRcdCdcdGlmICggZm9nVHlwZSA+IDAgKSB7JyxcblxuXHRcdFx0XHQnXHRcdGZsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxuXG5cdFx0XHRcdCdcdFx0aWYgKCBmb2dUeXBlID09IDEgKSB7JyxcblxuXHRcdFx0XHQnXHRcdFx0Zm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBmb2dEZXB0aCApOycsXG5cblx0XHRcdFx0J1x0XHR9IGVsc2UgeycsXG5cblx0XHRcdFx0J1x0XHRcdGNvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxuXHRcdFx0XHQnXHRcdFx0Zm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGZvZ0RlcHRoICogZm9nRGVwdGggKiBMT0cyICk7Jyxcblx0XHRcdFx0J1x0XHRcdGZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcblxuXHRcdFx0XHQnXHRcdH0nLFxuXG5cdFx0XHRcdCdcdFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApOycsXG5cblx0XHRcdFx0J1x0fScsXG5cblx0XHRcdFx0J30nXG5cblx0XHRcdF0uam9pbiggJ1xcbicgKSApO1xuXG5cdFx0XHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcblx0XHRcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cdFx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cblx0XHRcdGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcblxuXHRcdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG5cdFx0XHRcdHJldHVybiBiLnogLSBhLno7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGIuaWQgLSBhLmlkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHR2YXIgbWF0ZXJpYWxJZCA9IDA7XG5cblx0ZnVuY3Rpb24gTWF0ZXJpYWwoKSB7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IG1hdGVyaWFsSWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xuXHRcdHRoaXMubGlnaHRzID0gdHJ1ZTtcblxuXHRcdHRoaXMuYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcblx0XHR0aGlzLnNpZGUgPSBGcm9udFNpZGU7XG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gTm9Db2xvcnM7IC8vIFRIUkVFLk5vQ29sb3JzLCBUSFJFRS5WZXJ0ZXhDb2xvcnMsIFRIUkVFLkZhY2VDb2xvcnNcblxuXHRcdHRoaXMub3BhY2l0eSA9IDE7XG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5ibGVuZFNyYyA9IFNyY0FscGhhRmFjdG9yO1xuXHRcdHRoaXMuYmxlbmREc3QgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xuXHRcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuXHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcblx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cblx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xuXHRcdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcblx0XHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IG51bGw7XG5cdFx0dGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zaGFkb3dTaWRlID0gbnVsbDtcblxuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cblx0XHR0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXG5cblx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcblxuXHRcdHRoaXMuZGl0aGVyaW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmFscGhhVGVzdCA9IDA7XG5cdFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBmYWxzZTtcblxuXHRcdHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG5cdE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IE1hdGVyaWFsLFxuXG5cdFx0aXNNYXRlcmlhbDogdHJ1ZSxcblxuXHRcdG9uQmVmb3JlQ29tcGlsZTogZnVuY3Rpb24gKCkge30sXG5cblx0XHRzZXRWYWx1ZXM6IGZ1bmN0aW9uICggdmFsdWVzICkge1xuXG5cdFx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0XHR2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xuXG5cdFx0XHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZm9yIGJhY2t3YXJkIGNvbXBhdGFiaWxpdHkgaWYgc2hhZGluZyBpcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG5cdFx0XHRcdGlmICgga2V5ID09PSAnc2hhZGluZycgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLnNoYWRpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHRoZSBib29sZWFuIC5mbGF0U2hhZGluZyBpbnN0ZWFkLicgKTtcblx0XHRcdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gKCBuZXdWYWx1ZSA9PT0gRmxhdFNoYWRpbmcgKSA/IHRydWUgOiBmYWxzZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xuXG5cdFx0XHRcdGlmICggY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuXCIgKyB0aGlzLnR5cGUgKyBcIjogJ1wiICsga2V5ICsgXCInIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoaXMgbWF0ZXJpYWwuXCIgKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzQ29sb3IgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc1ZlY3RvcjMgKSAmJiAoIG5ld1ZhbHVlICYmIG5ld1ZhbHVlLmlzVmVjdG9yMyApICkge1xuXG5cdFx0XHRcdFx0Y3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xuXG5cdFx0XHRcdFx0Ly8gZW5zdXJlIG92ZXJkcmF3IGlzIGJhY2t3YXJkcy1jb21wYXRpYmxlIHdpdGggbGVnYWN5IGJvb2xlYW4gdHlwZVxuXHRcdFx0XHRcdHRoaXNbIGtleSBdID0gTnVtYmVyKCBuZXdWYWx1ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0XHR2YXIgaXNSb290ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRcdGlmICggaXNSb290ICkge1xuXG5cdFx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRcdGltYWdlczoge31cblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bWV0YWRhdGE6IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ01hdGVyaWFsJyxcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0XHRpZiAoIHRoaXMuY29sb3IgJiYgdGhpcy5jb2xvci5pc0NvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG5cblx0XHRcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XG5cdFx0XHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xuXG5cdFx0XHRpZiAoIHRoaXMuZW1pc3NpdmUgJiYgdGhpcy5lbWlzc2l2ZS5pc0NvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XG5cdFx0XHRpZiAoIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IDEgKSBkYXRhLmVtaXNzaXZlSW50ZW5zaXR5ID0gdGhpcy5lbWlzc2l2ZUludGVuc2l0eTtcblxuXHRcdFx0aWYgKCB0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuXHRcdFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcblx0XHRcdGlmICggdGhpcy5jbGVhckNvYXQgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJDb2F0ID0gdGhpcy5jbGVhckNvYXQ7XG5cdFx0XHRpZiAoIHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLmNsZWFyQ29hdFJvdWdobmVzcyA9IHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzO1xuXG5cdFx0XHRpZiAoIHRoaXMubWFwICYmIHRoaXMubWFwLmlzVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGlmICggdGhpcy5hbHBoYU1hcCAmJiB0aGlzLmFscGhhTWFwLmlzVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRpZiAoIHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUgKSBkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0aWYgKCB0aGlzLmJ1bXBNYXAgJiYgdGhpcy5idW1wTWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdFx0ZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcblxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUgKSB7XG5cblx0XHRcdFx0ZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0XHRkYXRhLm5vcm1hbFNjYWxlID0gdGhpcy5ub3JtYWxTY2FsZS50b0FycmF5KCk7XG5cblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgJiYgdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLnJvdWdobmVzc01hcCA9IHRoaXMucm91Z2huZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRpZiAoIHRoaXMubWV0YWxuZXNzTWFwICYmIHRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSApIGRhdGEubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdFx0aWYgKCB0aGlzLmVtaXNzaXZlTWFwICYmIHRoaXMuZW1pc3NpdmVNYXAuaXNUZXh0dXJlICkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGlmICggdGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdGlmICggdGhpcy5lbnZNYXAgJiYgdGhpcy5lbnZNYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdFx0ZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5ncmFkaWVudE1hcCAmJiB0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XG5cdFx0XHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IE5vcm1hbEJsZW5kaW5nICkgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG5cdFx0XHRpZiAoIHRoaXMuZmxhdFNoYWRpbmcgPT09IHRydWUgKSBkYXRhLmZsYXRTaGFkaW5nID0gdGhpcy5mbGF0U2hhZGluZztcblx0XHRcdGlmICggdGhpcy5zaWRlICE9PSBGcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG5cdFx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSBOb0NvbG9ycyApIGRhdGEudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblx0XHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xuXG5cdFx0XHRkYXRhLmRlcHRoRnVuYyA9IHRoaXMuZGVwdGhGdW5jO1xuXHRcdFx0ZGF0YS5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcblx0XHRcdGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblxuXHRcdFx0Ly8gcm90YXRpb24gKFNwcml0ZU1hdGVyaWFsKVxuXHRcdFx0aWYgKCB0aGlzLnJvdGF0aW9uICE9PSAwICkgZGF0YS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG5cblx0XHRcdGlmICggdGhpcy5saW5ld2lkdGggIT09IDEgKSBkYXRhLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xuXHRcdFx0aWYgKCB0aGlzLmRhc2hTaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLmRhc2hTaXplID0gdGhpcy5kYXNoU2l6ZTtcblx0XHRcdGlmICggdGhpcy5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cdFx0XHRpZiAoIHRoaXMuc2NhbGUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG5cdFx0XHRpZiAoIHRoaXMuZGl0aGVyaW5nID09PSB0cnVlICkgZGF0YS5kaXRoZXJpbmcgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG5cdFx0XHRpZiAoIHRoaXMucHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkgZGF0YS5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0aGlzLnByZW11bHRpcGxpZWRBbHBoYTtcblxuXHRcdFx0aWYgKCB0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSApIGRhdGEud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cdFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID4gMSApIGRhdGEud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZWNhcCAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcblx0XHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lam9pbiAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZGF0YS5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXHRcdFx0aWYgKCB0aGlzLnNraW5uaW5nID09PSB0cnVlICkgZGF0YS5za2lubmluZyA9IHRydWU7XG5cblx0XHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIGRhdGEudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRcdC8vIFRPRE86IENvcGllZCBmcm9tIE9iamVjdDNELnRvSlNPTlxuXG5cdFx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc1Jvb3QgKSB7XG5cblx0XHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBkYXRhLnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBkYXRhLmltYWdlcyA9IGltYWdlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cdFx0XHR0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XG5cblx0XHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XG5cdFx0XHR0aGlzLnNpZGUgPSBzb3VyY2Uuc2lkZTtcblx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG5cdFx0XHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xuXHRcdFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcblxuXHRcdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcblx0XHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcblx0XHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xuXHRcdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG5cdFx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cblx0XHRcdHRoaXMuZGVwdGhGdW5jID0gc291cmNlLmRlcHRoRnVuYztcblx0XHRcdHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcblx0XHRcdHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuXG5cdFx0XHR0aGlzLmNvbG9yV3JpdGUgPSBzb3VyY2UuY29sb3JXcml0ZTtcblxuXHRcdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xuXG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcblx0XHRcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuXHRcdFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzb3VyY2UucG9seWdvbk9mZnNldFVuaXRzO1xuXG5cdFx0XHR0aGlzLmRpdGhlcmluZyA9IHNvdXJjZS5kaXRoZXJpbmc7XG5cblx0XHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcblx0XHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcblxuXHRcdFx0dGhpcy5vdmVyZHJhdyA9IHNvdXJjZS5vdmVyZHJhdztcblxuXHRcdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cdFx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XG5cblx0XHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBzb3VyY2UuY2xpcFNoYWRvd3M7XG5cdFx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcblxuXHRcdFx0dmFyIHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcyxcblx0XHRcdFx0ZHN0UGxhbmVzID0gbnVsbDtcblxuXHRcdFx0aWYgKCBzcmNQbGFuZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dmFyIG4gPSBzcmNQbGFuZXMubGVuZ3RoO1xuXHRcdFx0XHRkc3RQbGFuZXMgPSBuZXcgQXJyYXkoIG4gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxuXHRcdFx0XHRcdGRzdFBsYW5lc1sgaSBdID0gc3JjUGxhbmVzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gZHN0UGxhbmVzO1xuXG5cdFx0XHR0aGlzLnNoYWRvd1NpZGUgPSBzb3VyY2Uuc2hhZG93U2lkZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwczovL2NsYXJhLmlvXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlxuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cblx0ICogfVxuXHQgKi9cblxuXHRmdW5jdGlvbiBNZXNoRGVwdGhNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLmZvZyA9IGZhbHNlO1xuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaERlcHRoTWF0ZXJpYWw7XG5cblx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcblxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKlxuXHQgKiAgcmVmZXJlbmNlUG9zaXRpb246IDxmbG9hdD4sXG5cdCAqICBuZWFyRGlzdGFuY2U6IDxmbG9hdD4sXG5cdCAqICBmYXJEaXN0YW5jZTogPGZsb2F0Pixcblx0ICpcblx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXG5cdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcblx0ICpcblx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+XG5cdCAqXG5cdCAqIH1cblx0ICovXG5cblx0ZnVuY3Rpb24gTWVzaERpc3RhbmNlTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaERpc3RhbmNlTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5yZWZlcmVuY2VQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5uZWFyRGlzdGFuY2UgPSAxO1xuXHRcdHRoaXMuZmFyRGlzdGFuY2UgPSAxMDAwO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5mb2cgPSBmYWxzZTtcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0TWVzaERpc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hEaXN0YW5jZU1hdGVyaWFsO1xuXG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID0gdHJ1ZTtcblxuXHRNZXNoRGlzdGFuY2VNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLnJlZmVyZW5jZVBvc2l0aW9uLmNvcHkoIHNvdXJjZS5yZWZlcmVuY2VQb3NpdGlvbiApO1xuXHRcdHRoaXMubmVhckRpc3RhbmNlID0gc291cmNlLm5lYXJEaXN0YW5jZTtcblx0XHR0aGlzLmZhckRpc3RhbmNlID0gc291cmNlLmZhckRpc3RhbmNlO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKi9cblxuXHRmdW5jdGlvbiBCb3gzKCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcblx0XHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIEJveDMucHJvdG90eXBlLCB7XG5cblx0XHRpc0JveDM6IHRydWUsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xuXHRcdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xuXHRcdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xuXG5cdFx0XHR2YXIgbWF4WCA9IC0gSW5maW5pdHk7XG5cdFx0XHR2YXIgbWF4WSA9IC0gSW5maW5pdHk7XG5cdFx0XHR2YXIgbWF4WiA9IC0gSW5maW5pdHk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2YXIgeCA9IGFycmF5WyBpIF07XG5cdFx0XHRcdHZhciB5ID0gYXJyYXlbIGkgKyAxIF07XG5cdFx0XHRcdHZhciB6ID0gYXJyYXlbIGkgKyAyIF07XG5cblx0XHRcdFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xuXHRcdFx0XHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XG5cdFx0XHRcdGlmICggeiA8IG1pblogKSBtaW5aID0gejtcblxuXHRcdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XG5cdFx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcblx0XHRcdFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWluLnNldCggbWluWCwgbWluWSwgbWluWiApO1xuXHRcdFx0dGhpcy5tYXguc2V0KCBtYXhYLCBtYXhZLCBtYXhaICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlICkge1xuXG5cdFx0XHR2YXIgbWluWCA9ICsgSW5maW5pdHk7XG5cdFx0XHR2YXIgbWluWSA9ICsgSW5maW5pdHk7XG5cdFx0XHR2YXIgbWluWiA9ICsgSW5maW5pdHk7XG5cblx0XHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcblx0XHRcdHZhciBtYXhZID0gLSBJbmZpbml0eTtcblx0XHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgeCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XG5cdFx0XHRcdHZhciB5ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcblx0XHRcdFx0dmFyIHogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xuXG5cdFx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcblx0XHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xuXHRcdFx0XHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XG5cblx0XHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xuXHRcdFx0XHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XG5cdFx0XHRcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcblx0XHRcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG5cdFx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5leHBhbmRCeU9iamVjdCggb2JqZWN0ICk7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xuXHRcdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG5cdFx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAsIDAgKSA6IHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cblx0XHR9LFxuXG5cdFx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuXHRcdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcblx0XHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGV4cGFuZEJ5T2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG5cdFx0XHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuXHRcdFx0dmFyIHNjb3BlLCBpLCBsO1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmdW5jdGlvbiB0cmF2ZXJzZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2MS5jb3B5KCB2ZXJ0aWNlc1sgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0XHRcdHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaSApLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGV4cGFuZEJ5T2JqZWN0KCBvYmplY3QgKSB7XG5cblx0XHRcdFx0c2NvcGUgPSB0aGlzO1xuXG5cdFx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRcdG9iamVjdC50cmF2ZXJzZSggdHJhdmVyc2UgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0XHRwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0XHR0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueSAmJlxuXHRcdFx0XHR0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcblxuXHRcdH0sXG5cblx0XHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcblx0XHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXG5cdFx0XHQpO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblx0XHRcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcblx0XHRcdFx0Ym94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XG5cdFx0XHRcdGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHRcdFx0dGhpcy5jbGFtcFBvaW50KCBzcGhlcmUuY2VudGVyLCBjbG9zZXN0UG9pbnQgKTtcblxuXHRcdFx0XHQvLyBJZiB0aGF0IHBvaW50IGlzIGluc2lkZSB0aGUgc3BoZXJlLCB0aGUgQUFCQiBhbmQgc3BoZXJlIGludGVyc2VjdC5cblx0XHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggc3BoZXJlLmNlbnRlciApIDw9ICggc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXMgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0gKSgpLFxuXG5cdFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXG5cdFx0XHQvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cblxuXHRcdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0XHRpZiAoIHBsYW5lLm5vcm1hbC54ID4gMCApIHtcblxuXHRcdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XG5cdFx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWF4Lng7XG5cdFx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBsYW5lLm5vcm1hbC55ID4gMCApIHtcblxuXHRcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcblx0XHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXHRcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIG1pbiA8PSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gcGxhbmUuY29uc3RhbnQgKTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyB0cmlhbmdsZSBjZW50ZXJlZCB2ZXJ0aWNlc1xuXHRcdFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyB0cmlhbmdsZSBlZGdlIHZlY3RvcnNcblx0XHRcdHZhciBmMCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgZjEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIGYyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIHRlc3RBeGlzID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgZXh0ZW50cyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHZhciB0cmlhbmdsZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZ1bmN0aW9uIHNhdEZvckF4ZXMoIGF4ZXMgKSB7XG5cblx0XHRcdFx0dmFyIGksIGo7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGogPSBheGVzLmxlbmd0aCAtIDM7IGkgPD0gajsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0dGVzdEF4aXMuZnJvbUFycmF5KCBheGVzLCBpICk7XG5cdFx0XHRcdFx0Ly8gcHJvamVjdCB0aGUgYWFiYiBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcblx0XHRcdFx0XHR2YXIgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCB0ZXN0QXhpcy54ICkgKyBleHRlbnRzLnkgKiBNYXRoLmFicyggdGVzdEF4aXMueSApICsgZXh0ZW50cy56ICogTWF0aC5hYnMoIHRlc3RBeGlzLnogKTtcblx0XHRcdFx0XHQvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBlcmF0aW5nIGF4aXNcblx0XHRcdFx0XHR2YXIgcDAgPSB2MC5kb3QoIHRlc3RBeGlzICk7XG5cdFx0XHRcdFx0dmFyIHAxID0gdjEuZG90KCB0ZXN0QXhpcyApO1xuXHRcdFx0XHRcdHZhciBwMiA9IHYyLmRvdCggdGVzdEF4aXMgKTtcblx0XHRcdFx0XHQvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxuXHRcdFx0XHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcG9pbnRzIG9mIHRoZSBwcm9qZWN0ZWQgdHJpYW5nbGUgYXJlIG91dHNpZGUgdGhlIHByb2plY3RlZCBoYWxmLWxlbmd0aCBvZiB0aGUgYWFiYlxuXHRcdFx0XHRcdFx0Ly8gdGhlIGF4aXMgaXMgc2VwZXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSBib3ggY2VudGVyIGFuZCBleHRlbnRzXG5cdFx0XHRcdHRoaXMuZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblx0XHRcdFx0ZXh0ZW50cy5zdWJWZWN0b3JzKCB0aGlzLm1heCwgY2VudGVyICk7XG5cblx0XHRcdFx0Ly8gdHJhbnNsYXRlIHRyaWFuZ2xlIHRvIGFhYmIgb3JpZ2luXG5cdFx0XHRcdHYwLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmEsIGNlbnRlciApO1xuXHRcdFx0XHR2MS5zdWJWZWN0b3JzKCB0cmlhbmdsZS5iLCBjZW50ZXIgKTtcblx0XHRcdFx0djIuc3ViVmVjdG9ycyggdHJpYW5nbGUuYywgY2VudGVyICk7XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSBlZGdlIHZlY3RvcnMgZm9yIHRyaWFuZ2xlXG5cdFx0XHRcdGYwLnN1YlZlY3RvcnMoIHYxLCB2MCApO1xuXHRcdFx0XHRmMS5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcblx0XHRcdFx0ZjIuc3ViVmVjdG9ycyggdjAsIHYyICk7XG5cblx0XHRcdFx0Ly8gdGVzdCBhZ2FpbnN0IGF4ZXMgdGhhdCBhcmUgZ2l2ZW4gYnkgY3Jvc3MgcHJvZHVjdCBjb21iaW5hdGlvbnMgb2YgdGhlIGVkZ2VzIG9mIHRoZSB0cmlhbmdsZSBhbmQgdGhlIGVkZ2VzIG9mIHRoZSBhYWJiXG5cdFx0XHRcdC8vIG1ha2UgYW4gYXhpcyB0ZXN0aW5nIG9mIGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIGFhYmIgYWdhaW5zdCBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSB0cmlhbmdsZSA9IDkgYXhpcyBvZiBzZXBhcmF0aW9uXG5cdFx0XHRcdC8vIGF4aXNfaWogPSB1X2kgeCBmX2ogKHUwLCB1MSwgdTIgPSBmYWNlIG5vcm1hbHMgb2YgYWFiYiA9IHgseSx6IGF4ZXMgdmVjdG9ycyBzaW5jZSBhYWJiIGlzIGF4aXMgYWxpZ25lZClcblx0XHRcdFx0dmFyIGF4ZXMgPSBbXG5cdFx0XHRcdFx0MCwgLSBmMC56LCBmMC55LCAwLCAtIGYxLnosIGYxLnksIDAsIC0gZjIueiwgZjIueSxcblx0XHRcdFx0XHRmMC56LCAwLCAtIGYwLngsIGYxLnosIDAsIC0gZjEueCwgZjIueiwgMCwgLSBmMi54LFxuXHRcdFx0XHRcdC0gZjAueSwgZjAueCwgMCwgLSBmMS55LCBmMS54LCAwLCAtIGYyLnksIGYyLngsIDBcblx0XHRcdFx0XTtcblx0XHRcdFx0aWYgKCAhIHNhdEZvckF4ZXMoIGF4ZXMgKSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cdFx0XHRcdGF4ZXMgPSBbIDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEgXTtcblx0XHRcdFx0aWYgKCAhIHNhdEZvckF4ZXMoIGF4ZXMgKSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZmluYWxseSB0ZXN0aW5nIHRoZSBmYWNlIG5vcm1hbCBvZiB0aGUgdHJpYW5nbGVcblx0XHRcdFx0Ly8gdXNlIGFscmVhZHkgZXhpc3RpbmcgdHJpYW5nbGUgZWRnZSB2ZWN0b3JzIGhlcmVcblx0XHRcdFx0dHJpYW5nbGVOb3JtYWwuY3Jvc3NWZWN0b3JzKCBmMCwgZjEgKTtcblx0XHRcdFx0YXhlcyA9IFsgdHJpYW5nbGVOb3JtYWwueCwgdHJpYW5nbGVOb3JtYWwueSwgdHJpYW5nbGVOb3JtYWwueiBdO1xuXHRcdFx0XHRyZXR1cm4gc2F0Rm9yQXhlcyggYXhlcyApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSApKCksXG5cblx0XHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cdFx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Z2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEJvdW5kaW5nU3BoZXJlKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFNwaGVyZSgpO1xuXG5cdFx0XHRcdHRoaXMuZ2V0Q2VudGVyKCByZXN1bHQuY2VudGVyICk7XG5cblx0XHRcdFx0cmVzdWx0LnJhZGl1cyA9IHRoaXMuZ2V0U2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcCwgdGhlIHJlc3VsdCBpcyBmdWxseSBlbXB0eSwgbm90IHNsaWdodGx5IGVtcHR5IHdpdGggbm9uLWluZi8raW5mIHZhbHVlcyB0aGF0IHdpbGwgY2F1c2Ugc3Vic2VxdWVuY2UgaW50ZXJzZWN0cyB0byBlcnJvbmVvdXNseSByZXR1cm4gdmFsaWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBwb2ludHMgPSBbXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IzKClcblx0XHRcdF07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdFx0XHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cblx0XHRcdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG5cdFx0XHRcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdFx0XHRwb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcblx0XHRcdFx0cG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG5cdFx0XHRcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdFx0XHRwb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcblx0XHRcdFx0cG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG5cdFx0XHRcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdFx0XHRwb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1x0Ly8gMTExXG5cblx0XHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cblx0XHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG5cdFx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFNwaGVyZSggY2VudGVyLCByYWRpdXMgKSB7XG5cblx0XHR0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBTcGhlcmUucHJvdG90eXBlLCB7XG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tUG9pbnRzKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xuXG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuXHRcdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtYXhSYWRpdXNTcSA9IDA7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcblx0XHRcdHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPD0gMCApO1xuXG5cdFx0fSxcblxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cblx0XHR9LFxuXG5cdFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdFx0dmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcblxuXHRcdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xuXG5cdFx0fSxcblxuXHRcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmVzdWx0LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG5cdFx0XHRcdHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH0sXG5cblx0XHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBCb3gzKCk7XG5cblx0XHRcdGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuXHRcdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG5cdFx0XHRyZXR1cm4gYm94O1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0XHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cblx0XHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFBsYW5lKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggUGxhbmUucHJvdG90eXBlLCB7XG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHRcdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldENvbXBvbmVudHM6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuXHRcdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcblxuXHRcdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG5cdFx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Db3BsYW5hclBvaW50cyggYSwgYiwgYyApIHtcblxuXHRcdFx0XHR2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHQvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xuXG5cdFx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuXHRcdFx0dGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXG5cblx0XHRcdHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG5cdFx0XHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xuXHRcdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5jb25zdGFudCAqPSAtIDE7XG5cdFx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWwuZG90KCBwb2ludCApICsgdGhpcy5jb25zdGFudDtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgLSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0fSxcblxuXHRcdHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgKS5hZGQoIHBvaW50ICk7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0TGluZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0TGluZSggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0dmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XG5cblx0XHRcdFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcblxuXHRcdFx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0XHRcdGlmICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0XHRcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRpbnRlcnNlY3RzTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cblxuXHRcdFx0dmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG5cdFx0XHR2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xuXG5cdFx0XHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHJldHVybiBib3guaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRcdHJldHVybiBzcGhlcmUuaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XG5cblx0XHR9LFxuXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgbTEgPSBuZXcgTWF0cml4MygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlNYXRyaXg0KCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xuXG5cdFx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBtMS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRcdHZhciByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjEgKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHRcdHZhciBub3JtYWwgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdHRoaXMuY29uc3RhbnQgPSAtIHJlZmVyZW5jZVBvaW50LmRvdCggbm9ybWFsICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0XHR0aGlzLmNvbnN0YW50IC09IG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKi9cblxuXHRmdW5jdGlvbiBGcnVzdHVtKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdFx0dGhpcy5wbGFuZXMgPSBbXG5cblx0XHRcdCggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgUGxhbmUoKSxcblx0XHRcdCggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgUGxhbmUoKSxcblx0XHRcdCggcDIgIT09IHVuZGVmaW5lZCApID8gcDIgOiBuZXcgUGxhbmUoKSxcblx0XHRcdCggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgUGxhbmUoKSxcblx0XHRcdCggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgUGxhbmUoKSxcblx0XHRcdCggcDUgIT09IHVuZGVmaW5lZCApID8gcDUgOiBuZXcgUGxhbmUoKVxuXG5cdFx0XTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggRnJ1c3R1bS5wcm90b3R5cGUsIHtcblxuXHRcdHNldDogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG5cdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRcdHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XG5cdFx0XHRwbGFuZXNbIDEgXS5jb3B5KCBwMSApO1xuXHRcdFx0cGxhbmVzWyAyIF0uY29weSggcDIgKTtcblx0XHRcdHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XG5cdFx0XHRwbGFuZXNbIDQgXS5jb3B5KCBwNCApO1xuXHRcdFx0cGxhbmVzWyA1IF0uY29weSggcDUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggZnJ1c3R1bSApIHtcblxuXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdHBsYW5lc1sgaSBdLmNvcHkoIGZydXN0dW0ucGxhbmVzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cdFx0XHR2YXIgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcblx0XHRcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xuXHRcdFx0dmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xuXHRcdFx0dmFyIG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcblxuXHRcdFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XG5cdFx0XHRwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRcdHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XG5cdFx0XHRwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XG5cdFx0XHRwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdHNPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNPYmplY3QoIG9iamVjdCApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXG5cdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlIClcblx0XHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGludGVyc2VjdHNTcHJpdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNTcHJpdGUoIHNwcml0ZSApIHtcblxuXHRcdFx0XHRzcGhlcmUuY2VudGVyLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRzcGhlcmUucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2O1xuXHRcdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cdFx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcblx0XHRcdHZhciBuZWdSYWRpdXMgPSAtIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBwMSA9IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdHAyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNCb3goIGJveCApIHtcblxuXHRcdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBwbGFuZSA9IHBsYW5lc1sgaSBdO1xuXG5cdFx0XHRcdFx0cDEueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5taW4ueCA6IGJveC5tYXgueDtcblx0XHRcdFx0XHRwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuXHRcdFx0XHRcdHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XG5cdFx0XHRcdFx0cDIueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcblx0XHRcdFx0XHRwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xuXHRcdFx0XHRcdHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XG5cblx0XHRcdFx0XHR2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XG5cdFx0XHRcdFx0dmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xuXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBvdXRzaWRlIHBsYW5lLCBubyBpbnRlcnNlY3Rpb25cblxuXHRcdFx0XHRcdGlmICggZDEgPCAwICYmIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xTaGFkb3dNYXAoIF9yZW5kZXJlciwgX29iamVjdHMsIG1heFRleHR1cmVTaXplICkge1xuXG5cdFx0dmFyIF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKSxcblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKSxcblxuXHRcdFx0X3NoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0X21heFNoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMiggbWF4VGV4dHVyZVNpemUsIG1heFRleHR1cmVTaXplICksXG5cblx0XHRcdF9sb29rVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSxcblx0XHRcdF9saWdodFBvc2l0aW9uV29ybGQgPSBuZXcgVmVjdG9yMygpLFxuXG5cdFx0XHRfTW9ycGhpbmdGbGFnID0gMSxcblx0XHRcdF9Ta2lubmluZ0ZsYWcgPSAyLFxuXG5cdFx0XHRfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzID0gKCBfTW9ycGhpbmdGbGFnIHwgX1NraW5uaW5nRmxhZyApICsgMSxcblxuXHRcdFx0X2RlcHRoTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXG5cdFx0XHRfZGlzdGFuY2VNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcblxuXHRcdFx0X21hdGVyaWFsQ2FjaGUgPSB7fTtcblxuXHRcdHZhciBzaGFkb3dTaWRlID0geyAwOiBCYWNrU2lkZSwgMTogRnJvbnRTaWRlLCAyOiBEb3VibGVTaWRlIH07XG5cblx0XHR2YXIgY3ViZURpcmVjdGlvbnMgPSBbXG5cdFx0XHRuZXcgVmVjdG9yMyggMSwgMCwgMCApLCBuZXcgVmVjdG9yMyggLSAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAwLCAwLCAxICksXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMCwgLSAxICksIG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAtIDEsIDAgKVxuXHRcdF07XG5cblx0XHR2YXIgY3ViZVVwcyA9IFtcblx0XHRcdG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAxLCAwICksXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApXG5cdFx0XTtcblxuXHRcdHZhciBjdWJlMkRWaWV3UG9ydHMgPSBbXG5cdFx0XHRuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLFxuXHRcdFx0bmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKVxuXHRcdF07XG5cblx0XHQvLyBpbml0XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHM7ICsrIGkgKSB7XG5cblx0XHRcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcblx0XHRcdHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcblxuXHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoIHtcblxuXHRcdFx0XHRkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcsXG5cblx0XHRcdFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcblx0XHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXG5cblx0XHRcdH0gKTtcblxuXHRcdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgge1xuXG5cdFx0XHRcdG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXG5cdFx0XHRcdHNraW5uaW5nOiB1c2VTa2lubmluZ1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdF9kaXN0YW5jZU1hdGVyaWFsc1sgaSBdID0gZGlzdGFuY2VNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMudHlwZSA9IFBDRlNoYWRvd01hcDtcblxuXHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBsaWdodHMsIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0XHRpZiAoIHNjb3BlLmF1dG9VcGRhdGUgPT09IGZhbHNlICYmIHNjb3BlLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0aWYgKCBsaWdodHMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0XHQvLyBUT0RPIENsZWFuIHVwIChuZWVkZWQgaW4gY2FzZSBvZiBjb250ZXh0bG9zdClcblx0XHRcdHZhciBfZ2wgPSBfcmVuZGVyZXIuY29udGV4dDtcblx0XHRcdHZhciBfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGU7XG5cblx0XHRcdC8vIFNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwLlxuXHRcdFx0X3N0YXRlLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXHRcdFx0X3N0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIDEsIDEsIDEsIDEgKTtcblx0XHRcdF9zdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIHRydWUgKTtcblx0XHRcdF9zdGF0ZS5zZXRTY2lzc29yVGVzdCggZmFsc2UgKTtcblxuXHRcdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxuXG5cdFx0XHR2YXIgZmFjZUNvdW50O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXHRcdFx0XHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXHRcdFx0XHR2YXIgaXNQb2ludExpZ2h0ID0gbGlnaHQgJiYgbGlnaHQuaXNQb2ludExpZ2h0O1xuXG5cdFx0XHRcdGlmICggc2hhZG93ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRvd01hcDonLCBsaWdodCwgJ2hhcyBubyBzaGFkb3cuJyApO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgc2hhZG93Q2FtZXJhID0gc2hhZG93LmNhbWVyYTtcblxuXHRcdFx0XHRfc2hhZG93TWFwU2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xuXHRcdFx0XHRfc2hhZG93TWFwU2l6ZS5taW4oIF9tYXhTaGFkb3dNYXBTaXplICk7XG5cblx0XHRcdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0XHR2YXIgdnBXaWR0aCA9IF9zaGFkb3dNYXBTaXplLng7XG5cdFx0XHRcdFx0dmFyIHZwSGVpZ2h0ID0gX3NoYWRvd01hcFNpemUueTtcblxuXHRcdFx0XHRcdC8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxuXHRcdFx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vICB4elhaXG5cdFx0XHRcdFx0Ly8gICB5IFlcblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuXHRcdFx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxuXHRcdFx0XHRcdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxuXHRcdFx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuXHRcdFx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxuXG5cdFx0XHRcdFx0Ly8gcG9zaXRpdmUgWFxuXHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMCBdLnNldCggdnBXaWR0aCAqIDIsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXHRcdFx0XHRcdC8vIG5lZ2F0aXZlIFhcblx0XHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDEgXS5zZXQoIDAsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIFpcblx0XHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDIgXS5zZXQoIHZwV2lkdGggKiAzLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblx0XHRcdFx0XHQvLyBuZWdhdGl2ZSBaXG5cdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAzIF0uc2V0KCB2cFdpZHRoLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblx0XHRcdFx0XHQvLyBwb3NpdGl2ZSBZXG5cdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyA0IF0uc2V0KCB2cFdpZHRoICogMywgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblx0XHRcdFx0XHQvLyBuZWdhdGl2ZSBZXG5cdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyA1IF0uc2V0KCB2cFdpZHRoLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXG5cdFx0XHRcdFx0X3NoYWRvd01hcFNpemUueCAqPSA0LjA7XG5cdFx0XHRcdFx0X3NoYWRvd01hcFNpemUueSAqPSAyLjA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2hhZG93Lm1hcCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlciwgZm9ybWF0OiBSR0JBRm9ybWF0IH07XG5cblx0XHRcdFx0XHRzaGFkb3cubWFwID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KCBfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55LCBwYXJzICk7XG5cdFx0XHRcdFx0c2hhZG93Lm1hcC50ZXh0dXJlLm5hbWUgPSBsaWdodC5uYW1lICsgXCIuc2hhZG93TWFwXCI7XG5cblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNoYWRvdy5pc1Nwb3RMaWdodFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdHNoYWRvdy51cGRhdGUoIGxpZ2h0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzaGFkb3dNYXAgPSBzaGFkb3cubWFwO1xuXHRcdFx0XHR2YXIgc2hhZG93TWF0cml4ID0gc2hhZG93Lm1hdHJpeDtcblxuXHRcdFx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcblxuXHRcdFx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHRcdGZhY2VDb3VudCA9IDY7XG5cblx0XHRcdFx0XHQvLyBmb3IgcG9pbnQgbGlnaHRzIHdlIHNldCB0aGUgc2hhZG93IG1hdHJpeCB0byBiZSBhIHRyYW5zbGF0aW9uLW9ubHkgbWF0cml4XG5cdFx0XHRcdFx0Ly8gZXF1YWwgdG8gaW52ZXJzZSBvZiB0aGUgbGlnaHQncyBwb3NpdGlvblxuXG5cdFx0XHRcdFx0c2hhZG93TWF0cml4Lm1ha2VUcmFuc2xhdGlvbiggLSBfbGlnaHRQb3NpdGlvbldvcmxkLngsIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC55LCAtIF9saWdodFBvc2l0aW9uV29ybGQueiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmYWNlQ291bnQgPSAxO1xuXG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0XHRcdFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XG5cblx0XHRcdFx0XHRzaGFkb3dNYXRyaXguc2V0KFxuXHRcdFx0XHRcdFx0MC41LCAwLjAsIDAuMCwgMC41LFxuXHRcdFx0XHRcdFx0MC4wLCAwLjUsIDAuMCwgMC41LFxuXHRcdFx0XHRcdFx0MC4wLCAwLjAsIDAuNSwgMC41LFxuXHRcdFx0XHRcdFx0MC4wLCAwLjAsIDAuMCwgMS4wXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblx0XHRcdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XG5cdFx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwIGZvciBlYWNoIGN1YmUgZmFjZSAoaWYgb21uaS1kaXJlY3Rpb25hbCkgb3Jcblx0XHRcdFx0Ly8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XG5cblx0XHRcdFx0Zm9yICggdmFyIGZhY2UgPSAwOyBmYWNlIDwgZmFjZUNvdW50OyBmYWNlICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0XHRcdF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xuXHRcdFx0XHRcdFx0X2xvb2tUYXJnZXQuYWRkKCBjdWJlRGlyZWN0aW9uc1sgZmFjZSBdICk7XG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXAuY29weSggY3ViZVVwc1sgZmFjZSBdICk7XG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xuXHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRcdFx0XHRcdHZhciB2cERpbWVuc2lvbnMgPSBjdWJlMkRWaWV3UG9ydHNbIGZhY2UgXTtcblx0XHRcdFx0XHRcdF9zdGF0ZS52aWV3cG9ydCggdnBEaW1lbnNpb25zICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cblx0XHRcdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0XHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXG5cblx0XHRcdFx0XHRyZW5kZXJPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBsaWdodFBvc2l0aW9uV29ybGQsIHNoYWRvd0NhbWVyYU5lYXIsIHNoYWRvd0NhbWVyYUZhciApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gbnVsbDtcblxuXHRcdFx0dmFyIG1hdGVyaWFsVmFyaWFudHMgPSBfZGVwdGhNYXRlcmlhbHM7XG5cdFx0XHR2YXIgY3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxWYXJpYW50cyA9IF9kaXN0YW5jZU1hdGVyaWFscztcblx0XHRcdFx0Y3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgY3VzdG9tTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0dmFyIHVzZU1vcnBoaW5nID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRcdHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoID4gMDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRcdHVzZU1vcnBoaW5nID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZG93TWFwOiBUSFJFRS5Ta2lubmVkTWVzaCB3aXRoIG1hdGVyaWFsLnNraW5uaW5nIHNldCB0byBmYWxzZTonLCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHVzZVNraW5uaW5nID0gb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWwuc2tpbm5pbmc7XG5cblx0XHRcdFx0dmFyIHZhcmlhbnRJbmRleCA9IDA7XG5cblx0XHRcdFx0aWYgKCB1c2VNb3JwaGluZyApIHZhcmlhbnRJbmRleCB8PSBfTW9ycGhpbmdGbGFnO1xuXHRcdFx0XHRpZiAoIHVzZVNraW5uaW5nICkgdmFyaWFudEluZGV4IHw9IF9Ta2lubmluZ0ZsYWc7XG5cblx0XHRcdFx0cmVzdWx0ID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzdWx0ID0gY3VzdG9tTWF0ZXJpYWw7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBfcmVuZGVyZXIubG9jYWxDbGlwcGluZ0VuYWJsZWQgJiZcblx0XHRcdFx0XHRtYXRlcmlhbC5jbGlwU2hhZG93cyA9PT0gdHJ1ZSAmJlxuXHRcdFx0XHRcdG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHQvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCBhIHVuaXF1ZSBtYXRlcmlhbCBpbnN0YW5jZSByZWZsZWN0aW5nIHRoZVxuXHRcdFx0XHQvLyBhcHByb3ByaWF0ZSBzdGF0ZVxuXG5cdFx0XHRcdHZhciBrZXlBID0gcmVzdWx0LnV1aWQsIGtleUIgPSBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbHNGb3JWYXJpYW50ID0gX21hdGVyaWFsQ2FjaGVbIGtleUEgXTtcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsc0ZvclZhcmlhbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnQgPSB7fTtcblx0XHRcdFx0XHRfbWF0ZXJpYWxDYWNoZVsga2V5QSBdID0gbWF0ZXJpYWxzRm9yVmFyaWFudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWxzRm9yVmFyaWFudFsga2V5QiBdO1xuXG5cdFx0XHRcdGlmICggY2FjaGVkTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gcmVzdWx0LmNsb25lKCk7XG5cdFx0XHRcdFx0bWF0ZXJpYWxzRm9yVmFyaWFudFsga2V5QiBdID0gY2FjaGVkTWF0ZXJpYWw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCA9IGNhY2hlZE1hdGVyaWFsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcblx0XHRcdHJlc3VsdC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XG5cblx0XHRcdHJlc3VsdC5zaWRlID0gKCBtYXRlcmlhbC5zaGFkb3dTaWRlICE9IG51bGwgKSA/IG1hdGVyaWFsLnNoYWRvd1NpZGUgOiBzaGFkb3dTaWRlWyBtYXRlcmlhbC5zaWRlIF07XG5cblx0XHRcdHJlc3VsdC5jbGlwU2hhZG93cyA9IG1hdGVyaWFsLmNsaXBTaGFkb3dzO1xuXHRcdFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XG5cdFx0XHRyZXN1bHQuY2xpcEludGVyc2VjdGlvbiA9IG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb247XG5cblx0XHRcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdFx0XHRyZXN1bHQubGluZXdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xuXG5cdFx0XHRpZiAoIGlzUG9pbnRMaWdodCAmJiByZXN1bHQuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZXN1bHQucmVmZXJlbmNlUG9zaXRpb24uY29weSggbGlnaHRQb3NpdGlvbldvcmxkICk7XG5cdFx0XHRcdHJlc3VsdC5uZWFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFOZWFyO1xuXHRcdFx0XHRyZXN1bHQuZmFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFGYXI7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdCggb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0dmFyIHZpc2libGUgPSBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKTtcblxuXHRcdFx0aWYgKCB2aXNpYmxlICYmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBrIF07XG5cdFx0XHRcdFx0XHRcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCwgc2hhZG93Q2FtZXJhLm5lYXIsIHNoYWRvd0NhbWVyYS5mYXIgKTtcblx0XHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCwgc2hhZG93Q2FtZXJhLm5lYXIsIHNoYWRvd0NhbWVyYS5mYXIgKTtcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0cmVuZGVyT2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdlYkdMQXR0cmlidXRlcyggZ2wgKSB7XG5cblx0XHR2YXIgYnVmZmVycyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcblx0XHRcdHZhciB1c2FnZSA9IGF0dHJpYnV0ZS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XG5cblx0XHRcdHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYnVmZmVyICk7XG5cdFx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBhcnJheSwgdXNhZ2UgKTtcblxuXHRcdFx0YXR0cmlidXRlLm9uVXBsb2FkQ2FsbGJhY2soKTtcblxuXHRcdFx0dmFyIHR5cGUgPSBnbC5GTE9BVDtcblxuXHRcdFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcblxuXHRcdFx0XHR0eXBlID0gZ2wuRkxPQVQ7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMQXR0cmlidXRlczogVW5zdXBwb3J0ZWQgZGF0YSBidWZmZXIgZm9ybWF0OiBGbG9hdDY0QXJyYXkuJyApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICkge1xuXG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcblxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5ICkge1xuXG5cdFx0XHRcdHR5cGUgPSBnbC5TSE9SVDtcblxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSApIHtcblxuXHRcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfSU5UO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgKSB7XG5cblx0XHRcdFx0dHlwZSA9IGdsLklOVDtcblxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgKSB7XG5cblx0XHRcdFx0dHlwZSA9IGdsLkJZVEU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSApIHtcblxuXHRcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRidWZmZXI6IGJ1ZmZlcixcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Ynl0ZXNQZXJFbGVtZW50OiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcblx0XHRcdFx0dmVyc2lvbjogYXR0cmlidXRlLnZlcnNpb25cblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGJ1ZmZlciwgYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHR2YXIgdXBkYXRlUmFuZ2UgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2U7XG5cblx0XHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5keW5hbWljID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBhcnJheSwgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggdXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcblxuXHRcdFx0XHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xuXG5cdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIDAsIGFycmF5ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHVwZGF0ZVJhbmdlLmNvdW50ID09PSAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcblx0XHRcdFx0XHRhcnJheS5zdWJhcnJheSggdXBkYXRlUmFuZ2Uub2Zmc2V0LCB1cGRhdGVSYW5nZS5vZmZzZXQgKyB1cGRhdGVSYW5nZS5jb3VudCApICk7XG5cblx0XHRcdFx0dXBkYXRlUmFuZ2UuY291bnQgPSAtIDE7IC8vIHJlc2V0IHJhbmdlXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBnZXQoIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xuXG5cdFx0XHRyZXR1cm4gYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZSggYXR0cmlidXRlICkge1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XG5cblx0XHRcdHZhciBkYXRhID0gYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhICkge1xuXG5cdFx0XHRcdGdsLmRlbGV0ZUJ1ZmZlciggZGF0YS5idWZmZXIgKTtcblxuXHRcdFx0XHRkZWxldGUgYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcblxuXHRcdFx0dmFyIGRhdGEgPSBidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdO1xuXG5cdFx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdID0gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZGF0YS52ZXJzaW9uIDwgYXR0cmlidXRlLnZlcnNpb24gKSB7XG5cblx0XHRcdFx0dXBkYXRlQnVmZmVyKCBkYXRhLmJ1ZmZlciwgYXR0cmlidXRlLCBidWZmZXJUeXBlICk7XG5cblx0XHRcdFx0ZGF0YS52ZXJzaW9uID0gYXR0cmlidXRlLnZlcnNpb247XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0cmVtb3ZlOiByZW1vdmUsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEV1bGVyKCB4LCB5LCB6LCBvcmRlciApIHtcblxuXHRcdHRoaXMuX3ggPSB4IHx8IDA7XG5cdFx0dGhpcy5feSA9IHkgfHwgMDtcblx0XHR0aGlzLl96ID0geiB8fCAwO1xuXHRcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgRXVsZXIuRGVmYXVsdE9yZGVyO1xuXG5cdH1cblxuXHRFdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuXG5cdEV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFdWxlci5wcm90b3R5cGUsIHtcblxuXHRcdHg6IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0eToge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR6OiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl96O1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdG9yZGVyOiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIEV1bGVyLnByb3RvdHlwZSwge1xuXG5cdFx0aXNFdWxlcjogdHJ1ZSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcblxuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXHRcdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG5cdFx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XG5cdFx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0XHR2YXIgY2xhbXAgPSBfTWF0aC5jbGFtcDtcblxuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdFx0dmFyIHRlID0gbS5lbGVtZW50cztcblx0XHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdFx0dmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XG5cdFx0XHR2YXIgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cblx0XHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tUXVhdGVybmlvbiggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcblxuXHRcdH0sXG5cblx0XHRyZW9yZGVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuXHRcdFx0dmFyIHEgPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcmVvcmRlciggbmV3T3JkZXIgKSB7XG5cblx0XHRcdFx0cS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdFx0cmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xuXG5cdFx0fSxcblxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdFx0dGhpcy5feCA9IGFycmF5WyAwIF07XG5cdFx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdFx0aWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH0sXG5cblx0XHR0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cblx0XHRcdGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gTGF5ZXJzKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMSB8IDA7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIExheWVycy5wcm90b3R5cGUsIHtcblxuXHRcdHNldDogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0XHR0aGlzLm1hc2sgPSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdFx0fSxcblxuXHRcdGVuYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcblxuXHRcdH0sXG5cblx0XHR0b2dnbGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbCB8IDA7XG5cblx0XHR9LFxuXG5cdFx0ZGlzYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG5cdFx0XHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCB8IDAgKTtcblxuXHRcdH0sXG5cblx0XHR0ZXN0OiBmdW5jdGlvbiAoIGxheWVycyApIHtcblxuXHRcdFx0cmV0dXJuICggdGhpcy5tYXNrICYgbGF5ZXJzLm1hc2sgKSAhPT0gMDtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXG5cdCAqL1xuXG5cdHZhciBvYmplY3QzRElkID0gMDtcblxuXHRmdW5jdGlvbiBPYmplY3QzRCgpIHtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogb2JqZWN0M0RJZCArKyB9ICk7XG5cblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XG5cblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0dGhpcy51cCA9IE9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xuXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcblxuXHRcdGZ1bmN0aW9uIG9uUm90YXRpb25DaGFuZ2UoKSB7XG5cblx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uUXVhdGVybmlvbkNoYW5nZSgpIHtcblxuXHRcdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdHJvdGF0aW9uLm9uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XG5cdFx0cXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0XHR9LFxuXHRcdFx0cm90YXRpb246IHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHJvdGF0aW9uXG5cdFx0XHR9LFxuXHRcdFx0cXVhdGVybmlvbjoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcXVhdGVybmlvblxuXHRcdFx0fSxcblx0XHRcdHNjYWxlOiB7XG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdFx0fSxcblx0XHRcdG1vZGVsVmlld01hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdFx0fSxcblx0XHRcdG5vcm1hbE1hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG5cdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0T2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcblx0T2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdE9iamVjdDNELnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IE9iamVjdDNELFxuXG5cdFx0aXNPYmplY3QzRDogdHJ1ZSxcblxuXHRcdG9uQmVmb3JlUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRvbkFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRSb3RhdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdFx0fSxcblxuXHRcdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcblxuXHRcdH0sXG5cblx0XHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxuXHRcdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdFx0dmFyIHExID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRyb3RhdGVPbldvcmxkQXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cdFx0XHQvLyBtZXRob2QgYXNzdW1lcyBubyByb3RhdGVkIHBhcmVudFxuXG5cdFx0XHR2YXIgcTEgPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25Xb3JsZEF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBxMSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkge1xuXG5cdFx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdHRoaXMucG9zaXRpb24uYWRkKCB2MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWCggZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVkoIGRpc3RhbmNlICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVaKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0bG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdH0sXG5cblx0XHR3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHdvcmxkVG9Mb2NhbCggdmVjdG9yICkge1xuXG5cdFx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG5cdFx0XHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHgsIHksIHogKSB7XG5cblx0XHRcdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0XHRcdHZlY3Rvci5jb3B5KCB4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZlY3Rvci5zZXQoIHgsIHksIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aGlzLmlzQ2FtZXJhICkge1xuXG5cdFx0XHRcdFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlwiLCBvYmplY3QgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdhZGRlZCcgfSApO1xuXG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudCA9IG51bGw7XG5cblx0XHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcblxuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG5cdFx0fSxcblxuXHRcdGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuXHRcdH0sXG5cblx0XHRnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXG5cdFx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcblx0XHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHR9LFxuXG5cdFx0Z2V0V29ybGRQb3NpdGlvbjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdH0sXG5cblx0XHRnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFF1YXRlcm5pb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Z2V0V29ybGRSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFJvdGF0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IEV1bGVyKCk7XG5cblx0XHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB0aGlzLnJvdGF0aW9uLm9yZGVyLCBmYWxzZSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Z2V0V29ybGRTY2FsZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRTY2FsZSggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkRGlyZWN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHRcdHRyYXZlcnNlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGNhbGxiYWNrKCBwYXJlbnQgKTtcblxuXHRcdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XG5cblx0XHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdFx0Ly8gbWV0YSBpcyBhIHN0cmluZyB3aGVuIGNhbGxlZCBmcm9tIEpTT04uc3RyaW5naWZ5XG5cdFx0XHR2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XG5cblx0XHRcdHZhciBvdXRwdXQgPSB7fTtcblxuXHRcdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cblx0XHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG5cdFx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxuXHRcdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdFx0Ly8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuXHRcdFx0XHRtZXRhID0ge1xuXHRcdFx0XHRcdGdlb21ldHJpZXM6IHt9LFxuXHRcdFx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRcdGltYWdlczoge30sXG5cdFx0XHRcdFx0c2hhcGVzOiB7fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXG5cdFx0XHRcdFx0dHlwZTogJ09iamVjdCcsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXG5cdFx0XHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG5cdFx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0ZnVuY3Rpb24gc2VyaWFsaXplKCBsaWJyYXJ5LCBlbGVtZW50ICkge1xuXG5cdFx0XHRcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID0gZWxlbWVudC50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvYmplY3QuZ2VvbWV0cnkgPSBzZXJpYWxpemUoIG1ldGEuZ2VvbWV0cmllcywgdGhpcy5nZW9tZXRyeSApO1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHR2YXIgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dXVpZHMucHVzaCggc2VyaWFsaXplKCBtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbFsgaSBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbiA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJpZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmdlb21ldHJpZXMgKTtcblx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XG5cdFx0XHRcdHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcblx0XHRcdFx0dmFyIGltYWdlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuaW1hZ2VzICk7XG5cdFx0XHRcdHZhciBzaGFwZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNoYXBlcyApO1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcblx0XHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XG5cdFx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0XHRpZiAoIHNoYXBlcy5sZW5ndGggPiAwICkgb3V0cHV0LnNoYXBlcyA9IHNoYXBlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdFx0XHQvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuXHRcdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdFx0Ly8gYW5kIHJldHVybiBhcyBhcnJheVxuXHRcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cblx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG5cdFx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdGlmICggcmVjdXJzaXZlID09PSB1bmRlZmluZWQgKSByZWN1cnNpdmUgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcblxuXHRcdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBzb3VyY2UucG9zaXRpb24gKTtcblx0XHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuXHRcdFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblxuXHRcdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcblx0XHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG5cdFx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcblx0XHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuXG5cdFx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcblx0XHRcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XG5cblx0XHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xuXHRcdFx0XHRcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCovXG5cblx0ZnVuY3Rpb24gQ2FtZXJhKCkge1xuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhbWVyYSc7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHR9XG5cblx0Q2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQ2FtZXJhLFxuXG5cdFx0aXNDYW1lcmE6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBhcm9zZSAvIGh0dHA6Ly9naXRodWIuY29tL2Fyb3NlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIE9ydGhvZ3JhcGhpY0NhbWVyYSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRDYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG5cblx0XHR0aGlzLnpvb20gPSAxO1xuXHRcdHRoaXMudmlldyA9IG51bGw7XG5cblx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xuXHRcdHRoaXMucmlnaHQgPSByaWdodDtcblx0XHR0aGlzLnRvcCA9IHRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuXHRcdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xuXHRcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHRPcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ2FtZXJhLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogT3J0aG9ncmFwaGljQ2FtZXJhLFxuXG5cdFx0aXNPcnRob2dyYXBoaWNDYW1lcmE6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHRDYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XG5cdFx0XHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xuXHRcdFx0dGhpcy50b3AgPSBzb3VyY2UudG9wO1xuXHRcdFx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xuXHRcdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG5cdFx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cblx0XHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXHRcdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0XHRpZiAoIHRoaXMudmlldyA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLnZpZXcgPSB7XG5cdFx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0XHRmdWxsV2lkdGg6IDEsXG5cdFx0XHRcdFx0ZnVsbEhlaWdodDogMSxcblx0XHRcdFx0XHRvZmZzZXRYOiAwLFxuXHRcdFx0XHRcdG9mZnNldFk6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdFx0aGVpZ2h0OiAxXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0XHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRYID0geDtcblx0XHRcdHRoaXMudmlldy5vZmZzZXRZID0geTtcblx0XHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR9LFxuXG5cdFx0Y2xlYXJWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xuXHRcdFx0dmFyIGR5ID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcblx0XHRcdHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcblx0XHRcdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcblxuXHRcdFx0dmFyIGxlZnQgPSBjeCAtIGR4O1xuXHRcdFx0dmFyIHJpZ2h0ID0gY3ggKyBkeDtcblx0XHRcdHZhciB0b3AgPSBjeSArIGR5O1xuXHRcdFx0dmFyIGJvdHRvbSA9IGN5IC0gZHk7XG5cblx0XHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xuXG5cdFx0XHRcdHZhciB6b29tVyA9IHRoaXMuem9vbSAvICggdGhpcy52aWV3LndpZHRoIC8gdGhpcy52aWV3LmZ1bGxXaWR0aCApO1xuXHRcdFx0XHR2YXIgem9vbUggPSB0aGlzLnpvb20gLyAoIHRoaXMudmlldy5oZWlnaHQgLyB0aGlzLnZpZXcuZnVsbEhlaWdodCApO1xuXHRcdFx0XHR2YXIgc2NhbGVXID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyB0aGlzLnZpZXcud2lkdGg7XG5cdFx0XHRcdHZhciBzY2FsZUggPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvIHRoaXMudmlldy5oZWlnaHQ7XG5cblx0XHRcdFx0bGVmdCArPSBzY2FsZVcgKiAoIHRoaXMudmlldy5vZmZzZXRYIC8gem9vbVcgKTtcblx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogKCB0aGlzLnZpZXcud2lkdGggLyB6b29tVyApO1xuXHRcdFx0XHR0b3AgLT0gc2NhbGVIICogKCB0aGlzLnZpZXcub2Zmc2V0WSAvIHpvb21IICk7XG5cdFx0XHRcdGJvdHRvbSA9IHRvcCAtIHNjYWxlSCAqICggdGhpcy52aWV3LmhlaWdodCAvIHpvb21IICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0XHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xuXHRcdFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcblx0XHRcdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcblx0XHRcdGRhdGEub2JqZWN0LnRvcCA9IHRoaXMudG9wO1xuXHRcdFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XG5cdFx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRcdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cblx0XHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnZpZXcgKTtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdHRoaXMuYSA9IGE7XG5cdFx0dGhpcy5iID0gYjtcblx0XHR0aGlzLmMgPSBjO1xuXG5cdFx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAmJiBub3JtYWwuaXNWZWN0b3IzICkgPyBub3JtYWwgOiBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XG5cblx0XHR0aGlzLmNvbG9yID0gKCBjb2xvciAmJiBjb2xvci5pc0NvbG9yICkgPyBjb2xvciA6IG5ldyBDb2xvcigpO1xuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XG5cblx0XHR0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggRmFjZTMucHJvdG90eXBlLCB7XG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuYSA9IHNvdXJjZS5hO1xuXHRcdFx0dGhpcy5iID0gc291cmNlLmI7XG5cdFx0XHR0aGlzLmMgPSBzb3VyY2UuYztcblxuXHRcdFx0dGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xuXHRcdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKi9cblxuXHR2YXIgZ2VvbWV0cnlJZCA9IDA7IC8vIEdlb21ldHJ5IHVzZXMgZXZlbiBudW1iZXJzIGFzIElkXG5cblx0ZnVuY3Rpb24gR2VvbWV0cnkoKSB7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IGdlb21ldHJ5SWQgKz0gMiB9ICk7XG5cblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnZlcnRpY2VzID0gW107XG5cdFx0dGhpcy5jb2xvcnMgPSBbXTtcblx0XHR0aGlzLmZhY2VzID0gW107XG5cdFx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gW107XG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuXHRcdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcblx0XHR0aGlzLnNraW5JbmRpY2VzID0gW107XG5cblx0XHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0Ly8gdXBkYXRlIGZsYWdzXG5cblx0XHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHR9XG5cblx0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogR2VvbWV0cnksXG5cblx0XHRpc0dlb21ldHJ5OiB0cnVlLFxuXG5cdFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0XHR2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblx0XHRcdFx0ZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xuXG5cdFx0XHRcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG5cdFx0XHRcdG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcblxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG5cdFx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcblxuXHRcdFx0XHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuXHRcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcblxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0XHRcdG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG9iaiA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRcdFx0b2JqLmxvb2tBdCggdmVjdG9yICk7XG5cblx0XHRcdFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblx0XHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcblx0XHRcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gW107XG5cblx0XHRcdHZhciB0ZW1wTm9ybWFscyA9IFtdO1xuXHRcdFx0dmFyIHRlbXBVVnMgPSBbXTtcblx0XHRcdHZhciB0ZW1wVVZzMiA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XG5cblx0XHRcdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApICk7XG5cblx0XHRcdFx0aWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZW1wTm9ybWFscy5wdXNoKCBuZXcgVmVjdG9yMyggbm9ybWFsc1sgaSBdLCBub3JtYWxzWyBpICsgMSBdLCBub3JtYWxzWyBpICsgMiBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZW1wVVZzLnB1c2goIG5ldyBWZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZW1wVVZzMi5wdXNoKCBuZXcgVmVjdG9yMiggdXZzMlsgaiBdLCB1dnMyWyBqICsgMSBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYWRkRmFjZSggYSwgYiwgYywgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cdFx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBjb2xvcnMgIT09IHVuZGVmaW5lZCA/IFsgc2NvcGUuY29sb3JzWyBhIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBiIF0uY2xvbmUoKSwgc2NvcGUuY29sb3JzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cblx0XHRcdFx0dmFyIGZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycywgbWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMSBdLnB1c2goIFsgdGVtcFVWczJbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYiBdLmNsb25lKCksIHRlbXBVVnMyWyBjIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0sIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRhZGRGYWNlKCBqLCBqICsgMSwgaiArIDIsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNlbnRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoKS5uZWdhdGUoKTtcblxuXHRcdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcblxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblxuXHRcdH0sXG5cblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXHRcdFx0dmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuXG5cdFx0XHR2YXIgcyA9IHJhZGl1cyA9PT0gMCA/IDEgOiAxLjAgLyByYWRpdXM7XG5cblx0XHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0bWF0cml4LnNldChcblx0XHRcdFx0cywgMCwgMCwgLSBzICogY2VudGVyLngsXG5cdFx0XHRcdDAsIHMsIDAsIC0gcyAqIGNlbnRlci55LFxuXHRcdFx0XHQwLCAwLCBzLCAtIHMgKiBjZW50ZXIueixcblx0XHRcdFx0MCwgMCwgMCwgMVxuXHRcdFx0KTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIHZhciBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHR2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0dmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xuXHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRjYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xuXG5cdFx0XHRpZiAoIGFyZWFXZWlnaHRlZCA9PT0gdW5kZWZpbmVkICkgYXJlYVdlaWdodGVkID0gdHJ1ZTtcblxuXHRcdFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XG5cblx0XHRcdHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzWyB2IF0gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXJlYVdlaWdodGVkICkge1xuXG5cdFx0XHRcdC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXG5cdFx0XHRcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cblxuXHRcdFx0XHR2YXIgdkEsIHZCLCB2Qztcblx0XHRcdFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdFx0dkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHRcdHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdFx0dmVydGljZXNbIHYgXS5ub3JtYWxpemUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggdmVydGljZXNbIGZhY2UuYiBdICk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSB2ZXJ0aWNlc1sgZmFjZS5hIF0uY2xvbmUoKTtcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRjb21wdXRlRmxhdFZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGYsIGZsLCBmYWNlO1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XG5cblx0XHRcdC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xuXHRcdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXG5cdFx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcblxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gKSB7XG5cblx0XHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxuXG5cdFx0XHR2YXIgdG1wR2VvID0gbmV3IEdlb21ldHJ5KCk7XG5cdFx0XHR0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHQvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXG5cblx0XHRcdFx0aWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XG5cblx0XHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XG5cdFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xuXHRcdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyA9IFtdO1xuXG5cdFx0XHRcdFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcblx0XHRcdFx0XHR2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVmVjdG9yMygpLCBiOiBuZXcgVmVjdG9yMygpLCBjOiBuZXcgVmVjdG9yMygpIH07XG5cblx0XHRcdFx0XHRcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcblx0XHRcdFx0XHRcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcblxuXHRcdFx0XHQvLyBzZXQgdmVydGljZXMgdG8gbW9ycGggdGFyZ2V0XG5cblx0XHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuXHRcdFx0XHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcblxuXHRcdFx0XHR0bXBHZW8uY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0XHRcdHRtcEdlby5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdFx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcblxuXHRcdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHRcdGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcblxuXHRcdFx0XHRcdGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG5cdFx0fSxcblxuXHRcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XG5cblx0XHRcdGlmICggISAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4LFxuXHRcdFx0XHR2ZXJ0ZXhPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcblx0XHRcdFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcblx0XHRcdFx0dmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXG5cdFx0XHRcdGZhY2VzMSA9IHRoaXMuZmFjZXMsXG5cdFx0XHRcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxuXHRcdFx0XHR1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXG5cdFx0XHRcdHV2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0sXG5cdFx0XHRcdGNvbG9yczEgPSB0aGlzLmNvbG9ycyxcblx0XHRcdFx0Y29sb3JzMiA9IGdlb21ldHJ5LmNvbG9ycztcblxuXHRcdFx0aWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcblxuXHRcdFx0aWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdmVydGljZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XG5cblx0XHRcdFx0dmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcblxuXHRcdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHRcdHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29sb3JzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjb2xvcnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbG9yczEucHVzaCggY29sb3JzMlsgaSBdLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXG5cdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXG5cdFx0XHRcdFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0XHRcdGZhY2VDb3B5ID0gbmV3IEZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XG5cdFx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcblx0XHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcblxuXHRcdFx0XHRmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1dnNcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xuXG5cdFx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR1dkNvcHkucHVzaCggdXZbIGogXS5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHV2czEucHVzaCggdXZDb3B5ICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRtZXJnZU1lc2g6IGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdFx0aWYgKCAhICggbWVzaCAmJiBtZXNoLmlzTWVzaCApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZU1lc2goKTogbWVzaCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuTWVzaC4nLCBtZXNoICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRtZXNoLm1hdHJpeEF1dG9VcGRhdGUgJiYgbWVzaC51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0dGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcblxuXHRcdH0sXG5cblx0XHQvKlxuXHRcdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cblx0XHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXG5cdFx0ICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cblx0XHQgKi9cblxuXHRcdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZXMgYnkgcG9zaXRpb24gY29vcmRpbmF0ZXMgKGFuZCBtYWtpbmcgc3VyZSB0aGV5IGFyZSB1bmlxdWUpXG5cdFx0XHR2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcblxuXHRcdFx0dmFyIHYsIGtleTtcblx0XHRcdHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcblx0XHRcdHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xuXHRcdFx0dmFyIGksIGlsLCBmYWNlO1xuXHRcdFx0dmFyIGluZGljZXMsIGosIGpsO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XG5cdFx0XHRcdGtleSA9IE1hdGgucm91bmQoIHYueCAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi55ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnogKiBwcmVjaXNpb24gKTtcblxuXHRcdFx0XHRpZiAoIHZlcnRpY2VzTWFwWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcblx0XHRcdFx0XHR1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XG5cdFx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XG5cdFx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxuXHRcdFx0Ly8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cblx0XHRcdHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuXHRcdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcblx0XHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XG5cdFx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcblxuXHRcdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXG5cdFx0XHRcdC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXG5cdFx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGluZGljZXNbIG4gXSA9PT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XG5cblx0XHRcdFx0dmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnNwbGljZSggaWR4LCAxICk7XG5cblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcblxuXHRcdFx0dmFyIGRpZmYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIHVuaXF1ZS5sZW5ndGg7XG5cdFx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xuXHRcdFx0cmV0dXJuIGRpZmY7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0XHRcdHRoaXMudmVydGljZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c29ydEZhY2VzQnlNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG5cdFx0XHR2YXIgbGVuZ3RoID0gZmFjZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyB0YWcgZmFjZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGZhY2VzWyBpIF0uX2lkID0gaTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzb3J0IGZhY2VzXG5cblx0XHRcdGZ1bmN0aW9uIG1hdGVyaWFsSW5kZXhTb3J0KCBhLCBiICkge1xuXG5cdFx0XHRcdHJldHVybiBhLm1hdGVyaWFsSW5kZXggLSBiLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZXMuc29ydCggbWF0ZXJpYWxJbmRleFNvcnQgKTtcblxuXHRcdFx0Ly8gc29ydCB1dnNcblxuXHRcdFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblx0XHRcdHZhciB1dnMyID0gdGhpcy5mYWNlVmVydGV4VXZzWyAxIF07XG5cblx0XHRcdHZhciBuZXdVdnMxLCBuZXdVdnMyO1xuXG5cdFx0XHRpZiAoIHV2czEgJiYgdXZzMS5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czEgPSBbXTtcblx0XHRcdGlmICggdXZzMiAmJiB1dnMyLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMiA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGlkID0gZmFjZXNbIGkgXS5faWQ7XG5cblx0XHRcdFx0aWYgKCBuZXdVdnMxICkgbmV3VXZzMS5wdXNoKCB1dnMxWyBpZCBdICk7XG5cdFx0XHRcdGlmICggbmV3VXZzMiApIG5ld1V2czIucHVzaCggdXZzMlsgaWQgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmV3VXZzMSApIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdID0gbmV3VXZzMTtcblx0XHRcdGlmICggbmV3VXZzMiApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gbmV3VXZzMjtcblxuXHRcdH0sXG5cblx0XHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC41LFxuXHRcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeScsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzdGFuZGFyZCBHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBmYWNlcyA9IFtdO1xuXHRcdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xuXHRcdFx0dmFyIGNvbG9ycyA9IFtdO1xuXHRcdFx0dmFyIGNvbG9yc0hhc2ggPSB7fTtcblx0XHRcdHZhciB1dnMgPSBbXTtcblx0XHRcdHZhciB1dnNIYXNoID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG5cdFx0XHRcdHZhciBoYXNNYXRlcmlhbCA9IHRydWU7XG5cdFx0XHRcdHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxuXHRcdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0XHR2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcblx0XHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcblx0XHRcdFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xuXHRcdFx0XHR2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcblxuXHRcdFx0XHR2YXIgZmFjZVR5cGUgPSAwO1xuXG5cdFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMCwgMCApOyAvLyBpc1F1YWRcblx0XHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAxLCBoYXNNYXRlcmlhbCApO1xuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDIsIGhhc0ZhY2VVdiApO1xuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDQsIGhhc0ZhY2VOb3JtYWwgKTtcblx0XHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA1LCBoYXNGYWNlVmVydGV4Tm9ybWFsICk7XG5cdFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XG5cdFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNywgaGFzRmFjZVZlcnRleENvbG9yICk7XG5cblx0XHRcdFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcblx0XHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xuXHRcdFx0XHRmYWNlcy5wdXNoKCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuXHRcdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuXHRcdFx0XHRcdGZhY2VzLnB1c2goXG5cdFx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcblx0XHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxuXHRcdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRcdGZhY2VzLnB1c2goXG5cdFx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXG5cdFx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXG5cdFx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuXHRcdFx0XHRcdGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuXHRcdFx0XHRcdGZhY2VzLnB1c2goXG5cdFx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDAgXSApLFxuXHRcdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcblx0XHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBzZXRCaXQoIHZhbHVlLCBwb3NpdGlvbiwgZW5hYmxlZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XG5cblx0XHRcdFx0dmFyIGhhc2ggPSBub3JtYWwueC50b1N0cmluZygpICsgbm9ybWFsLnkudG9TdHJpbmcoKSArIG5vcm1hbC56LnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XG5cblx0XHRcdFx0dmFyIGhhc2ggPSBjb2xvci5yLnRvU3RyaW5nKCkgKyBjb2xvci5nLnRvU3RyaW5nKCkgKyBjb2xvci5iLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xuXG5cdFx0XHRcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XG5cblx0XHRcdFx0dmFyIGhhc2ggPSB1di54LnRvU3RyaW5nKCkgKyB1di55LnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0aWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHV2c0hhc2hbIGhhc2ggXSA9IHV2cy5sZW5ndGggLyAyO1xuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0ZGF0YS5kYXRhID0ge307XG5cblx0XHRcdGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXHRcdFx0ZGF0YS5kYXRhLm5vcm1hbHMgPSBub3JtYWxzO1xuXHRcdFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XG5cdFx0XHRpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdGRhdGEuZGF0YS5mYWNlcyA9IGZhY2VzO1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvKlxuXHRcdFx0IC8vIEhhbmRsZSBwcmltaXRpdmVzXG5cblx0XHRcdCB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0IGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQgdmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHQgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHQgdmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XG5cblx0XHRcdCB9XG5cblx0XHRcdCB2YXIgZ2VvbWV0cnkgPSBPYmplY3QuY3JlYXRlKCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSApO1xuXHRcdFx0IHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcblx0XHRcdCByZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdCB9XG5cblx0XHRcdCByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cdFx0XHQgKi9cblxuXHRcdFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpLmNvcHkoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0dmFyIGksIGlsLCBqLCBqbCwgaywga2w7XG5cblx0XHRcdC8vIHJlc2V0XG5cblx0XHRcdHRoaXMudmVydGljZXMgPSBbXTtcblx0XHRcdHRoaXMuY29sb3JzID0gW107XG5cdFx0XHR0aGlzLmZhY2VzID0gW107XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbW11dO1xuXHRcdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcblx0XHRcdHRoaXMubW9ycGhOb3JtYWxzID0gW107XG5cdFx0XHR0aGlzLnNraW5XZWlnaHRzID0gW107XG5cdFx0XHR0aGlzLnNraW5JbmRpY2VzID0gW107XG5cdFx0XHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHRcdC8vIG5hbWVcblxuXHRcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cblx0XHRcdC8vIHZlcnRpY2VzXG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IHNvdXJjZS52ZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb2xvcnNcblxuXHRcdFx0dmFyIGNvbG9ycyA9IHNvdXJjZS5jb2xvcnM7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvcnNbIGkgXS5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0dmFyIGZhY2VzID0gc291cmNlLmZhY2VzO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGZhY2UgdmVydGV4IHV2c1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHNvdXJjZS5mYWNlVmVydGV4VXZzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB1dnMgPSBmYWNlVmVydGV4VXZzWyBqIF0sIHV2c0NvcHkgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIGsgPSAwLCBrbCA9IHV2cy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHV2ID0gdXZzWyBrIF07XG5cblx0XHRcdFx0XHRcdHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBtb3JwaCB0YXJnZXRzXG5cblx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0ge307XG5cdFx0XHRcdG1vcnBoVGFyZ2V0Lm5hbWUgPSBtb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xuXG5cdFx0XHRcdC8vIHZlcnRpY2VzXG5cblx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXQudmVydGljZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRtb3JwaFRhcmdldC52ZXJ0aWNlcy5wdXNoKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlc1sgaiBdLmNsb25lKCkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbm9ybWFsc1xuXG5cdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXQubm9ybWFscyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0bW9ycGhUYXJnZXQubm9ybWFscy5wdXNoKCBtb3JwaFRhcmdldHNbIGkgXS5ub3JtYWxzWyBqIF0uY2xvbmUoKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG1vcnBoIG5vcm1hbHNcblxuXHRcdFx0dmFyIG1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSB7fTtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXggbm9ybWFsc1xuXG5cdFx0XHRcdGlmICggbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bW9ycGhOb3JtYWwudmVydGV4Tm9ybWFscyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHNyY1ZlcnRleE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHNbIGogXTtcblx0XHRcdFx0XHRcdHZhciBkZXN0VmVydGV4Tm9ybWFsID0ge307XG5cblx0XHRcdFx0XHRcdGRlc3RWZXJ0ZXhOb3JtYWwuYSA9IHNyY1ZlcnRleE5vcm1hbC5hLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRkZXN0VmVydGV4Tm9ybWFsLmIgPSBzcmNWZXJ0ZXhOb3JtYWwuYi5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0ZGVzdFZlcnRleE5vcm1hbC5jID0gc3JjVmVydGV4Tm9ybWFsLmMuY2xvbmUoKTtcblxuXHRcdFx0XHRcdFx0bW9ycGhOb3JtYWwudmVydGV4Tm9ybWFscy5wdXNoKCBkZXN0VmVydGV4Tm9ybWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGZhY2Ugbm9ybWFsc1xuXG5cdFx0XHRcdGlmICggbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG1vcnBoTm9ybWFsLmZhY2VOb3JtYWxzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0bW9ycGhOb3JtYWwuZmFjZU5vcm1hbHMucHVzaCggbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHNbIGogXS5jbG9uZSgpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzLnB1c2goIG1vcnBoTm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2tpbiB3ZWlnaHRzXG5cblx0XHRcdHZhciBza2luV2VpZ2h0cyA9IHNvdXJjZS5za2luV2VpZ2h0cztcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBza2luIGluZGljZXNcblxuXHRcdFx0dmFyIHNraW5JbmRpY2VzID0gc291cmNlLnNraW5JbmRpY2VzO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBza2luSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBpIF0uY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGxpbmUgZGlzdGFuY2VzXG5cblx0XHRcdHZhciBsaW5lRGlzdGFuY2VzID0gc291cmNlLmxpbmVEaXN0YW5jZXM7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGxpbmVEaXN0YW5jZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzLnB1c2goIGxpbmVEaXN0YW5jZXNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGJvdW5kaW5nIGJveFxuXG5cdFx0XHR2YXIgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XG5cblx0XHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgZmxhZ3NcblxuXHRcdFx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBzb3VyY2UuZWxlbWVudHNOZWVkVXBkYXRlO1xuXHRcdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBzb3VyY2UudmVydGljZXNOZWVkVXBkYXRlO1xuXHRcdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gc291cmNlLnV2c05lZWRVcGRhdGU7XG5cdFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gc291cmNlLm5vcm1hbHNOZWVkVXBkYXRlO1xuXHRcdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gc291cmNlLmNvbG9yc05lZWRVcGRhdGU7XG5cdFx0XHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gc291cmNlLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlO1xuXHRcdFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gc291cmNlLmdyb3Vwc05lZWRVcGRhdGU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggYXJyYXkgKSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xuXHRcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XG5cblx0XHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblxuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcblxuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCAnbmVlZHNVcGRhdGUnLCB7XG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcblxuXHRcdGlzQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXG5cdFx0c2V0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggYXJyYXkgKSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyB0aGlzLml0ZW1TaXplIDogMDtcblx0XHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcblxuXHRcdH0sXG5cblx0XHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuXHRcdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cblx0XHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG5cdFx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cblx0XHRcdHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5Q29sb3JzQXJyYXk6IGZ1bmN0aW9uICggY29sb3JzICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY29sb3IgPSBjb2xvcnNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0XHRjb2xvciA9IG5ldyBDb2xvcigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcblxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5hO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuXHRcdFx0XHRcdHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y29weVZlY3RvcjRzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuXHRcdFx0XHRcdHZlY3RvciA9IG5ldyBWZWN0b3I0KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xuXG5cdFx0fSxcblxuXHRcdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuXHRcdH0sXG5cblx0XHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG5cdFx0fSxcblxuXHRcdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XG5cblx0XHR9LFxuXG5cdFx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XG5cblx0XHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0b25VcGxvYWQ6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUgKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8vXG5cblx0ZnVuY3Rpb24gSW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBJbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuXHRJbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XG5cblxuXHRmdW5jdGlvbiBVaW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxuXHRVaW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5cdFVpbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQ4QnVmZmVyQXR0cmlidXRlO1xuXG5cblx0ZnVuY3Rpb24gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxuXHRVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuXHRVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlO1xuXG5cblx0ZnVuY3Rpb24gSW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cblx0SW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuXHRJbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcblxuXG5cdGZ1bmN0aW9uIFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cblx0VWludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcblx0VWludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcblxuXG5cdGZ1bmN0aW9uIEludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG5cdEludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50MzJCdWZmZXJBdHRyaWJ1dGU7XG5cblxuXHRmdW5jdGlvbiBVaW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50MzJCdWZmZXJBdHRyaWJ1dGU7XG5cblxuXHRmdW5jdGlvbiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEZsb2F0MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cblx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTtcblxuXG5cdGZ1bmN0aW9uIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgRmxvYXQ2NEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxuXHRGbG9hdDY0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcblx0RmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9hdDY0QnVmZmVyQXR0cmlidXRlO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBEaXJlY3RHZW9tZXRyeSgpIHtcblxuXHRcdHRoaXMuaW5kaWNlcyA9IFtdO1xuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcblx0XHR0aGlzLm5vcm1hbHMgPSBbXTtcblx0XHR0aGlzLmNvbG9ycyA9IFtdO1xuXHRcdHRoaXMudXZzID0gW107XG5cdFx0dGhpcy51dnMyID0gW107XG5cblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcblxuXHRcdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcblx0XHR0aGlzLnNraW5JbmRpY2VzID0gW107XG5cblx0XHQvLyB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0Ly8gdXBkYXRlIGZsYWdzXG5cblx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlLCB7XG5cblx0XHRjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgZ3JvdXA7XG5cdFx0XHR2YXIgZ3JvdXBzID0gW107XG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0Ly8gbWF0ZXJpYWxzXG5cblx0XHRcdFx0aWYgKCBmYWNlLm1hdGVyaWFsSW5kZXggIT09IG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xuXHRcdFx0XHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRncm91cCA9IHtcblx0XHRcdFx0XHRcdHN0YXJ0OiBpICogMyxcblx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcblx0XHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ncm91cHMgPSBncm91cHM7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xuXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdjIgPSBmYWNlVmVydGV4VXZzWyAxIF0gJiYgZmFjZVZlcnRleFV2c1sgMSBdLmxlbmd0aCA+IDA7XG5cblx0XHRcdC8vIG1vcnBoc1xuXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRcdHZhciBtb3JwaFRhcmdldHNQb3NpdGlvbjtcblxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcblxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0c05vcm1hbDtcblxuXHRcdFx0aWYgKCBtb3JwaE5vcm1hbHNMZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbCA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaSBdID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBza2luc1xuXG5cdFx0XHR2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcblx0XHRcdHZhciBza2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzO1xuXG5cdFx0XHR2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcblx0XHRcdHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggdmVydGV4Tm9ybWFsc1sgMCBdLCB2ZXJ0ZXhOb3JtYWxzWyAxIF0sIHZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cblx0XHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICkge1xuXG5cdFx0XHRcdFx0dGhpcy5jb2xvcnMucHVzaCggdmVydGV4Q29sb3JzWyAwIF0sIHZlcnRleENvbG9yc1sgMSBdLCB2ZXJ0ZXhDb2xvcnNbIDIgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgY29sb3IgPSBmYWNlLmNvbG9yO1xuXG5cdFx0XHRcdFx0dGhpcy5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuXHRcdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xuXG5cdFx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2MiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAxIF1bIGkgXTtcblxuXHRcdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XG5cblx0XHRcdFx0XHRcdHRoaXMudXZzMi5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG1vcnBoc1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGogXS5wdXNoKCBtb3JwaFRhcmdldFsgZmFjZS5hIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmIgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYyBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaiBdLnZlcnRleE5vcm1hbHNbIGkgXTtcblxuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaiBdLnB1c2goIG1vcnBoTm9ybWFsLmEsIG1vcnBoTm9ybWFsLmIsIG1vcnBoTm9ybWFsLmMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2tpbnNcblxuXHRcdFx0XHRpZiAoIGhhc1NraW5JbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzU2tpbldlaWdodHMgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xuXG5cdFx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcblx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcblx0XHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XG5cdFx0XHR0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuXHRcdFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBhcnJheU1heCggYXJyYXkgKSB7XG5cblx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMCApIHJldHVybiAtIEluZmluaXR5O1xuXG5cdFx0dmFyIG1heCA9IGFycmF5WyAwIF07XG5cblx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArKyBpICkge1xuXG5cdFx0XHRpZiAoIGFycmF5WyBpIF0gPiBtYXggKSBtYXggPSBhcnJheVsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heDtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdHZhciBidWZmZXJHZW9tZXRyeUlkID0gMTsgLy8gQnVmZmVyR2VvbWV0cnkgdXNlcyBvZGQgbnVtYmVycyBhcyBJZFxuXG5cdGZ1bmN0aW9uIEJ1ZmZlckdlb21ldHJ5KCkge1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBidWZmZXJHZW9tZXRyeUlkICs9IDIgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnR5cGUgPSAnQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XG5cblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcblxuXHR9XG5cblx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQnVmZmVyR2VvbWV0cnksXG5cblx0XHRpc0J1ZmZlckdlb21ldHJ5OiB0cnVlLFxuXG5cdFx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW5kZXg7XG5cblx0XHR9LFxuXG5cdFx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggaW5kZXggKSApIHtcblxuXHRcdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlNYXgoIGluZGV4ICkgPiA2NTUzNSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGlmICggISAoIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUgKSAmJiAhICggYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcblxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdICkgKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuYW1lID09PSAnaW5kZXgnICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xuXHRcdFx0XHR0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YWRkR3JvdXA6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0XHRjb3VudDogY291bnQsXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXG5cblx0XHRcdH0gKTtcblxuXHRcdH0sXG5cblx0XHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG5cdFx0fSxcblxuXHRcdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWF0cml4LmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XG5cdFx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0aWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRcdG5vcm1hbE1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBub3JtYWwgKTtcblx0XHRcdFx0bm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cblx0XHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cblx0XHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcblxuXHRcdFx0XHRtMS5tYWtlUm90YXRpb25ZKCBhbmdsZSApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cblx0XHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cblx0XHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cblx0XHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcblxuXHRcdFx0XHRtMS5tYWtlU2NhbGUoIHgsIHksIHogKTtcblxuXHRcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBvYmogPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG5cdFx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xuXG5cdFx0XHRcdG9iai51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XG5cblx0XHRcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XG5cblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKCBvYmplY3QuaXNQb2ludHMgfHwgb2JqZWN0LmlzTGluZSApIHtcblxuXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcblx0XHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMywgMyApO1xuXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHR2YXIgbGluZURpc3RhbmNlcyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCwgMSApO1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBsaW5lRGlzdGFuY2VzLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTWVzaCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0cG9zaXRpb24ucHVzaCggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcblxuXHRcdFx0XHR2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGRpcmVjdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcblx0XHRcdFx0ZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG5cdFx0XHRcdGRpcmVjdC5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcblx0XHRcdFx0ZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuXHRcdFx0XHRkaXJlY3QuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XG5cblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdFx0Z2VvbWV0cnkgPSBkaXJlY3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGF0dHJpYnV0ZTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlR3JvdXBzKCBvYmplY3QuZ2VvbWV0cnkgKTtcblx0XHRcdFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0Z2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSA9IG5ldyBEaXJlY3RHZW9tZXRyeSgpLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbURpcmVjdEdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKiAzICk7XG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMyApO1xuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2cy5sZW5ndGggKiAyICk7XG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgdXZzMiA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2czIubGVuZ3RoICogMiApO1xuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2czIsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzMiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIFR5cGVBcnJheSA9IGFycmF5TWF4KCBnZW9tZXRyeS5pbmRpY2VzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XG5cdFx0XHRcdHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XG5cdFx0XHRcdHRoaXMuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKS5jb3B5SW5kaWNlc0FycmF5KCBnZW9tZXRyeS5pbmRpY2VzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBncm91cHNcblxuXHRcdFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdC8vIG1vcnBoc1xuXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gW107XG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIG5hbWUgXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNraW5uaW5nXG5cblx0XHRcdGlmICggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgc2tpbkluZGljZXMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIHNraW5JbmRpY2VzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luSW5kaWNlcyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBza2luV2VpZ2h0cyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94OiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XG5cdFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0aWYgKCBwb3NpdGlvbiApIHtcblxuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0XHRcdGJveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXHRcdFx0XHRcdGJveC5nZXRDZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdFx0XHQvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXG5cblx0XHRcdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZlY3Rvci54ID0gcG9zaXRpb24uZ2V0WCggaSApO1xuXHRcdFx0XHRcdFx0dmVjdG9yLnkgPSBwb3NpdGlvbi5nZXRZKCBpICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3IueiA9IHBvc2l0aW9uLmdldFooIGkgKTtcblx0XHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXHRcdFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRhcnJheVsgaSBdID0gMDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdFx0XHR2YXIgdkEsIHZCLCB2Qztcblx0XHRcdFx0dmFyIHBBID0gbmV3IFZlY3RvcjMoKSwgcEIgPSBuZXcgVmVjdG9yMygpLCBwQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cblx0XHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGogXTtcblxuXHRcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHR2QSA9IGluZGljZXNbIGkgKyAwIF0gKiAzO1xuXHRcdFx0XHRcdFx0XHR2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xuXHRcdFx0XHRcdFx0XHR2QyA9IGluZGljZXNbIGkgKyAyIF0gKiAzO1xuXG5cdFx0XHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xuXHRcdFx0XHRcdFx0XHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcblx0XHRcdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZDICk7XG5cblx0XHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG5cdFx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyB2QSBdICs9IGNiLng7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMiBdICs9IGNiLno7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgXSArPSBjYi54O1xuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDIgXSArPSBjYi56O1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuXHRcdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcblx0XHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xuXHRcdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XG5cblx0XHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuXHRcdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XG5cdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSBdID0gY2IueDtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAxIF0gPSBjYi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDIgXSA9IGNiLno7XG5cblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNyBdID0gY2IueTtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuXHRcdFx0XHRhdHRyaWJ1dGVzLm5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgb2Zmc2V0ICkge1xuXG5cdFx0XHRpZiAoICEgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZTIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGUyLml0ZW1TaXplO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlQXJyYXkxWyBqIF0gPSBhdHRyaWJ1dGVBcnJheTJbIGkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbGl6ZU5vcm1hbHMoKSB7XG5cblx0XHRcdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3IueCA9IG5vcm1hbHMuZ2V0WCggaSApO1xuXHRcdFx0XHRcdHZlY3Rvci55ID0gbm9ybWFscy5nZXRZKCBpICk7XG5cdFx0XHRcdFx0dmVjdG9yLnogPSBub3JtYWxzLmdldFooIGkgKTtcblxuXHRcdFx0XHRcdHZlY3Rvci5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0dG9Ob25JbmRleGVkOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS50b05vbkluZGV4ZWQoKTogR2VvbWV0cnkgaXMgYWxyZWFkeSBub24taW5kZXhlZC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0dmFyIGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRcdHZhciBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdFx0XHR2YXIgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gMCwgaW5kZXgyID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaXRlbVNpemU7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkyLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5MjtcblxuXHRcdH0sXG5cblx0XHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdFx0dmVyc2lvbjogNC41LFxuXHRcdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XG5cblx0XHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XG5cblx0XHRcdFx0ZGF0YS5kYXRhLmluZGV4ID0ge1xuXHRcdFx0XHRcdHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG5cdFx0XHRcdFx0YXJyYXk6IGFycmF5XG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xuXG5cdFx0XHRcdGRhdGEuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcblx0XHRcdFx0XHRpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxuXHRcdFx0XHRcdHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRcdGFycmF5OiBhcnJheSxcblx0XHRcdFx0XHRub3JtYWxpemVkOiBhdHRyaWJ1dGUubm9ybWFsaXplZFxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG5cdFx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuXHRcdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Lypcblx0XHRcdCAvLyBIYW5kbGUgcHJpbWl0aXZlc1xuXG5cdFx0XHQgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdCBpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0IHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0IGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0IHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xuXG5cdFx0XHQgfVxuXG5cdFx0XHQgdmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcblx0XHRcdCB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XG5cdFx0XHQgcmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHQgfVxuXG5cdFx0XHQgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXHRcdFx0ICovXG5cblx0XHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHZhciBuYW1lLCBpLCBsO1xuXG5cdFx0XHQvLyByZXNldFxuXG5cdFx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHRcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0XHQvLyBuYW1lXG5cblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0XHQvLyBpbmRleFxuXG5cdFx0XHR2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGF0dHJpYnV0ZXNcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yICggbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRcdGZvciAoIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggbW9ycGhBdHRyaWJ1dGVbIGkgXS5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBncm91cHNcblxuXHRcdFx0dmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGJvdW5kaW5nIGJveFxuXG5cdFx0XHR2YXIgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XG5cblx0XHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBkcmF3IHJhbmdlXG5cblx0XHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcblx0XHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqL1xuXG5cdC8vIEJveEdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gQm94R2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdGRlcHRoOiBkZXB0aCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgQm94QnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApICk7XG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0fVxuXG5cdEJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRCb3hHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hHZW9tZXRyeTtcblxuXHQvLyBCb3hCdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIEJveEJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm94QnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRkZXB0aDogZGVwdGgsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuXHRcdH07XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0d2lkdGggPSB3aWR0aCB8fCAxO1xuXHRcdGhlaWdodCA9IGhlaWdodCB8fCAxO1xuXHRcdGRlcHRoID0gZGVwdGggfHwgMTtcblxuXHRcdC8vIHNlZ21lbnRzXG5cblx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG5cdFx0ZGVwdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIGRlcHRoU2VnbWVudHMgKSB8fCAxO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdHZhciB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdHZhciBudW1iZXJPZlZlcnRpY2VzID0gMDtcblx0XHR2YXIgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxuXG5cdFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCApOyAvLyBweFxuXHRcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDEgKTsgLy8gbnhcblx0XHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAxLCAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMiApOyAvLyBweVxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMyApOyAvLyBueVxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0ICk7IC8vIHB6XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA1ICk7IC8vIG56XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHcsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBncmlkWCwgZ3JpZFksIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdHZhciBzZWdtZW50V2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuXHRcdFx0dmFyIHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuXHRcdFx0dmFyIHdpZHRoSGFsZiA9IHdpZHRoIC8gMjtcblx0XHRcdHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblx0XHRcdHZhciBkZXB0aEhhbGYgPSBkZXB0aCAvIDI7XG5cblx0XHRcdHZhciBncmlkWDEgPSBncmlkWCArIDE7XG5cdFx0XHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdFx0XHR2YXIgdmVydGV4Q291bnRlciA9IDA7XG5cdFx0XHR2YXIgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdHZhciBpeCwgaXk7XG5cblx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG5cdFx0XHRcdHZhciB5ID0gaXkgKiBzZWdtZW50SGVpZ2h0IC0gaGVpZ2h0SGFsZjtcblxuXHRcdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcblxuXHRcdFx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7XG5cblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSB4ICogdWRpcjtcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9IHkgKiB2ZGlyO1xuXHRcdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGhIYWxmO1xuXG5cdFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byB2ZXJ0ZXggYnVmZmVyXG5cblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSAwO1xuXHRcdFx0XHRcdHZlY3RvclsgdiBdID0gMDtcblx0XHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XG5cblx0XHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIG5vcm1hbCBidWZmZXJcblxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHRcdFx0Ly8gdXZzXG5cblx0XHRcdFx0XHR1dnMucHVzaCggaXggLyBncmlkWCApO1xuXHRcdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdFx0XHRcdC8vIGNvdW50ZXJzXG5cblx0XHRcdFx0XHR2ZXJ0ZXhDb3VudGVyICs9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2Vcblx0XHRcdC8vIDIuIGEgc2luZ2xlIHNlZ21lbnQgY29uc2lzdHMgb2YgdHdvIGZhY2VzXG5cdFx0XHQvLyAzLiBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIHNpeCAoMiozKSBpbmRpY2VzIHBlciBzZWdtZW50XG5cblx0XHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdFx0dmFyIGIgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRcdHZhciBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRcdHZhciBkID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0XHRcdC8vIGluY3JlYXNlIGNvdW50ZXJcblxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIG1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdFx0Ly8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRudW1iZXJPZlZlcnRpY2VzICs9IHZlcnRleENvdW50ZXI7XG5cblx0XHR9XG5cblx0fVxuXG5cdEJveEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRCb3hCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hCdWZmZXJHZW9tZXRyeTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICovXG5cblx0Ly8gUGxhbmVHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFBsYW5lR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG5cdH1cblxuXHRQbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRQbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lR2VvbWV0cnk7XG5cblx0Ly8gUGxhbmVCdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFBsYW5lQnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BsYW5lQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdHdpZHRoID0gd2lkdGggfHwgMTtcblx0XHRoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuXHRcdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuXHRcdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cblx0XHR2YXIgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcblx0XHR2YXIgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG5cblx0XHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHRcdHZhciBncmlkWTEgPSBncmlkWSArIDE7XG5cblx0XHR2YXIgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XG5cdFx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0XHR2YXIgaXgsIGl5O1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdHZhciB1dnMgPSBbXTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG5cdFx0XHR2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0dmFyIHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIC0geSwgMCApO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XG5cdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuXHRcdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdFBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVCdWZmZXJHZW9tZXRyeTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8aGV4Pixcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG5cdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG5cdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBkZXB0aFRlc3Q6IDxib29sPixcblx0ICogIGRlcHRoV3JpdGU6IDxib29sPixcblx0ICpcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgc2tpbm5pbmc6IDxib29sPixcblx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0ZnVuY3Rpb24gTWVzaEJhc2ljTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcblxuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcblx0XHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuXHRNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoQmFzaWNNYXRlcmlhbDtcblxuXHRNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoQmFzaWNNYXRlcmlhbCA9IHRydWU7XG5cblx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqICBkZWZpbmVzOiB7IFwibGFiZWxcIiA6IFwidmFsdWVcIiB9LFxuXHQgKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdmFsdWU6IDEuMCB9LCBcInBhcmFtZXRlcjJcIjogeyB2YWx1ZTI6IDIgfSB9LFxuXHQgKlxuXHQgKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuXHQgKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcblx0ICpcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgbGlnaHRzOiA8Ym9vbD4sXG5cdCAqXG5cdCAqICBza2lubmluZzogPGJvb2w+LFxuXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG5cdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFNoYWRlck1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHt9O1xuXHRcdHRoaXMudW5pZm9ybXMgPSB7fTtcblxuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufSc7XG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XFxufSc7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHRcdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcblx0XHR0aGlzLmNsaXBwaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2UgdXNlci1kZWZpbmVkIGNsaXBwaW5nIHBsYW5lc1xuXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7XG5cdFx0XHRkZXJpdmF0aXZlczogZmFsc2UsIC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcblx0XHRcdGZyYWdEZXB0aDogZmFsc2UsIC8vIHNldCB0byB1c2UgZnJhZ21lbnQgZGVwdGggdmFsdWVzXG5cdFx0XHRkcmF3QnVmZmVyczogZmFsc2UsIC8vIHNldCB0byB1c2UgZHJhdyBidWZmZXJzXG5cdFx0XHRzaGFkZXJUZXh0dXJlTE9EOiBmYWxzZSAvLyBzZXQgdG8gdXNlIHNoYWRlciB0ZXh0dXJlIExPRFxuXHRcdH07XG5cblx0XHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcblx0XHQvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXG5cdFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXG5cdFx0XHQndXYnOiBbIDAsIDAgXSxcblx0XHRcdCd1djInOiBbIDAsIDAgXVxuXHRcdH07XG5cblx0XHR0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy51bmlmb3Jtc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRlck1hdGVyaWFsO1xuXG5cdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5pc1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcblxuXHRTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuXHRcdHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcblxuXHRcdHRoaXMudW5pZm9ybXMgPSBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzb3VyY2UudW5pZm9ybXMgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHNvdXJjZS5kZWZpbmVzO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblx0XHR0aGlzLmNsaXBwaW5nID0gc291cmNlLmNsaXBwaW5nO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcblxuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBzb3VyY2UuZXh0ZW5zaW9ucztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBkYXRhID0gTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cblx0XHRkYXRhLnVuaWZvcm1zID0gdGhpcy51bmlmb3Jtcztcblx0XHRkYXRhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xuXHRcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKi9cblxuXHRmdW5jdGlvbiBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFZlY3RvcjMoKTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggUmF5LnByb3RvdHlwZSwge1xuXG5cdFx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCByYXkgKSB7XG5cblx0XHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0XHR9LFxuXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHYgKS5zdWIoIHRoaXMub3JpZ2luICkubm9ybWFsaXplKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJlY2FzdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcmVjYXN0KCB0ICkge1xuXG5cdFx0XHRcdHRoaXMub3JpZ2luLmNvcHkoIHRoaXMuYXQoIHQsIHYxICkgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcblx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5vcmlnaW4gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlU3FUb1BvaW50OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRcdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0XHRcdC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XG5cblx0XHRcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdFx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHNlZ0NlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgc2VnRGlyID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlU3FUb1NlZ21lbnQoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVEaXN0UmF5U2VnbWVudC5oXG5cdFx0XHRcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XG5cdFx0XHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG5cdFx0XHRcdC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XG5cdFx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxuXHRcdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cblx0XHRcdFx0c2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblx0XHRcdFx0c2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcblxuXHRcdFx0XHR2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcblx0XHRcdFx0dmFyIGEwMSA9IC0gdGhpcy5kaXJlY3Rpb24uZG90KCBzZWdEaXIgKTtcblx0XHRcdFx0dmFyIGIwID0gZGlmZi5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cdFx0XHRcdHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xuXHRcdFx0XHR2YXIgYyA9IGRpZmYubGVuZ3RoU3EoKTtcblx0XHRcdFx0dmFyIGRldCA9IE1hdGguYWJzKCAxIC0gYTAxICogYTAxICk7XG5cdFx0XHRcdHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuXHRcdFx0XHRpZiAoIGRldCA+IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXG5cblx0XHRcdFx0XHRzMCA9IGEwMSAqIGIxIC0gYjA7XG5cdFx0XHRcdFx0czEgPSBhMDEgKiBiMCAtIGIxO1xuXHRcdFx0XHRcdGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcblxuXHRcdFx0XHRcdGlmICggczAgPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHMxIDw9IGV4dERldCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAwXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGludkRldCA9IDEgLyBkZXQ7XG5cdFx0XHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcblx0XHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyByZWdpb24gMVxuXG5cdFx0XHRcdFx0XHRcdFx0czEgPSBzZWdFeHRlbnQ7XG5cdFx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA1XG5cblx0XHRcdFx0XHRcdFx0czEgPSAtIHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA0XG5cblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyByZWdpb24gM1xuXG5cdFx0XHRcdFx0XHRcdHMwID0gMDtcblx0XHRcdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAyXG5cblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcblx0XHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxuXG5cdFx0XHRcdFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcblxuXHRcdFx0XHRcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIgKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc3FyRGlzdDtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0U3BoZXJlKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRcdHYxLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luICk7XG5cdFx0XHRcdHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cdFx0XHRcdHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcblx0XHRcdFx0dmFyIHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcblxuXHRcdFx0XHRpZiAoIGQyID4gcmFkaXVzMiApIHJldHVybiBudWxsO1xuXG5cdFx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG5cdFx0XHRcdC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXG5cdFx0XHRcdHZhciB0MCA9IHRjYSAtIHRoYztcblxuXHRcdFx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG5cdFx0XHRcdHZhciB0MSA9IHRjYSArIHRoYztcblxuXHRcdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcblx0XHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG5cdFx0XHRcdC8vIGlmIGl0IGlzLCB0aGUgcmF5IGlzIGluc2lkZSB0aGUgc3BoZXJlLCBzbyByZXR1cm4gdGhlIHNlY29uZCBleGl0IHBvaW50IHNjYWxlZCBieSB0MSxcblx0XHRcdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuXHRcdFx0XHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0XHQvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuXHRcdFx0XHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBOdWxsIGlzIHByZWZlcmFibGUgdG8gdW5kZWZpbmVkIHNpbmNlIHVuZGVmaW5lZCBtZWFucy4uLi4gaXQgaXMgdW5kZWZpbmVkXG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcblxuXHRcdFx0cmV0dXJuIHQgPj0gMCA/IHQgOiBudWxsO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcblxuXHRcdFx0aWYgKCB0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmF0KCB0LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxuXG5cdFx0XHR2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XG5cblx0XHRcdGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uICggYm94LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xuXG5cdFx0XHR2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxuXHRcdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG5cdFx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuXHRcdFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG5cdFx0XHRpZiAoIGludmRpcnggPj0gMCApIHtcblxuXHRcdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cdFx0XHRcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW52ZGlyeSA+PSAwICkge1xuXG5cdFx0XHRcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cblx0XHRcdC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cblxuXHRcdFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcblxuXHRcdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcblxuXHRcdFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XG5cblx0XHRcdFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0XHR0em1heCA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0aWYgKCB0em1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0em1pbjtcblxuXHRcdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcblxuXHRcdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxuXG5cdFx0XHRpZiAoIHRtYXggPCAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RzQm94OiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XG5cblx0XHRcdH07XG5cblx0XHR9ICkoKSxcblxuXHRcdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuXHRcdFx0dmFyIGRpZmYgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIGVkZ2UxID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBlZGdlMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG5cblx0XHRcdFx0ZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xuXHRcdFx0XHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG5cdFx0XHRcdC8vIFNvbHZlIFEgKyB0KkQgPSBiMSpFMSArIGIyKkUyIChRID0ga0RpZmYsIEQgPSByYXkgZGlyZWN0aW9uLFxuXHRcdFx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XG5cdFx0XHRcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuXHRcdFx0XHQvLyAgIHxEb3QoRCxOKXwqYjIgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhFMSxRKSlcblx0XHRcdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcblx0XHRcdFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG5cdFx0XHRcdHZhciBzaWduO1xuXG5cdFx0XHRcdGlmICggRGROID4gMCApIHtcblxuXHRcdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0c2lnbiA9IDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggRGROIDwgMCApIHtcblxuXHRcdFx0XHRcdHNpZ24gPSAtIDE7XG5cdFx0XHRcdFx0RGROID0gLSBEZE47XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XG5cdFx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuXHRcdFx0XHQvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0XHRpZiAoIERkUXhFMiA8IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcblxuXHRcdFx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0XHRpZiAoIERkRTF4USA8IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cblx0XHRcdFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cblx0XHRcdFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuXHRcdFx0XHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRcdGlmICggUWROIDwgMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cblx0XHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG5cdFx0XHR0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcblx0XHRcdHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4NCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggcmF5ICkge1xuXG5cdFx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIExpbmUzKCBzdGFydCwgZW5kICkge1xuXG5cdFx0dGhpcy5zdGFydCA9ICggc3RhcnQgIT09IHVuZGVmaW5lZCApID8gc3RhcnQgOiBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFZlY3RvcjMoKTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggTGluZTMucHJvdG90eXBlLCB7XG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuXHRcdFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xuXHRcdFx0dGhpcy5lbmQuY29weSggZW5kICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cblx0XHRcdHRoaXMuc3RhcnQuY29weSggbGluZS5zdGFydCApO1xuXHRcdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0XHR9LFxuXG5cdFx0ZGVsdGE6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG5cdFx0fSxcblxuXHRcdGRpc3RhbmNlU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XG5cblx0XHR9LFxuXG5cdFx0ZGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcblxuXHRcdH0sXG5cblx0XHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG5cdFx0fSxcblxuXHRcdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHN0YXJ0UCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgc3RhcnRFbmQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICkge1xuXG5cdFx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuXHRcdFx0XHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG5cdFx0XHRcdHZhciBzdGFydEVuZDIgPSBzdGFydEVuZC5kb3QoIHN0YXJ0RW5kICk7XG5cdFx0XHRcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG5cdFx0XHRcdHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG5cdFx0XHRcdGlmICggY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRcdFx0XHR0ID0gX01hdGguY2xhbXAoIHQsIDAsIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHQ7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG5cdFx0fSxcblxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHRcdHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblx0XHRcdHRoaXMuZW5kLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFRyaWFuZ2xlKCBhLCBiLCBjICkge1xuXG5cdFx0dGhpcy5hID0gKCBhICE9PSB1bmRlZmluZWQgKSA/IGEgOiBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBWZWN0b3IzKCk7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFRyaWFuZ2xlLCB7XG5cblx0XHRub3JtYWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbCggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcblx0XHRcdFx0djAuc3ViVmVjdG9ycyggYSwgYiApO1xuXHRcdFx0XHRyZXN1bHQuY3Jvc3MoIHYwICk7XG5cblx0XHRcdFx0dmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XG5cdFx0XHRcdGlmICggcmVzdWx0TGVuZ3RoU3EgPiAwICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Ly8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcblx0XHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuXHRcdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBiYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0XHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0XHRcdHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRcdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuXHRcdFx0XHR2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XG5cdFx0XHRcdHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcblx0XHRcdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuXHRcdFx0XHR2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XG5cdFx0XHRcdHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuXHRcdFx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cdFx0XHRcdGlmICggZGVub20gPT09IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cblx0XHRcdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xuXHRcdFx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuXHRcdFx0XHR2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG5cdFx0XHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG5cdFx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQoIHBvaW50LCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdHZhciByZXN1bHQgPSBUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xuXG5cdFx0XHRcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKVxuXG5cdH0gKTtcblxuXHRPYmplY3QuYXNzaWduKCBUcmlhbmdsZS5wcm90b3R5cGUsIHtcblxuXHRcdHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHR0aGlzLmEuY29weSggYSApO1xuXHRcdFx0dGhpcy5iLmNvcHkoIGIgKTtcblx0XHRcdHRoaXMuYy5jb3B5KCBjICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcblxuXHRcdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xuXHRcdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuXHRcdFx0dGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcblxuXHRcdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcblx0XHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG5cdFx0XHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhcmVhOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYXJlYSgpIHtcblxuXHRcdFx0XHR2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xuXHRcdFx0XHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xuXG5cdFx0XHRcdHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG5cdFx0fSxcblxuXHRcdG5vcm1hbDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH0sXG5cblx0XHRwbGFuZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBQbGFuZSgpO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdFx0fSxcblxuXHRcdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHJldHVybiBUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0fSxcblxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHJldHVybiBUcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNUcmlhbmdsZSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHBsYW5lID0gbmV3IFBsYW5lKCk7XG5cdFx0XHR2YXIgZWRnZUxpc3QgPSBbIG5ldyBMaW5lMygpLCBuZXcgTGluZTMoKSwgbmV3IExpbmUzKCkgXTtcblx0XHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG5cblx0XHRcdFx0Ly8gcHJvamVjdCB0aGUgcG9pbnQgb250byB0aGUgcGxhbmUgb2YgdGhlIHRyaWFuZ2xlXG5cblx0XHRcdFx0cGxhbmUuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cdFx0XHRcdHBsYW5lLnByb2plY3RQb2ludCggcG9pbnQsIHByb2plY3RlZFBvaW50ICk7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHByb2plY3Rpb24gbGllcyB3aXRoaW4gdGhlIHRyaWFuZ2xlXG5cblx0XHRcdFx0aWYgKCB0aGlzLmNvbnRhaW5zUG9pbnQoIHByb2plY3RlZFBvaW50ICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiBzbywgdGhpcyBpcyB0aGUgY2xvc2VzdCBwb2ludFxuXG5cdFx0XHRcdFx0cmVzdWx0LmNvcHkoIHByb2plY3RlZFBvaW50ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGlmIG5vdCwgdGhlIHBvaW50IGZhbGxzIG91dHNpZGUgdGhlIHRyaWFuZ2xlLiB0aGUgcmVzdWx0IGlzIHRoZSBjbG9zZXN0IHBvaW50IHRvIHRoZSB0cmlhbmdsZSdzIGVkZ2VzIG9yIHZlcnRpY2VzXG5cblx0XHRcdFx0XHRlZGdlTGlzdFsgMCBdLnNldCggdGhpcy5hLCB0aGlzLmIgKTtcblx0XHRcdFx0XHRlZGdlTGlzdFsgMSBdLnNldCggdGhpcy5iLCB0aGlzLmMgKTtcblx0XHRcdFx0XHRlZGdlTGlzdFsgMiBdLnNldCggdGhpcy5jLCB0aGlzLmEgKTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVkZ2VMaXN0Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0ZWRnZUxpc3RbIGkgXS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwcm9qZWN0ZWRQb2ludCwgdHJ1ZSwgY2xvc2VzdFBvaW50ICk7XG5cblx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHByb2plY3RlZFBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCBjbG9zZXN0UG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0LmNvcHkoIGNsb3Nlc3RQb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH07XG5cblx0XHR9KCksXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cblx0XHRcdHJldHVybiB0cmlhbmdsZS5hLmVxdWFscyggdGhpcy5hICkgJiYgdHJpYW5nbGUuYi5lcXVhbHMoIHRoaXMuYiApICYmIHRyaWFuZ2xlLmMuZXF1YWxzKCB0aGlzLmMgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2gnO1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cblx0XHR0aGlzLmRyYXdNb2RlID0gVHJpYW5nbGVzRHJhd01vZGU7XG5cblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG5cdH1cblxuXHRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogTWVzaCxcblxuXHRcdGlzTWVzaDogdHJ1ZSxcblxuXHRcdHNldERyYXdNb2RlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmRyYXdNb2RlID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0XHR0aGlzLmRyYXdNb2RlID0gc291cmNlLmRyYXdNb2RlO1xuXG5cdFx0XHRpZiAoIHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMuc2xpY2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNvdXJjZS5tb3JwaFRhcmdldERpY3Rpb25hcnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlTW9ycGhUYXJnZXRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHR2YXIgbSwgbWwsIG5hbWU7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBtb3JwaEF0dHJpYnV0ZXMgKTtcblxuXHRcdFx0XHRpZiAoIGtleXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sga2V5c1sgMCBdIF07XG5cblx0XHRcdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRuYW1lID0gbW9ycGhBdHRyaWJ1dGVbIG0gXS5uYW1lIHx8IFN0cmluZyggbSApO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblxuXHRcdFx0XHRpZiAoIG1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIG1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRcdFx0Zm9yICggbSA9IDAsIG1sID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHRcdFx0XHRuYW1lID0gbW9ycGhUYXJnZXRzWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdHZhciByYXkgPSBuZXcgUmF5KCk7XG5cdFx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0XHR2YXIgdkEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHZCID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciB2QyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHZhciB0ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHRlbXBDID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHR2YXIgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHR2YXIgYmFyeWNvb3JkID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0ZnVuY3Rpb24gdXZJbnRlcnNlY3Rpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzICkge1xuXG5cdFx0XHRcdFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHAxLCBwMiwgcDMsIGJhcnljb29yZCApO1xuXG5cdFx0XHRcdHV2MS5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnggKTtcblx0XHRcdFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xuXHRcdFx0XHR1djMubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC56ICk7XG5cblx0XHRcdFx0dXYxLmFkZCggdXYyICkuYWRkKCB1djMgKTtcblxuXHRcdFx0XHRyZXR1cm4gdXYxLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApIHtcblxuXHRcdFx0XHR2YXIgaW50ZXJzZWN0O1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgbWF0ZXJpYWwuc2lkZSAhPT0gRG91YmxlU2lkZSwgcG9pbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XG5cblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXG5cdFx0XHRcdFx0b2JqZWN0OiBvYmplY3Rcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGEgKTtcblx0XHRcdFx0dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGIgKTtcblx0XHRcdFx0dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGMgKTtcblxuXHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgb2JqZWN0Lm1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgdkEsIHZCLCB2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdGlmICggdXYgKSB7XG5cblx0XHRcdFx0XHRcdHV2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYSApO1xuXHRcdFx0XHRcdFx0dXZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBiICk7XG5cdFx0XHRcdFx0XHR1dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGMgKTtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCB2QSwgdkIsIHZDLCB1dkEsIHV2QiwgdXZDICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBGYWNlMyggYSwgYiwgYywgVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gYTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG5cdFx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0XHRcdC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGlmICggcmF5LmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uO1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdHZhciBhLCBiLCBjO1xuXHRcdFx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRcdFx0dmFyIHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djtcblx0XHRcdFx0XHR2YXIgaSwgbDtcblxuXHRcdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gaW5kZXguY291bnQ7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0YSA9IGluZGV4LmdldFgoIGkgKTtcblx0XHRcdFx0XHRcdFx0YiA9IGluZGV4LmdldFgoIGkgKyAxICk7XG5cdFx0XHRcdFx0XHRcdGMgPSBpbmRleC5nZXRYKCBpICsgMiApO1xuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBpIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kaWNlcyBidWZmZXIgc2VtYW50aWNzXG5cdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdGEgPSBpO1xuXHRcdFx0XHRcdFx0XHRiID0gaSArIDE7XG5cdFx0XHRcdFx0XHRcdGMgPSBpICsgMjtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uaW5kZXggPSBhOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3Ncblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHR2YXIgZnZBLCBmdkIsIGZ2Qztcblx0XHRcdFx0XHR2YXIgaXNNdWx0aU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXHRcdFx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXHRcdFx0XHRcdHZhciB1dnM7XG5cblx0XHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblx0XHRcdFx0XHRpZiAoIGZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHV2cyA9IGZhY2VWZXJ0ZXhVdnM7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGYgXTtcblx0XHRcdFx0XHRcdHZhciBmYWNlTWF0ZXJpYWwgPSBpc011bHRpTWF0ZXJpYWwgPyBtYXRlcmlhbFsgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0aWYgKCBmYWNlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRmdkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHRcdFx0XHRmdkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG5cdFx0XHRcdFx0XHRmdkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXHRcdFx0XHRcdFx0XHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRcdFx0XHRcdFx0dkEuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdFx0XHRcdHZCLnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdFx0XHR2Qy5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XG5cblx0XHRcdFx0XHRcdFx0XHR2QS5hZGRTY2FsZWRWZWN0b3IoIHRlbXBBLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYSBdLCBmdkEgKSwgaW5mbHVlbmNlICk7XG5cdFx0XHRcdFx0XHRcdFx0dkIuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQi5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmIgXSwgZnZCICksIGluZmx1ZW5jZSApO1xuXHRcdFx0XHRcdFx0XHRcdHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dkEuYWRkKCBmdkEgKTtcblx0XHRcdFx0XHRcdFx0dkIuYWRkKCBmdkIgKTtcblx0XHRcdFx0XHRcdFx0dkMuYWRkKCBmdkMgKTtcblxuXHRcdFx0XHRcdFx0XHRmdkEgPSB2QTtcblx0XHRcdFx0XHRcdFx0ZnZCID0gdkI7XG5cdFx0XHRcdFx0XHRcdGZ2QyA9IHZDO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCBmYWNlTWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBmdkEsIGZ2QiwgZnZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHV2cyAmJiB1dnNbIGYgXSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciB1dnNfZiA9IHV2c1sgZiBdO1xuXHRcdFx0XHRcdFx0XHRcdHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XG5cdFx0XHRcdFx0XHRcdFx0dXZCLmNvcHkoIHV2c19mWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR1dkMuY29weSggdXZzX2ZbIDIgXSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCBmdkEsIGZ2QiwgZnZDLCB1dkEsIHV2QiwgdXZDICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlID0gZmFjZTtcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9KCkgKSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdlYkdMQmFja2dyb3VuZCggcmVuZGVyZXIsIHN0YXRlLCBnZW9tZXRyaWVzLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cblx0XHR2YXIgY2xlYXJDb2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcblx0XHR2YXIgY2xlYXJBbHBoYSA9IDA7XG5cblx0XHR2YXIgcGxhbmVDYW1lcmEsIHBsYW5lTWVzaDtcblx0XHR2YXIgYm94TWVzaDtcblxuXHRcdGZ1bmN0aW9uIHJlbmRlciggcmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0dmFyIGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuXG5cdFx0XHRpZiAoIGJhY2tncm91bmQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzQ29sb3IgKSB7XG5cblx0XHRcdFx0c2V0Q2xlYXIoIGJhY2tncm91bmQsIDEgKTtcblx0XHRcdFx0Zm9yY2VDbGVhciA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZW5kZXJlci5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5jbGVhciggcmVuZGVyZXIuYXV0b0NsZWFyQ29sb3IsIHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoLCByZW5kZXJlci5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIGJveE1lc2ggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGJveE1lc2ggPSBuZXcgTWVzaChcblx0XHRcdFx0XHRcdG5ldyBCb3hCdWZmZXJHZW9tZXRyeSggMSwgMSwgMSApLFxuXHRcdFx0XHRcdFx0bmV3IFNoYWRlck1hdGVyaWFsKCB7XG5cdFx0XHRcdFx0XHRcdHVuaWZvcm1zOiBTaGFkZXJMaWIuY3ViZS51bmlmb3Jtcyxcblx0XHRcdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuY3ViZS52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuY3ViZS5mcmFnbWVudFNoYWRlcixcblx0XHRcdFx0XHRcdFx0c2lkZTogQmFja1NpZGUsXG5cdFx0XHRcdFx0XHRcdGRlcHRoVGVzdDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGZvZzogZmFsc2Vcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcblx0XHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ3V2JyApO1xuXG5cdFx0XHRcdFx0Ym94TWVzaC5vbkJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRnZW9tZXRyaWVzLnVwZGF0ZSggYm94TWVzaC5nZW9tZXRyeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnRDdWJlLnZhbHVlID0gYmFja2dyb3VuZDtcblxuXHRcdFx0XHRyZW5kZXJMaXN0LnB1c2goIGJveE1lc2gsIGJveE1lc2guZ2VvbWV0cnksIGJveE1lc2gubWF0ZXJpYWwsIDAsIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIHBsYW5lQ2FtZXJhID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRwbGFuZUNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gMSwgMSwgMSwgLSAxLCAwLCAxICk7XG5cblx0XHRcdFx0XHRwbGFuZU1lc2ggPSBuZXcgTWVzaChcblx0XHRcdFx0XHRcdG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KCAyLCAyICksXG5cdFx0XHRcdFx0XHRuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgZGVwdGhUZXN0OiBmYWxzZSwgZGVwdGhXcml0ZTogZmFsc2UsIGZvZzogZmFsc2UgfSApXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGdlb21ldHJpZXMudXBkYXRlKCBwbGFuZU1lc2guZ2VvbWV0cnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLm1hcCA9IGJhY2tncm91bmQ7XG5cblx0XHRcdFx0Ly8gVE9ETyBQdXNoIHRoaXMgdG8gcmVuZGVyTGlzdFxuXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggcGxhbmVDYW1lcmEsIG51bGwsIHBsYW5lTWVzaC5nZW9tZXRyeSwgcGxhbmVNZXNoLm1hdGVyaWFsLCBwbGFuZU1lc2gsIG51bGwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0Q2xlYXIoIGNvbG9yLCBhbHBoYSApIHtcblxuXHRcdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhciggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgYWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0Z2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBjbGVhckNvbG9yO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHRcdFx0Y2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XG5cdFx0XHRcdGNsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xuXHRcdFx0XHRzZXRDbGVhciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xuXG5cdFx0XHR9LFxuXHRcdFx0Z2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBjbGVhckFscGhhO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCBhbHBoYSApIHtcblxuXHRcdFx0XHRjbGVhckFscGhhID0gYWxwaGE7XG5cdFx0XHRcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XG5cblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IHJlbmRlclxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xuXG5cdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG5cblx0XHR9IGVsc2UgaWYgKCBhLnByb2dyYW0gJiYgYi5wcm9ncmFtICYmIGEucHJvZ3JhbSAhPT0gYi5wcm9ncmFtICkge1xuXG5cdFx0XHRyZXR1cm4gYS5wcm9ncmFtLmlkIC0gYi5wcm9ncmFtLmlkO1xuXG5cdFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcblxuXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xuXG5cdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdHJldHVybiBhLnogLSBiLno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcblxuXHRcdGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcblxuXHRcdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xuXG5cdFx0fSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG5cdFx0XHRyZXR1cm4gYi56IC0gYS56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlckxpc3QoKSB7XG5cblx0XHR2YXIgcmVuZGVySXRlbXMgPSBbXTtcblx0XHR2YXIgcmVuZGVySXRlbXNJbmRleCA9IDA7XG5cblx0XHR2YXIgb3BhcXVlID0gW107XG5cdFx0dmFyIHRyYW5zcGFyZW50ID0gW107XG5cblx0XHRmdW5jdGlvbiBpbml0KCkge1xuXG5cdFx0XHRyZW5kZXJJdGVtc0luZGV4ID0gMDtcblxuXHRcdFx0b3BhcXVlLmxlbmd0aCA9IDA7XG5cdFx0XHR0cmFuc3BhcmVudC5sZW5ndGggPSAwO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHosIGdyb3VwICkge1xuXG5cdFx0XHR2YXIgcmVuZGVySXRlbSA9IHJlbmRlckl0ZW1zWyByZW5kZXJJdGVtc0luZGV4IF07XG5cblx0XHRcdGlmICggcmVuZGVySXRlbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJlbmRlckl0ZW0gPSB7XG5cdFx0XHRcdFx0aWQ6IG9iamVjdC5pZCxcblx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcblx0XHRcdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXG5cdFx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxuXHRcdFx0XHRcdHByb2dyYW06IG1hdGVyaWFsLnByb2dyYW0sXG5cdFx0XHRcdFx0cmVuZGVyT3JkZXI6IG9iamVjdC5yZW5kZXJPcmRlcixcblx0XHRcdFx0XHR6OiB6LFxuXHRcdFx0XHRcdGdyb3VwOiBncm91cFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHJlbmRlckl0ZW1zWyByZW5kZXJJdGVtc0luZGV4IF0gPSByZW5kZXJJdGVtO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XG5cdFx0XHRcdHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xuXHRcdFx0XHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0XHRcdHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHRcdFx0cmVuZGVySXRlbS5wcm9ncmFtID0gbWF0ZXJpYWwucHJvZ3JhbTtcblx0XHRcdFx0cmVuZGVySXRlbS5yZW5kZXJPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcblx0XHRcdFx0cmVuZGVySXRlbS56ID0gejtcblx0XHRcdFx0cmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xuXG5cdFx0XHR9XG5cblx0XHRcdCggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgPyB0cmFuc3BhcmVudCA6IG9wYXF1ZSApLnB1c2goIHJlbmRlckl0ZW0gKTtcblxuXHRcdFx0cmVuZGVySXRlbXNJbmRleCArKztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNvcnQoKSB7XG5cblx0XHRcdGlmICggb3BhcXVlLmxlbmd0aCA+IDEgKSBvcGFxdWUuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRcdGlmICggdHJhbnNwYXJlbnQubGVuZ3RoID4gMSApIHRyYW5zcGFyZW50LnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdG9wYXF1ZTogb3BhcXVlLFxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50LFxuXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cHVzaDogcHVzaCxcblxuXHRcdFx0c29ydDogc29ydFxuXHRcdH07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdHMoKSB7XG5cblx0XHR2YXIgbGlzdHMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGdldCggc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdFx0dmFyIGhhc2ggPSBzY2VuZS5pZCArICcsJyArIGNhbWVyYS5pZDtcblx0XHRcdHZhciBsaXN0ID0gbGlzdHNbIGhhc2ggXTtcblxuXHRcdFx0aWYgKCBsaXN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlckxpc3RzOicsIGhhc2ggKTtcblxuXHRcdFx0XHRsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdCgpO1xuXHRcdFx0XHRsaXN0c1sgaGFzaCBdID0gbGlzdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGlzdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRcdGxpc3RzID0ge307XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGFic051bWVyaWNhbFNvcnQoIGEsIGIgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIGJbIDEgXSApIC0gTWF0aC5hYnMoIGFbIDEgXSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTE1vcnBodGFyZ2V0cyggZ2wgKSB7XG5cblx0XHR2YXIgaW5mbHVlbmNlc0xpc3QgPSB7fTtcblx0XHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcHJvZ3JhbSApIHtcblxuXHRcdFx0dmFyIG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0XHR2YXIgbGVuZ3RoID0gb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7XG5cblx0XHRcdHZhciBpbmZsdWVuY2VzID0gaW5mbHVlbmNlc0xpc3RbIGdlb21ldHJ5LmlkIF07XG5cblx0XHRcdGlmICggaW5mbHVlbmNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGluaXRpYWxpc2UgbGlzdFxuXG5cdFx0XHRcdGluZmx1ZW5jZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpbmZsdWVuY2VzWyBpIF0gPSBbIGksIDAgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5mbHVlbmNlc0xpc3RbIGdlb21ldHJ5LmlkIF0gPSBpbmZsdWVuY2VzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBtYXRlcmlhbC5tb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0dmFyIG1vcnBoTm9ybWFscyA9IG1hdGVyaWFsLm1vcnBoTm9ybWFscyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHQvLyBSZW1vdmUgY3VycmVudCBtb3JwaEF0dHJpYnV0ZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBpbmZsdWVuY2VbIDEgXSAhPT0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xuXHRcdFx0XHRcdGlmICggbW9ycGhOb3JtYWxzICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb2xsZWN0IGluZmx1ZW5jZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XG5cblx0XHRcdFx0aW5mbHVlbmNlWyAwIF0gPSBpO1xuXHRcdFx0XHRpbmZsdWVuY2VbIDEgXSA9IG9iamVjdEluZmx1ZW5jZXNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbmZsdWVuY2VzLnNvcnQoIGFic051bWVyaWNhbFNvcnQgKTtcblxuXHRcdFx0Ly8gQWRkIG1vcnBoQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA4OyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSBpbmZsdWVuY2VbIDAgXTtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBpbmZsdWVuY2VbIDEgXTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhUYXJnZXRzWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0XHRpZiAoIG1vcnBoTm9ybWFscyApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoTm9ybWFsc1sgaW5kZXggXSApO1xuXG5cdFx0XHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgbW9ycGhJbmZsdWVuY2VzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcblxuXHRcdHZhciBtb2RlO1xuXG5cdFx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cblx0XHRcdG1vZGUgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHRcdHZhciB0eXBlLCBieXRlc1BlckVsZW1lbnQ7XG5cblx0XHRmdW5jdGlvbiBzZXRJbmRleCggdmFsdWUgKSB7XG5cblx0XHRcdHR5cGUgPSB2YWx1ZS50eXBlO1xuXHRcdFx0Ynl0ZXNQZXJFbGVtZW50ID0gdmFsdWUuYnl0ZXNQZXJFbGVtZW50O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRcdGdsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50ICk7XG5cblx0XHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XG5cdFx0XHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xuXG5cdFx0XHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXHRcdFx0ZWxzZSBpZiAoIG1vZGUgPT09IGdsLlBPSU5UUyApIGluZm9SZW5kZXIucG9pbnRzICs9IGNvdW50O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG5cdFx0XHRpbmZvUmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xuXG5cdFx0XHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudCAvIDM7XG5cdFx0XHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudDtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xuXHRcdHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcblx0XHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcblx0XHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdlYkdMQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvUmVuZGVyICkge1xuXG5cdFx0dmFyIG1vZGU7XG5cblx0XHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuXHRcdFx0bW9kZSA9IHZhbHVlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRcdGdsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xuXG5cdFx0XHRpbmZvUmVuZGVyLmNhbGxzICsrO1xuXHRcdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcblxuXHRcdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcblx0XHRcdGVsc2UgaWYgKCBtb2RlID09PSBnbC5QT0lOVFMgKSBpbmZvUmVuZGVyLnBvaW50cyArPSBjb3VudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIHN0YXJ0LCBjb3VudCApIHtcblxuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGlmICggcG9zaXRpb24uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRjb3VudCA9IHBvc2l0aW9uLmRhdGEuY291bnQ7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgc3RhcnQsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XG5cdFx0XHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50ICogZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQ7XG5cblx0XHRcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCAqIGNvdW50IC8gMztcblx0XHRcdGVsc2UgaWYgKCBtb2RlID09PSBnbC5QT0lOVFMgKSBpbmZvUmVuZGVyLnBvaW50cyArPSBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCAqIGNvdW50O1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG5cdFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdFx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBXZWJHTEdlb21ldHJpZXMoIGdsLCBhdHRyaWJ1dGVzLCBpbmZvTWVtb3J5ICkge1xuXG5cdFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcblx0XHR2YXIgd2lyZWZyYW1lQXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gb25HZW9tZXRyeURpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XG5cdFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHRpZiAoIGJ1ZmZlcmdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKCBidWZmZXJnZW9tZXRyeS5pbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuXHRcdFx0ZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cblx0XHRcdC8vIFRPRE8gUmVtb3ZlIGR1cGxpY2F0ZSBjb2RlXG5cblx0XHRcdHZhciBhdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGVzLnJlbW92ZSggYXR0cmlidXRlICk7XG5cdFx0XHRcdGRlbGV0ZSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGJ1ZmZlcmdlb21ldHJ5LmlkIF07XG5cblx0XHRcdGlmICggYXR0cmlidXRlICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKCBhdHRyaWJ1dGUgKTtcblx0XHRcdFx0ZGVsZXRlIHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGJ1ZmZlcmdlb21ldHJ5LmlkIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0aW5mb01lbW9yeS5nZW9tZXRyaWVzIC0tO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0KCBvYmplY3QsIGdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0XHRpZiAoIGJ1ZmZlcmdlb21ldHJ5ICkgcmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xuXG5cdFx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IGJ1ZmZlcmdlb21ldHJ5O1xuXG5cdFx0XHRpbmZvTWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0XHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZSggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0YXR0cmlidXRlcy51cGRhdGUoIGluZGV4LCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG1vcnBoIHRhcmdldHNcblxuXHRcdFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlc1sgZ2VvbWV0cnkuaWQgXTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgKSByZXR1cm4gYXR0cmlidXRlO1xuXG5cdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRcdC8vIGNvbnNvbGUudGltZSggJ3dpcmVmcmFtZScgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeUluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IGdlb21ldHJ5SW5kZXguYXJyYXk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0dmFyIGEgPSBhcnJheVsgaSArIDAgXTtcblx0XHRcdFx0XHR2YXIgYiA9IGFycmF5WyBpICsgMSBdO1xuXHRcdFx0XHRcdHZhciBjID0gYXJyYXlbIGkgKyAyIF07XG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gZ2VvbWV0cnlBdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gaSArIDA7XG5cdFx0XHRcdFx0dmFyIGIgPSBpICsgMTtcblx0XHRcdFx0XHR2YXIgYyA9IGkgKyAyO1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcblxuXHRcdFx0YXR0cmlidXRlID0gbmV3ICggYXJyYXlNYXgoIGluZGljZXMgKSA+IDY1NTM1ID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGljZXMsIDEgKTtcblxuXHRcdFx0YXR0cmlidXRlcy51cGRhdGUoIGF0dHJpYnV0ZSwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuXHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlc1sgZ2VvbWV0cnkuaWQgXSA9IGF0dHJpYnV0ZTtcblxuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cblx0XHRcdGdldFdpcmVmcmFtZUF0dHJpYnV0ZTogZ2V0V2lyZWZyYW1lQXR0cmlidXRlXG5cblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xPYmplY3RzKCBnZW9tZXRyaWVzLCBpbmZvUmVuZGVyICkge1xuXG5cdFx0dmFyIHVwZGF0ZUxpc3QgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZnJhbWUgPSBpbmZvUmVuZGVyLmZyYW1lO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cdFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldCggb2JqZWN0LCBnZW9tZXRyeSApO1xuXG5cdFx0XHQvLyBVcGRhdGUgb25jZSBwZXIgZnJhbWVcblxuXHRcdFx0aWYgKCB1cGRhdGVMaXN0WyBidWZmZXJnZW9tZXRyeS5pZCBdICE9PSBmcmFtZSApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cmllcy51cGRhdGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XG5cblx0XHRcdFx0dXBkYXRlTGlzdFsgYnVmZmVyZ2VvbWV0cnkuaWQgXSA9IGZyYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRcdHVwZGF0ZUxpc3QgPSB7fTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cblx0XHRcdHVwZGF0ZTogdXBkYXRlLFxuXHRcdFx0ZGlzcG9zZTogZGlzcG9zZVxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSB7XG5cblx0XHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFNoYWRlciggZ2wsIHR5cGUsIHN0cmluZyApIHtcblxuXHRcdHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTtcblxuXHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcblxuXHRcdGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXCd0IGNvbXBpbGUuJyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cblx0XHR9XG5cblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxuXHRcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cblx0XHRyZXR1cm4gc2hhZGVyO1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0dmFyIHByb2dyYW1JZENvdW50ID0gMDtcblxuXHRmdW5jdGlvbiBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICkge1xuXG5cdFx0c3dpdGNoICggZW5jb2RpbmcgKSB7XG5cblx0XHRcdGNhc2UgTGluZWFyRW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbICdMaW5lYXInLCAnKCB2YWx1ZSApJyBdO1xuXHRcdFx0Y2FzZSBzUkdCRW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbICdzUkdCJywgJyggdmFsdWUgKScgXTtcblx0XHRcdGNhc2UgUkdCRUVuY29kaW5nOlxuXHRcdFx0XHRyZXR1cm4gWyAnUkdCRScsICcoIHZhbHVlICknIF07XG5cdFx0XHRjYXNlIFJHQk03RW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbICdSR0JNJywgJyggdmFsdWUsIDcuMCApJyBdO1xuXHRcdFx0Y2FzZSBSR0JNMTZFbmNvZGluZzpcblx0XHRcdFx0cmV0dXJuIFsgJ1JHQk0nLCAnKCB2YWx1ZSwgMTYuMCApJyBdO1xuXHRcdFx0Y2FzZSBSR0JERW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbICdSR0JEJywgJyggdmFsdWUsIDI1Ni4wICknIF07XG5cdFx0XHRjYXNlIEdhbW1hRW5jb2Rpbmc6XG5cdFx0XHRcdHJldHVybiBbICdHYW1tYScsICcoIHZhbHVlLCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKScgXTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ3Vuc3VwcG9ydGVkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIGVuY29kaW5nICkge1xuXG5cdFx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XG5cdFx0cmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gJyArIGNvbXBvbmVudHNbIDAgXSArICdUb0xpbmVhcicgKyBjb21wb25lbnRzWyAxIF0gKyAnOyB9JztcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIGVuY29kaW5nICkge1xuXG5cdFx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XG5cdFx0cmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG8nICsgY29tcG9uZW50c1sgMCBdICsgY29tcG9uZW50c1sgMSBdICsgJzsgfSc7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgdG9uZU1hcHBpbmcgKSB7XG5cblx0XHR2YXIgdG9uZU1hcHBpbmdOYW1lO1xuXG5cdFx0c3dpdGNoICggdG9uZU1hcHBpbmcgKSB7XG5cblx0XHRcdGNhc2UgTGluZWFyVG9uZU1hcHBpbmc6XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdMaW5lYXInO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBSZWluaGFyZFRvbmVNYXBwaW5nOlxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnUmVpbmhhcmQnO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmc6XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdVbmNoYXJ0ZWQyJztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgQ2luZW9uVG9uZU1hcHBpbmc6XG5cdFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdPcHRpbWl6ZWRDaW5lb24nO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAndW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6ICcgKyB0b25lTWFwcGluZyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuICd2ZWMzICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gJyArIHRvbmVNYXBwaW5nTmFtZSArICdUb25lTWFwcGluZyggY29sb3IgKTsgfSc7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXJFeHRlbnNpb25zICkge1xuXG5cdFx0ZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cblx0XHR2YXIgY2h1bmtzID0gW1xuXHRcdFx0KCBleHRlbnNpb25zLmRlcml2YXRpdmVzIHx8IHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWIHx8IHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nICkgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsXG5cdFx0XHQoIGV4dGVuc2lvbnMuZnJhZ0RlcHRoIHx8IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlJyA6ICcnLFxuXHRcdFx0KCBleHRlbnNpb25zLmRyYXdCdWZmZXJzICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ1dFQkdMX2RyYXdfYnVmZmVycycgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlJyA6ICcnLFxuXHRcdFx0KCBleHRlbnNpb25zLnNoYWRlclRleHR1cmVMT0QgfHwgcGFyYW1ldGVycy5lbnZNYXAgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGUnIDogJydcblx0XHRdO1xuXG5cdFx0cmV0dXJuIGNodW5rcy5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcblxuXHRcdHZhciBjaHVua3MgPSBbXTtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICkge1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlQXR0cmliKCBwcm9ncmFtLCBpICk7XG5cdFx0XHR2YXIgbmFtZSA9IGluZm8ubmFtZTtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOicsIG5hbWUsIGkgKTtcblxuXHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcblxuXHRcdHJldHVybiBzdHJpbmcgIT09ICcnO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZXBsYWNlTGlnaHROdW1zKCBzdHJpbmcsIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHQucmVwbGFjZSggL05VTV9ESVJfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRzIClcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApXG5cdFx0XHQucmVwbGFjZSggL05VTV9SRUNUX0FSRUFfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUmVjdEFyZWFMaWdodHMgKVxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fUE9JTlRfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMgKVxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0cmV0dXJuIHN0cmluZ1xuXHRcdFx0LnJlcGxhY2UoIC9OVU1fQ0xJUFBJTkdfUExBTkVTL2csIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMgKVxuXHRcdFx0LnJlcGxhY2UoIC9VTklPTl9DTElQUElOR19QTEFORVMvZywgKCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzIC0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uICkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VJbmNsdWRlcyggc3RyaW5nICkge1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLl0rKT4vZ207XG5cblx0XHRmdW5jdGlvbiByZXBsYWNlKCBtYXRjaCwgaW5jbHVkZSApIHtcblxuXHRcdFx0dmFyIHJlcGxhY2UgPSBTaGFkZXJDaHVua1sgaW5jbHVkZSBdO1xuXG5cdFx0XHRpZiAoIHJlcGxhY2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW4gbm90IHJlc29sdmUgI2luY2x1ZGUgPCcgKyBpbmNsdWRlICsgJz4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBhcnNlSW5jbHVkZXMoIHJlcGxhY2UgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1bnJvbGxMb29wcyggc3RyaW5nICkge1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvI3ByYWdtYSB1bnJvbGxfbG9vcFtcXHNdKz9mb3IgXFwoIGludCBpIFxcPSAoXFxkKylcXDsgaSA8IChcXGQrKVxcOyBpIFxcK1xcKyBcXCkgXFx7KFtcXHNcXFNdKz8pKD89XFx9KVxcfS9nO1xuXG5cdFx0ZnVuY3Rpb24gcmVwbGFjZSggbWF0Y2gsIHN0YXJ0LCBlbmQsIHNuaXBwZXQgKSB7XG5cblx0XHRcdHZhciB1bnJvbGwgPSAnJztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSBwYXJzZUludCggc3RhcnQgKTsgaSA8IHBhcnNlSW50KCBlbmQgKTsgaSArKyApIHtcblxuXHRcdFx0XHR1bnJvbGwgKz0gc25pcHBldC5yZXBsYWNlKCAvXFxbIGkgXFxdL2csICdbICcgKyBpICsgJyBdJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bnJvbGw7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgZXh0ZW5zaW9ucywgY29kZSwgbWF0ZXJpYWwsIHNoYWRlciwgcGFyYW1ldGVycyApIHtcblxuXHRcdHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cblx0XHR2YXIgZGVmaW5lcyA9IG1hdGVyaWFsLmRlZmluZXM7XG5cblx0XHR2YXIgdmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlcjtcblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXI7XG5cblx0XHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwICkge1xuXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRic7XG5cblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdFx0dmFyIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGTEVDVElPTic7XG5cdFx0dmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcblxuXHRcdFx0XHRjYXNlIEN1YmVSZWZsZWN0aW9uTWFwcGluZzpcblx0XHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRjYXNlIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRV9VVic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcblx0XHRcdFx0Y2FzZSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcblx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG5cdFx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcblxuXHRcdFx0XHRjYXNlIE11bHRpcGx5T3BlcmF0aW9uOlxuXHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBNaXhPcGVyYXRpb246XG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBBZGRPcGVyYXRpb246XG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX0FERCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBjdXN0b21FeHRlbnNpb25zID0gZ2VuZXJhdGVFeHRlbnNpb25zKCBtYXRlcmlhbC5leHRlbnNpb25zLCBwYXJhbWV0ZXJzLCBleHRlbnNpb25zICk7XG5cblx0XHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0dmFyIHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cblx0XHRpZiAoIG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHByZWZpeFZlcnRleCA9IFtcblxuXHRcdFx0XHRjdXN0b21EZWZpbmVzXG5cblx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG5cdFx0XHRpZiAoIHByZWZpeFZlcnRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHByZWZpeFZlcnRleCArPSAnXFxuJztcblxuXHRcdFx0fVxuXG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9IFtcblxuXHRcdFx0XHRjdXN0b21FeHRlbnNpb25zLFxuXHRcdFx0XHRjdXN0b21EZWZpbmVzXG5cblx0XHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG5cdFx0XHRpZiAoIHByZWZpeEZyYWdtZW50Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0cHJlZml4RnJhZ21lbnQgKz0gJ1xcbic7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHByZWZpeFZlcnRleCA9IFtcblxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7Jyxcblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBzaGFkZXIubmFtZSxcblxuXHRcdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcblxuXHRcdFx0XHQnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxuXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgJiYgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNraW5uaW5nID8gJyNkZWZpbmUgVVNFX1NLSU5OSU5HJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7Jyxcblx0XHRcdFx0J3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7Jyxcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXG5cdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG5cdFx0XHRcdCcjaWZkZWYgVVNFX0NPTE9SJyxcblxuXHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjsnLFxuXG5cdFx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHRcdCcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXG5cblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxuXHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7Jyxcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXG5cblx0XHRcdFx0J1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxuXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXG5cblx0XHRcdFx0J1x0I2Vsc2UnLFxuXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXG5cblx0XHRcdFx0J1x0I2VuZGlmJyxcblxuXHRcdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0XHQnI2lmZGVmIFVTRV9TS0lOTklORycsXG5cblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7JyxcblxuXHRcdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0XHQnXFxuJ1xuXG5cdFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuXHRcdFx0cHJlZml4RnJhZ21lbnQgPSBbXG5cblx0XHRcdFx0Y3VzdG9tRXh0ZW5zaW9ucyxcblxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7Jyxcblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBzaGFkZXIubmFtZSxcblxuXHRcdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxuXG5cdFx0XHRcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5ncmFkaWVudE1hcCA/ICcjZGVmaW5lIFVTRV9HUkFESUVOVE1BUCcgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgPyAnI2RlZmluZSBQUkVNVUxUSVBMSUVEX0FMUEhBJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPyAnI2RlZmluZSBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSA/ICcjZGVmaW5lIFRFWFRVUkVfTE9EX0VYVCcgOiAnJyxcblxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7Jyxcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gJyNkZWZpbmUgVE9ORV9NQVBQSU5HJyA6ICcnLFxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IFNoYWRlckNodW5rWyAndG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCcgXSA6ICcnLCAvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHRvbmVNYXBwaW5nKCkgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xuXHRcdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oICd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKSA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuZGl0aGVyaW5nID8gJyNkZWZpbmUgRElUSEVSSU5HJyA6ICcnLFxuXG5cdFx0XHRcdCggcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLm1hcEVuY29kaW5nIHx8IHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgfHwgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nICkgPyBTaGFkZXJDaHVua1sgJ2VuY29kaW5nc19wYXJzX2ZyYWdtZW50JyBdIDogJycsIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdmFyaW91cyBlbmNvZGluZy9kZWNvZGluZyBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XG5cdFx0XHRcdHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdtYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5tYXBFbmNvZGluZyApIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdlbnZNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyApIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBFbmNvZGluZyA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggJ2VtaXNzaXZlTWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBFbmNvZGluZyApIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgPyBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oICdsaW5lYXJUb091dHB1dFRleGVsJywgcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyApIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgPyAnI2RlZmluZSBERVBUSF9QQUNLSU5HICcgKyBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgOiAnJyxcblxuXHRcdFx0XHQnXFxuJ1xuXG5cdFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuXHRcdH1cblxuXHRcdHZlcnRleFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIHZlcnRleFNoYWRlciApO1xuXHRcdHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXMoIHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyApO1xuXHRcdHZlcnRleFNoYWRlciA9IHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyggdmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzICk7XG5cblx0XHRmcmFnbWVudFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIGZyYWdtZW50U2hhZGVyICk7XG5cdFx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xuXHRcdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUNsaXBwaW5nUGxhbmVOdW1zKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xuXG5cdFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHMoIHZlcnRleFNoYWRlciApO1xuXHRcdGZyYWdtZW50U2hhZGVyID0gdW5yb2xsTG9vcHMoIGZyYWdtZW50U2hhZGVyICk7XG5cblx0XHR2YXIgdmVydGV4R2xzbCA9IHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcblx0XHR2YXIgZnJhZ21lbnRHbHNsID0gcHJlZml4RnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlcjtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XG5cdFx0Ly8gY29uc29sZS5sb2coICcqRlJBR01FTlQqJywgZnJhZ21lbnRHbHNsICk7XG5cblx0XHR2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBXZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcblx0XHR2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFdlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcblxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cblxuXHRcdGlmICggbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG5cdFx0XHQvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xuXG5cdFx0fVxuXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKS50cmltKCk7XG5cdFx0dmFyIHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsVmVydGV4U2hhZGVyICkudHJpbSgpO1xuXHRcdHZhciBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKS50cmltKCk7XG5cblx0XHR2YXIgcnVubmFibGUgPSB0cnVlO1xuXHRcdHZhciBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICcqKlZFUlRFWCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbFZlcnRleFNoYWRlciApICk7XG5cdFx0Ly8gY29uc29sZS5sb2coICcqKkZSQUdNRU5UKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsRnJhZ21lbnRTaGFkZXIgKSApO1xuXG5cdFx0aWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0cnVubmFibGUgPSBmYWxzZTtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUHJvZ3JhbTogc2hhZGVyIGVycm9yOiAnLCBnbC5nZXRFcnJvcigpLCAnZ2wuVkFMSURBVEVfU1RBVFVTJywgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTICksICdnbC5nZXRQcm9ncmFtSW5mb0xvZycsIHByb2dyYW1Mb2csIHZlcnRleExvZywgZnJhZ21lbnRMb2cgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHByb2dyYW1Mb2cgIT09ICcnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XG5cblx0XHR9IGVsc2UgaWYgKCB2ZXJ0ZXhMb2cgPT09ICcnIHx8IGZyYWdtZW50TG9nID09PSAnJyApIHtcblxuXHRcdFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRpZiAoIGhhdmVEaWFnbm9zdGljcyApIHtcblxuXHRcdFx0dGhpcy5kaWFnbm9zdGljcyA9IHtcblxuXHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXG5cdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcblxuXHRcdFx0XHRwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxuXG5cdFx0XHRcdHZlcnRleFNoYWRlcjoge1xuXG5cdFx0XHRcdFx0bG9nOiB2ZXJ0ZXhMb2csXG5cdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XG5cblx0XHRcdFx0XHRsb2c6IGZyYWdtZW50TG9nLFxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4RnJhZ21lbnRcblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHQvLyBjbGVhbiB1cFxuXG5cdFx0Z2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xuXHRcdGdsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cdFx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cblx0XHR2YXIgY2FjaGVkVW5pZm9ybXM7XG5cblx0XHR0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2FjaGVkVW5pZm9ybXMgPSBuZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xuXG5cdFx0fTtcblxuXHRcdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXG5cblx0XHR2YXIgY2FjaGVkQXR0cmlidXRlcztcblxuXHRcdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xuXG5cdFx0fTtcblxuXHRcdC8vIGZyZWUgcmVzb3VyY2VcblxuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Z2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXHRcdFx0dGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG5cdFx0fTtcblxuXHRcdC8vIERFUFJFQ0FURURcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG5cblx0XHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLicgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cblx0XHQvL1xuXG5cdFx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy51c2VkVGltZXMgPSAxO1xuXHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xQcm9ncmFtcyggcmVuZGVyZXIsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApIHtcblxuXHRcdHZhciBwcm9ncmFtcyA9IFtdO1xuXG5cdFx0dmFyIHNoYWRlcklEcyA9IHtcblx0XHRcdE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuXHRcdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuXHRcdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcblx0XHRcdE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdFx0TWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuXHRcdFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG5cdFx0XHRNZXNoVG9vbk1hdGVyaWFsOiAncGhvbmcnLFxuXHRcdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG5cdFx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcblx0XHRcdExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcblx0XHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcblx0XHRcdFNoYWRvd01hdGVyaWFsOiAnc2hhZG93J1xuXHRcdH07XG5cblx0XHR2YXIgcGFyYW1ldGVyTmFtZXMgPSBbXG5cdFx0XHRcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJtYXBFbmNvZGluZ1wiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIiwgXCJlbnZNYXBFbmNvZGluZ1wiLFxuXHRcdFx0XCJsaWdodE1hcFwiLCBcImFvTWFwXCIsIFwiZW1pc3NpdmVNYXBcIiwgXCJlbWlzc2l2ZU1hcEVuY29kaW5nXCIsIFwiYnVtcE1hcFwiLCBcIm5vcm1hbE1hcFwiLCBcImRpc3BsYWNlbWVudE1hcFwiLCBcInNwZWN1bGFyTWFwXCIsXG5cdFx0XHRcInJvdWdobmVzc01hcFwiLCBcIm1ldGFsbmVzc01hcFwiLCBcImdyYWRpZW50TWFwXCIsXG5cdFx0XHRcImFscGhhTWFwXCIsIFwiY29tYmluZVwiLCBcInZlcnRleENvbG9yc1wiLCBcImZvZ1wiLCBcInVzZUZvZ1wiLCBcImZvZ0V4cFwiLFxuXHRcdFx0XCJmbGF0U2hhZGluZ1wiLCBcInNpemVBdHRlbnVhdGlvblwiLCBcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcIiwgXCJza2lubmluZ1wiLFxuXHRcdFx0XCJtYXhCb25lc1wiLCBcInVzZVZlcnRleFRleHR1cmVcIiwgXCJtb3JwaFRhcmdldHNcIiwgXCJtb3JwaE5vcm1hbHNcIixcblx0XHRcdFwibWF4TW9ycGhUYXJnZXRzXCIsIFwibWF4TW9ycGhOb3JtYWxzXCIsIFwicHJlbXVsdGlwbGllZEFscGhhXCIsXG5cdFx0XHRcIm51bURpckxpZ2h0c1wiLCBcIm51bVBvaW50TGlnaHRzXCIsIFwibnVtU3BvdExpZ2h0c1wiLCBcIm51bUhlbWlMaWdodHNcIiwgXCJudW1SZWN0QXJlYUxpZ2h0c1wiLFxuXHRcdFx0XCJzaGFkb3dNYXBFbmFibGVkXCIsIFwic2hhZG93TWFwVHlwZVwiLCBcInRvbmVNYXBwaW5nXCIsICdwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cycsXG5cdFx0XHRcImFscGhhVGVzdFwiLCBcImRvdWJsZVNpZGVkXCIsIFwiZmxpcFNpZGVkXCIsIFwibnVtQ2xpcHBpbmdQbGFuZXNcIiwgXCJudW1DbGlwSW50ZXJzZWN0aW9uXCIsIFwiZGVwdGhQYWNraW5nXCIsIFwiZGl0aGVyaW5nXCJcblx0XHRdO1xuXG5cblx0XHRmdW5jdGlvbiBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcblx0XHRcdHZhciBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xuXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICkge1xuXG5cdFx0XHRcdHJldHVybiAxMDI0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcblx0XHRcdFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXG5cdFx0XHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xuXHRcdFx0XHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXG5cblx0XHRcdFx0dmFyIG5WZXJ0ZXhVbmlmb3JtcyA9IGNhcGFiaWxpdGllcy5tYXhWZXJ0ZXhVbmlmb3Jtcztcblx0XHRcdFx0dmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcblxuXHRcdFx0XHR2YXIgbWF4Qm9uZXMgPSBNYXRoLm1pbiggblZlcnRleE1hdHJpY2VzLCBib25lcy5sZW5ndGggKTtcblxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgYm9uZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogU2tlbGV0b24gaGFzICcgKyBib25lcy5sZW5ndGggKyAnIGJvbmVzLiBUaGlzIEdQVSBzdXBwb3J0cyAnICsgbWF4Qm9uZXMgKyAnLicgKTtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1heEJvbmVzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXAsIGdhbW1hT3ZlcnJpZGVMaW5lYXIgKSB7XG5cblx0XHRcdHZhciBlbmNvZGluZztcblxuXHRcdFx0aWYgKCAhIG1hcCApIHtcblxuXHRcdFx0XHRlbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXAuaXNUZXh0dXJlICkge1xuXG5cdFx0XHRcdGVuY29kaW5nID0gbWFwLmVuY29kaW5nO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXAuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xQcm9ncmFtcy5nZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlwiICk7XG5cdFx0XHRcdGVuY29kaW5nID0gbWFwLnRleHR1cmUuZW5jb2Rpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBXZWJHTFJlbmRlcmVyLmdhbW1hSW5wdXQvZ2FtbWFPdXRwdXQgcGFyYW1ldGVyLCBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBhdCBzb21lIHBvaW50LlxuXHRcdFx0aWYgKCBlbmNvZGluZyA9PT0gTGluZWFyRW5jb2RpbmcgJiYgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcblxuXHRcdFx0XHRlbmNvZGluZyA9IEdhbW1hRW5jb2Rpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVuY29kaW5nO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBzaGFkb3dzLCBmb2csIG5DbGlwUGxhbmVzLCBuQ2xpcEludGVyc2VjdGlvbiwgb2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcblxuXHRcdFx0Ly8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcblx0XHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cblx0XHRcdHZhciBtYXhCb25lcyA9IG9iamVjdC5pc1NraW5uZWRNZXNoID8gYWxsb2NhdGVCb25lcyggb2JqZWN0ICkgOiAwO1xuXHRcdFx0dmFyIHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5wcmVjaXNpb247XG5cblx0XHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5nZXRNYXhQcmVjaXNpb24oIG1hdGVyaWFsLnByZWNpc2lvbiApO1xuXG5cdFx0XHRcdGlmICggcHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24gKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHtcblxuXHRcdFx0XHRzaGFkZXJJRDogc2hhZGVySUQsXG5cblx0XHRcdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXG5cdFx0XHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcblx0XHRcdFx0b3V0cHV0RW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoICggISBjdXJyZW50UmVuZGVyVGFyZ2V0ICkgPyBudWxsIDogY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlLCByZW5kZXJlci5nYW1tYU91dHB1dCApLFxuXHRcdFx0XHRtYXA6ICEhIG1hdGVyaWFsLm1hcCxcblx0XHRcdFx0bWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLm1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxuXHRcdFx0XHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcblx0XHRcdFx0ZW52TWFwTW9kZTogbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nLFxuXHRcdFx0XHRlbnZNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW52TWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXG5cdFx0XHRcdGVudk1hcEN1YmVVVjogKCAhISBtYXRlcmlhbC5lbnZNYXAgKSAmJiAoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgfHwgKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgKSApLFxuXHRcdFx0XHRsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXG5cdFx0XHRcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcblx0XHRcdFx0ZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxuXHRcdFx0XHRlbWlzc2l2ZU1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxuXHRcdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxuXHRcdFx0XHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcblx0XHRcdFx0ZGlzcGxhY2VtZW50TWFwOiAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXG5cdFx0XHRcdHJvdWdobmVzc01hcDogISEgbWF0ZXJpYWwucm91Z2huZXNzTWFwLFxuXHRcdFx0XHRtZXRhbG5lc3NNYXA6ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcCxcblx0XHRcdFx0c3BlY3VsYXJNYXA6ICEhIG1hdGVyaWFsLnNwZWN1bGFyTWFwLFxuXHRcdFx0XHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXG5cblx0XHRcdFx0Z3JhZGllbnRNYXA6ICEhIG1hdGVyaWFsLmdyYWRpZW50TWFwLFxuXG5cdFx0XHRcdGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXG5cblx0XHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cblx0XHRcdFx0Zm9nOiAhISBmb2csXG5cdFx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuXHRcdFx0XHRmb2dFeHA6ICggZm9nICYmIGZvZy5pc0ZvZ0V4cDIgKSxcblxuXHRcdFx0XHRmbGF0U2hhZGluZzogbWF0ZXJpYWwuZmxhdFNoYWRpbmcsXG5cblx0XHRcdFx0c2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXG5cdFx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG5cdFx0XHRcdHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyAmJiBtYXhCb25lcyA+IDAsXG5cdFx0XHRcdG1heEJvbmVzOiBtYXhCb25lcyxcblx0XHRcdFx0dXNlVmVydGV4VGV4dHVyZTogY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMsXG5cblx0XHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXG5cdFx0XHRcdG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxuXHRcdFx0XHRtYXhNb3JwaFRhcmdldHM6IHJlbmRlcmVyLm1heE1vcnBoVGFyZ2V0cyxcblx0XHRcdFx0bWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXG5cblx0XHRcdFx0bnVtRGlyTGlnaHRzOiBsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoLFxuXHRcdFx0XHRudW1Qb2ludExpZ2h0czogbGlnaHRzLnBvaW50Lmxlbmd0aCxcblx0XHRcdFx0bnVtU3BvdExpZ2h0czogbGlnaHRzLnNwb3QubGVuZ3RoLFxuXHRcdFx0XHRudW1SZWN0QXJlYUxpZ2h0czogbGlnaHRzLnJlY3RBcmVhLmxlbmd0aCxcblx0XHRcdFx0bnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxuXG5cdFx0XHRcdG51bUNsaXBwaW5nUGxhbmVzOiBuQ2xpcFBsYW5lcyxcblx0XHRcdFx0bnVtQ2xpcEludGVyc2VjdGlvbjogbkNsaXBJbnRlcnNlY3Rpb24sXG5cblx0XHRcdFx0ZGl0aGVyaW5nOiBtYXRlcmlhbC5kaXRoZXJpbmcsXG5cblx0XHRcdFx0c2hhZG93TWFwRW5hYmxlZDogcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgJiYgb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgc2hhZG93cy5sZW5ndGggPiAwLFxuXHRcdFx0XHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcblxuXHRcdFx0XHR0b25lTWFwcGluZzogcmVuZGVyZXIudG9uZU1hcHBpbmcsXG5cdFx0XHRcdHBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzOiByZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyxcblxuXHRcdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcblxuXHRcdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcblx0XHRcdFx0ZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUsXG5cdFx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUsXG5cblx0XHRcdFx0ZGVwdGhQYWNraW5nOiAoIG1hdGVyaWFsLmRlcHRoUGFja2luZyAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgOiBmYWxzZVxuXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVycztcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldFByb2dyYW1Db2RlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcblxuXHRcdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWwudmVydGV4U2hhZGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbWF0ZXJpYWwuZGVmaW5lcyApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIG5hbWUgKTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKCBtYXRlcmlhbC5kZWZpbmVzWyBuYW1lIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyTmFtZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnNbIHBhcmFtZXRlck5hbWVzWyBpIF0gXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZS50b1N0cmluZygpICk7XG5cblx0XHRcdGFycmF5LnB1c2goIHJlbmRlcmVyLmdhbW1hT3V0cHV0ICk7XG5cblx0XHRcdHJldHVybiBhcnJheS5qb2luKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5hY3F1aXJlUHJvZ3JhbSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHNoYWRlciwgcGFyYW1ldGVycywgY29kZSApIHtcblxuXHRcdFx0dmFyIHByb2dyYW07XG5cblx0XHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuXHRcdFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xuXG5cdFx0XHRcdHZhciBwcm9ncmFtSW5mbyA9IHByb2dyYW1zWyBwIF07XG5cblx0XHRcdFx0aWYgKCBwcm9ncmFtSW5mby5jb2RlID09PSBjb2RlICkge1xuXG5cdFx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xuXHRcdFx0XHRcdCsrIHByb2dyYW0udXNlZFRpbWVzO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHByb2dyYW0gPSBuZXcgV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgZXh0ZW5zaW9ucywgY29kZSwgbWF0ZXJpYWwsIHNoYWRlciwgcGFyYW1ldGVycyApO1xuXHRcdFx0XHRwcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZWxlYXNlUHJvZ3JhbSA9IGZ1bmN0aW9uICggcHJvZ3JhbSApIHtcblxuXHRcdFx0aWYgKCAtLSBwcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBSZW1vdmUgZnJvbSB1bm9yZGVyZWQgc2V0XG5cdFx0XHRcdHZhciBpID0gcHJvZ3JhbXMuaW5kZXhPZiggcHJvZ3JhbSApO1xuXHRcdFx0XHRwcm9ncmFtc1sgaSBdID0gcHJvZ3JhbXNbIHByb2dyYW1zLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0cHJvZ3JhbXMucG9wKCk7XG5cblx0XHRcdFx0Ly8gRnJlZSBXZWJHTCByZXNvdXJjZXNcblx0XHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XG5cdFx0dGhpcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCB1dGlscywgaW5mb01lbW9yeSwgaW5mb1JlbmRlciApIHtcblxuXHRcdHZhciBfaXNXZWJHTDIgPSAoIHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBfZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICk7XG5cdFx0dmFyIF92aWRlb1RleHR1cmVzID0ge307XG5cdFx0dmFyIF9jYW52YXM7XG5cblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUoIGltYWdlLCBtYXhTaXplICkge1xuXG5cdFx0XHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG5cdFx0XHRcdC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXG5cdFx0XHRcdC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXG5cblx0XHRcdFx0dmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIHNjYWxlICk7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBzY2FsZSApO1xuXG5cdFx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuXHRcdFx0XHRyZXR1cm4gY2FudmFzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzUG93ZXJPZlR3byggaW1hZ2UgKSB7XG5cblx0XHRcdHJldHVybiBfTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgX01hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VQb3dlck9mVHdvKCBpbWFnZSApIHtcblxuXHRcdFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwICkge1xuXG5cdFx0XHRcdGlmICggX2NhbnZhcyA9PT0gdW5kZWZpbmVkICkgX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuXG5cdFx0XHRcdF9jYW52YXMud2lkdGggPSBfTWF0aC5mbG9vclBvd2VyT2ZUd28oIGltYWdlLndpZHRoICk7XG5cdFx0XHRcdF9jYW52YXMuaGVpZ2h0ID0gX01hdGguZmxvb3JQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0XHR2YXIgY29udGV4dCA9IF9jYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIF9jYW52YXMud2lkdGgsIF9jYW52YXMuaGVpZ2h0ICk7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgbm90IHBvd2VyIG9mIHR3byAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIF9jYW52YXMud2lkdGggKyAneCcgKyBfY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuXHRcdFx0XHRyZXR1cm4gX2NhbnZhcztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2U7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkge1xuXG5cdFx0XHRyZXR1cm4gKCB0ZXh0dXJlLndyYXBTICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgKSB8fFxuXHRcdFx0XHQoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNQb3dlck9mVHdvICkge1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvICYmXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXI7XG5cblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG5cdFx0ZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2soIGYgKSB7XG5cblx0XHRcdGlmICggZiA9PT0gTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdFx0dmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHtcblxuXHRcdFx0XHRkZWxldGUgX3ZpZGVvVGV4dHVyZXNbIHRleHR1cmUuaWQgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKCBldmVudCApIHtcblxuXHRcdFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHRcdGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRpbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuXHRcdFx0XHQvLyBjdWJlIHRleHR1cmVcblxuXHRcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIDJEIHRleHR1cmVcblxuXHRcdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXG5cdFx0XHRwcm9wZXJ0aWVzLnJlbW92ZSggdGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXG5cdFx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0ICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZGlzcG9zZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICkgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXHRcdFx0cHJvcGVydGllcy5yZW1vdmUoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXG5cblx0XHRmdW5jdGlvbiBzZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHVwZGF0ZVZpZGVvVGV4dHVyZSggdGV4dHVyZSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdFx0dmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuXHRcdFx0XHRpZiAoIGltYWdlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWQnLCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScsIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcblxuXHRcdFx0XHRcdGlmICggISB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdFx0XHRcdFx0aW5mb01lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblxuXHRcdFx0XHRcdHZhciBpc0NvbXByZXNzZWQgPSAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICk7XG5cdFx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSAoIHRleHR1cmUuaW1hZ2VbIDAgXSAmJiB0ZXh0dXJlLmltYWdlWyAwIF0uaXNEYXRhVGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0dmFyIGN1YmVJbWFnZSA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIGlzQ29tcHJlc3NlZCAmJiAhIGlzRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGlzRGF0YVRleHR1cmUgPyB0ZXh0dXJlLmltYWdlWyBpIF0uaW1hZ2UgOiB0ZXh0dXJlLmltYWdlWyBpIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBpbWFnZSA9IGN1YmVJbWFnZVsgMCBdLFxuXHRcdFx0XHRcdFx0aXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXG5cdFx0XHRcdFx0XHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0XHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKCknICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkgKSB7XG5cblx0XHRcdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cblx0XHRcdHZhciBleHRlbnNpb247XG5cblx0XHRcdGlmICggaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmUud3JhcFMgKSApO1xuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgdXRpbHMuY29udmVydCggdGV4dHVyZS53cmFwVCApICk7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdXRpbHMuY29udmVydCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuJywgdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJywgdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gKSB7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ICkge1xuXG5cdFx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIGNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xuXHRcdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xuXG5cdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0XHRcdGluZm9NZW1vcnkudGV4dHVyZXMgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcblxuXHRcdFx0dmFyIGltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSAmJiBpc1Bvd2VyT2ZUd28oIGltYWdlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGltYWdlID0gbWFrZVBvd2VyT2ZUd28oIGltYWdlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGlzUG93ZXJPZlR3b0ltYWdlID0gaXNQb3dlck9mVHdvKCBpbWFnZSApLFxuXHRcdFx0XHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xuXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICk7XG5cblx0XHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cblx0XHRcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcblxuXHRcdFx0XHQvLyBwb3B1bGF0ZSBkZXB0aCB0ZXh0dXJlIHdpdGggZHVtbXkgZGF0YVxuXG5cdFx0XHRcdHZhciBpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQ7XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSApIHtcblxuXHRcdFx0XHRcdGlmICggISBfaXNXZWJHTDIgKSB0aHJvdyBuZXcgRXJyb3IoICdGbG9hdCBEZXB0aCBUZXh0dXJlIG9ubHkgc3VwcG9ydGVkIGluIFdlYkdMMi4wJyApO1xuXHRcdFx0XHRcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBfaXNXZWJHTDIgKSB7XG5cblx0XHRcdFx0XHQvLyBXZWJHTCAyLjAgcmVxdWlyZXMgc2lnbmVkIGludGVybmFsZm9ybWF0IGZvciBnbFRleEltYWdlMkRcblx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgJiYgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5ERVBUSF9DT01QT05FTlQgKSB7XG5cblx0XHRcdFx0XHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcblx0XHRcdFx0XHQvLyBERVBUSF9DT01QT05FTlQgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX1NIT1JUIG9yIFVOU0lHTkVEX0lOVFxuXHRcdFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZFNob3J0VHlwZSAmJiB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkSW50VHlwZSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkU2hvcnRUeXBlIG9yIFVuc2lnbmVkSW50VHlwZSBmb3IgRGVwdGhGb3JtYXQgRGVwdGhUZXh0dXJlLicgKTtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS50eXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XG5cdFx0XHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGVwdGggc3RlbmNpbCB0ZXh0dXJlcyBuZWVkIHRoZSBERVBUSF9TVEVOQ0lMIGludGVybmFsIGZvcm1hdFxuXHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfU1RFTkNJTDtcblxuXHRcdFx0XHRcdC8vIFRoZSBlcnJvciBJTlZBTElEX09QRVJBVElPTiBpcyBnZW5lcmF0ZWQgYnkgdGV4SW1hZ2UyRCBpZiBmb3JtYXQgYW5kIGludGVybmFsZm9ybWF0IGFyZVxuXHRcdFx0XHRcdC8vIERFUFRIX1NURU5DSUwgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX0lOVF8yNF84X1dFQkdMLlxuXHRcdFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludDI0OFR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZEludDI0OFR5cGUgZm9yIERlcHRoU3RlbmNpbEZvcm1hdCBEZXB0aFRleHR1cmUuJyApO1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG5cdFx0XHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFJHQkZvcm1hdCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcblxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkgKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gUmVuZGVyIHRhcmdldHNcblxuXHRcdC8vIFNldHVwIHN0b3JhZ2UgZm9yIHRhcmdldCB0ZXh0dXJlIGFuZCBiaW5kIGl0IHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblx0XHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCApIHtcblxuXHRcdFx0dmFyIGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ICk7XG5cdFx0XHR2YXIgZ2xUeXBlID0gdXRpbHMuY29udmVydCggcmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSApO1xuXHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggdGV4dHVyZVRhcmdldCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlLCAwICk7XG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHRcdH1cblxuXHRcdC8vIFNldHVwIHN0b3JhZ2UgZm9yIGludGVybmFsIGRlcHRoL3N0ZW5jaWwgYnVmZmVycyBhbmQgYmluZCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXG5cdFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cblx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEZJWE1FOiBXZSBkb24ndCBzdXBwb3J0ICFkZXB0aCAhc3RlbmNpbFxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgcmVzb3VyY2VzIGZvciBhIERlcHRoIFRleHR1cmUgZm9yIGEgRkJPIChuZWVkcyBhbiBleHRlbnNpb24pXG5cdFx0ZnVuY3Rpb24gc2V0dXBEZXB0aFRleHR1cmUoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcblx0XHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAnRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZCcgKTtcblxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRpZiAoICEgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRGVwdGhUZXh0dXJlJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwbG9hZCBhbiBlbXB0eSBkZXB0aCB0ZXh0dXJlIHdpdGggZnJhbWVidWZmZXIgc2l6ZVxuXHRcdFx0aWYgKCAhIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmUgfHxcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHxcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCAhPT0gcmVuZGVyVGFyZ2V0LmhlaWdodCApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNldFRleHR1cmUyRCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSwgMCApO1xuXG5cdFx0XHR2YXIgd2ViZ2xEZXB0aFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xuXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHtcblxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xuXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQnICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIFNldHVwIEdMIHJlc291cmNlcyBmb3IgYSBub24tdGV4dHVyZSBkZXB0aCBidWZmZXJcblx0XHRmdW5jdGlvbiBzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPT09IHRydWUgKTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xuXG5cdFx0XHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnICk7XG5cblx0XHRcdFx0c2V0dXBEZXB0aFRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcblx0XHRmdW5jdGlvbiBzZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXG5cdFx0XHRyZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0XHRpbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPT09IHRydWUgKTtcblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHQvLyBTZXR1cCBmcmFtZWJ1ZmZlclxuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0dXAgY29sb3IgYnVmZmVyXG5cblx0XHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKSApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQgKTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXR1cCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzXG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xuXG5cdFx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICkgKSB7XG5cblx0XHRcdFx0dmFyIHRhcmdldCA9IHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA/IF9nbC5URVhUVVJFX0NVQkVfTUFQIDogX2dsLlRFWFRVUkVfMkQ7XG5cdFx0XHRcdHZhciB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xuXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCB0YXJnZXQsIHdlYmdsVGV4dHVyZSApO1xuXHRcdFx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIHRhcmdldCApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCBudWxsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVZpZGVvVGV4dHVyZSggdGV4dHVyZSApIHtcblxuXHRcdFx0dmFyIGlkID0gdGV4dHVyZS5pZDtcblx0XHRcdHZhciBmcmFtZSA9IGluZm9SZW5kZXIuZnJhbWU7XG5cblx0XHRcdC8vIENoZWNrIHRoZSBsYXN0IGZyYW1lIHdlIHVwZGF0ZWQgdGhlIFZpZGVvVGV4dHVyZVxuXG5cdFx0XHRpZiAoIF92aWRlb1RleHR1cmVzWyBpZCBdICE9PSBmcmFtZSApIHtcblxuXHRcdFx0XHRfdmlkZW9UZXh0dXJlc1sgaWQgXSA9IGZyYW1lO1xuXHRcdFx0XHR0ZXh0dXJlLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldFRleHR1cmUyRCA9IHNldFRleHR1cmUyRDtcblx0XHR0aGlzLnNldFRleHR1cmVDdWJlID0gc2V0VGV4dHVyZUN1YmU7XG5cdFx0dGhpcy5zZXRUZXh0dXJlQ3ViZUR5bmFtaWMgPSBzZXRUZXh0dXJlQ3ViZUR5bmFtaWM7XG5cdFx0dGhpcy5zZXR1cFJlbmRlclRhcmdldCA9IHNldHVwUmVuZGVyVGFyZ2V0O1xuXHRcdHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xQcm9wZXJ0aWVzKCkge1xuXG5cdFx0dmFyIHByb3BlcnRpZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgdXVpZCA9IG9iamVjdC51dWlkO1xuXHRcdFx0dmFyIG1hcCA9IHByb3BlcnRpZXNbIHV1aWQgXTtcblxuXHRcdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXAgPSB7fTtcblx0XHRcdFx0cHJvcGVydGllc1sgdXVpZCBdID0gbWFwO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXA7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmUoIG9iamVjdCApIHtcblxuXHRcdFx0ZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCwga2V5LCB2YWx1ZSApIHtcblxuXHRcdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcblx0XHRcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XG5cblx0XHRcdG1hcFsga2V5IF0gPSB2YWx1ZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cblx0XHRcdHByb3BlcnRpZXMgPSB7fTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdHJlbW92ZTogcmVtb3ZlLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdlYkdMU3RhdGUoIGdsLCBleHRlbnNpb25zLCB1dGlscyApIHtcblxuXHRcdGZ1bmN0aW9uIENvbG9yQnVmZmVyKCkge1xuXG5cdFx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XG5cblx0XHRcdHZhciBjb2xvciA9IG5ldyBWZWN0b3I0KCk7XG5cdFx0XHR2YXIgY3VycmVudENvbG9yTWFzayA9IG51bGw7XG5cdFx0XHR2YXIgY3VycmVudENvbG9yQ2xlYXIgPSBuZXcgVmVjdG9yNCggMCwgMCwgMCwgMCApO1xuXG5cdFx0XHRyZXR1cm4ge1xuXG5cdFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggY29sb3JNYXNrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgJiYgISBsb2NrZWQgKSB7XG5cblx0XHRcdFx0XHRcdGdsLmNvbG9yTWFzayggY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50Q29sb3JNYXNrID0gY29sb3JNYXNrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cblx0XHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggciwgZywgYiwgYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdHIgKj0gYTsgZyAqPSBhOyBiICo9IGE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb2xvci5zZXQoIHIsIGcsIGIsIGEgKTtcblxuXHRcdFx0XHRcdGlmICggY3VycmVudENvbG9yQ2xlYXIuZXF1YWxzKCBjb2xvciApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Z2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuXHRcdFx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuY29weSggY29sb3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLnNldCggLSAxLCAwLCAwLCAwICk7IC8vIHNldCB0byBpbnZhbGlkIHN0YXRlXG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gRGVwdGhCdWZmZXIoKSB7XG5cblx0XHRcdHZhciBsb2NrZWQgPSBmYWxzZTtcblxuXHRcdFx0dmFyIGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xuXHRcdFx0dmFyIGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuXHRcdFx0dmFyIGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIHtcblxuXHRcdFx0XHRzZXRUZXN0OiBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcblxuXHRcdFx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHRcdFx0XHRlbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggZGVwdGhNYXNrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhNYXNrICE9PSBkZXB0aE1hc2sgJiYgISBsb2NrZWQgKSB7XG5cblx0XHRcdFx0XHRcdGdsLmRlcHRoTWFzayggZGVwdGhNYXNrICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVwdGhNYXNrID0gZGVwdGhNYXNrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBOZXZlckRlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5FVkVSICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgQWx3YXlzRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgTGVzc0RlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBMZXNzRXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckRlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkdSRUFURVIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBOb3RFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xuXG5cdFx0XHRcdFx0bG9ja2VkID0gbG9jaztcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIGRlcHRoICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhDbGVhciAhPT0gZGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdGdsLmNsZWFyRGVwdGgoIGRlcHRoICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IGRlcHRoO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IG51bGw7XG5cdFx0XHRcdFx0Y3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIFN0ZW5jaWxCdWZmZXIoKSB7XG5cblx0XHRcdHZhciBsb2NrZWQgPSBmYWxzZTtcblxuXHRcdFx0dmFyIGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XG5cdFx0XHR2YXIgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcblx0XHRcdHZhciBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XG5cdFx0XHR2YXIgY3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XG5cdFx0XHR2YXIgY3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcblx0XHRcdHZhciBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcblx0XHRcdHZhciBjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblx0XHRcdHZhciBjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIHtcblxuXHRcdFx0XHRzZXRUZXN0OiBmdW5jdGlvbiAoIHN0ZW5jaWxUZXN0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBzdGVuY2lsVGVzdCApIHtcblxuXHRcdFx0XHRcdFx0ZW5hYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGRpc2FibGUoIGdsLlNURU5DSUxfVEVTVCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKCBzdGVuY2lsTWFzayApIHtcblxuXHRcdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayAmJiAhIGxvY2tlZCApIHtcblxuXHRcdFx0XHRcdFx0Z2wuc3RlbmNpbE1hc2soIHN0ZW5jaWxNYXNrICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbE1hc2sgPSBzdGVuY2lsTWFzaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldEZ1bmM6IGZ1bmN0aW9uICggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XG5cdFx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFJlZiBcdCE9PSBzdGVuY2lsUmVmIFx0fHxcblx0XHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgIT09IHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0XHRcdFx0XHRnbC5zdGVuY2lsRnVuYyggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICk7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IHN0ZW5jaWxNYXNrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0T3A6IGZ1bmN0aW9uICggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZhaWxcdCAhPT0gc3RlbmNpbEZhaWwgXHR8fFxuXHRcdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxaRmFpbCAhPT0gc3RlbmNpbFpGYWlsIHx8XG5cdFx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFpQYXNzICE9PSBzdGVuY2lsWlBhc3MgKSB7XG5cblx0XHRcdFx0XHRcdGdsLnN0ZW5jaWxPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IHN0ZW5jaWxGYWlsO1xuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IHN0ZW5jaWxaRmFpbDtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcblxuXHRcdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCBzdGVuY2lsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbENsZWFyICE9PSBzdGVuY2lsICkge1xuXG5cdFx0XHRcdFx0XHRnbC5jbGVhclN0ZW5jaWwoIHN0ZW5jaWwgKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBzdGVuY2lsO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgY29sb3JCdWZmZXIgPSBuZXcgQ29sb3JCdWZmZXIoKTtcblx0XHR2YXIgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcblx0XHR2YXIgc3RlbmNpbEJ1ZmZlciA9IG5ldyBTdGVuY2lsQnVmZmVyKCk7XG5cblx0XHR2YXIgbWF4VmVydGV4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG5cdFx0dmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggbWF4VmVydGV4QXR0cmlidXRlcyApO1xuXHRcdHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XG5cdFx0dmFyIGF0dHJpYnV0ZURpdmlzb3JzID0gbmV3IFVpbnQ4QXJyYXkoIG1heFZlcnRleEF0dHJpYnV0ZXMgKTtcblxuXHRcdHZhciBjYXBhYmlsaXRpZXMgPSB7fTtcblxuXHRcdHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG5cdFx0dmFyIGN1cnJlbnRQcm9ncmFtID0gbnVsbDtcblxuXHRcdHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblx0XHR2YXIgY3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XG5cblx0XHR2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG5cblx0XHR2YXIgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cblx0XHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xuXHRcdHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcblxuXHRcdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcblxuXHRcdHZhciBsaW5lV2lkdGhBdmFpbGFibGUgPSBmYWxzZTtcblx0XHR2YXIgdmVyc2lvbiA9IDA7XG5cdFx0dmFyIGdsVmVyc2lvbiA9IGdsLmdldFBhcmFtZXRlciggZ2wuVkVSU0lPTiApO1xuXG5cdFx0aWYgKCBnbFZlcnNpb24uaW5kZXhPZiggJ1dlYkdMJyApICE9PSAtIDEgKSB7XG5cblx0XHQgICB2ZXJzaW9uID0gcGFyc2VGbG9hdCggL15XZWJHTFxcIChbMC05XSkvLmV4ZWMoIGdsVmVyc2lvbiApWyAxIF0gKTtcblx0XHQgICBsaW5lV2lkdGhBdmFpbGFibGUgPSAoIHZlcnNpb24gPj0gMS4wICk7XG5cblx0XHR9IGVsc2UgaWYgKCBnbFZlcnNpb24uaW5kZXhPZiggJ09wZW5HTCBFUycgKSAhPT0gLSAxICkge1xuXG5cdFx0ICAgdmVyc2lvbiA9IHBhcnNlRmxvYXQoIC9eT3BlbkdMXFwgRVNcXCAoWzAtOV0pLy5leGVjKCBnbFZlcnNpb24gKVsgMSBdICk7XG5cdFx0ICAgbGluZVdpZHRoQXZhaWxhYmxlID0gKCB2ZXJzaW9uID49IDIuMCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG5cdFx0dmFyIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cblx0XHR2YXIgY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xuXHRcdHZhciBjdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlVGV4dHVyZSggdHlwZSwgdGFyZ2V0LCBjb3VudCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggNCApOyAvLyA0IGlzIHJlcXVpcmVkIHRvIG1hdGNoIGRlZmF1bHQgdW5wYWNrIGFsaWdubWVudCBvZiA0LlxuXHRcdFx0dmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdGdsLmJpbmRUZXh0dXJlKCB0eXBlLCB0ZXh0dXJlICk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIHR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKCB0YXJnZXQgKyBpLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9XG5cblx0XHR2YXIgZW1wdHlUZXh0dXJlcyA9IHt9O1xuXHRcdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfMkQgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfMkQsIDEgKTtcblx0XHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFX0NVQkVfTUFQIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDYgKTtcblxuXHRcdC8vIGluaXRcblxuXHRcdGNvbG9yQnVmZmVyLnNldENsZWFyKCAwLCAwLCAwLCAxICk7XG5cdFx0ZGVwdGhCdWZmZXIuc2V0Q2xlYXIoIDEgKTtcblx0XHRzdGVuY2lsQnVmZmVyLnNldENsZWFyKCAwICk7XG5cblx0XHRlbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblx0XHRkZXB0aEJ1ZmZlci5zZXRGdW5jKCBMZXNzRXF1YWxEZXB0aCApO1xuXG5cdFx0c2V0RmxpcFNpZGVkKCBmYWxzZSApO1xuXHRcdHNldEN1bGxGYWNlKCBDdWxsRmFjZUJhY2sgKTtcblx0XHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0ZW5hYmxlKCBnbC5CTEVORCApO1xuXHRcdHNldEJsZW5kaW5nKCBOb3JtYWxCbGVuZGluZyApO1xuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIGluaXRBdHRyaWJ1dGVzKCkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuXHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSAwICkge1xuXG5cdFx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCAwICk7XG5cdFx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuXHRcdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRcdFx0XHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUgKTtcblx0XHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSAhPT0gbDsgKysgaSApIHtcblxuXHRcdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gIT09IG5ld0F0dHJpYnV0ZXNbIGkgXSApIHtcblxuXHRcdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuXHRcdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5hYmxlKCBpZCApIHtcblxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IHRydWUgKSB7XG5cblx0XHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xuXHRcdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkaXNhYmxlKCBpZCApIHtcblxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGdsLmRpc2FibGUoIGlkICk7XG5cdFx0XHRcdGNhcGFiaWxpdGllc1sgaWQgXSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKSB7XG5cblx0XHRcdGlmICggY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID09PSBudWxsICkge1xuXG5cdFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHxcblx0XHRcdFx0ICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8XG5cdFx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKSB8fFxuXHRcdFx0XHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGMnICkgKSB7XG5cblx0XHRcdFx0XHR2YXIgZm9ybWF0cyA9IGdsLmdldFBhcmFtZXRlciggZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMucHVzaCggZm9ybWF0c1sgaSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1c2VQcm9ncmFtKCBwcm9ncmFtICkge1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRQcm9ncmFtICE9PSBwcm9ncmFtICkge1xuXG5cdFx0XHRcdGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuXHRcdFx0XHRjdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0QmxlbmRpbmcoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG5cdFx0XHRpZiAoIGJsZW5kaW5nICE9PSBOb0JsZW5kaW5nICkge1xuXG5cdFx0XHRcdGVuYWJsZSggZ2wuQkxFTkQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkaXNhYmxlKCBnbC5CTEVORCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYmxlbmRpbmcgIT09IEN1c3RvbUJsZW5kaW5nICkge1xuXG5cdFx0XHRcdGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyB8fCBwcmVtdWx0aXBsaWVkQWxwaGEgIT09IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSApIHtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxuXG5cdFx0XHRcdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgTXVsdGlwbHlCbGVuZGluZzpcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuU1JDX0FMUEhBICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuXHRcdFx0XHRibGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYSB8fCBibGVuZFNyYztcblx0XHRcdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cblx0XHRcdFx0aWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cblx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIHV0aWxzLmNvbnZlcnQoIGJsZW5kRXF1YXRpb24gKSwgdXRpbHMuY29udmVydCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcblxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcblx0XHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSApIHtcblxuXHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCB1dGlscy5jb252ZXJ0KCBibGVuZFNyYyApLCB1dGlscy5jb252ZXJ0KCBibGVuZERzdCApLCB1dGlscy5jb252ZXJ0KCBibGVuZFNyY0FscGhhICksIHV0aWxzLmNvbnZlcnQoIGJsZW5kRHN0QWxwaGEgKSApO1xuXG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kU3JjID0gYmxlbmRTcmM7XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG5cdFx0XHRjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBwcmVtdWx0aXBsaWVkQWxwaGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXICkge1xuXG5cdFx0XHRtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlXG5cdFx0XHRcdD8gZGlzYWJsZSggZ2wuQ1VMTF9GQUNFIClcblx0XHRcdFx0OiBlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0XHR2YXIgZmxpcFNpZGVkID0gKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApO1xuXHRcdFx0aWYgKCBmcm9udEZhY2VDVyApIGZsaXBTaWRlZCA9ICEgZmxpcFNpZGVkO1xuXG5cdFx0XHRzZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApO1xuXG5cdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZVxuXHRcdFx0XHQ/IHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApXG5cdFx0XHRcdDogc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcblxuXHRcdFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG5cdFx0XHRkZXB0aEJ1ZmZlci5zZXRUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcblx0XHRcdGRlcHRoQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblx0XHRcdGNvbG9yQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcblxuXHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gc2V0RmxpcFNpZGVkKCBmbGlwU2lkZWQgKSB7XG5cblx0XHRcdGlmICggY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xuXG5cdFx0XHRcdGlmICggZmxpcFNpZGVkICkge1xuXG5cdFx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNDVyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRDdWxsRmFjZSggY3VsbEZhY2UgKSB7XG5cblx0XHRcdGlmICggY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSApIHtcblxuXHRcdFx0XHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0XHRcdGlmICggY3VsbEZhY2UgIT09IGN1cnJlbnRDdWxsRmFjZSApIHtcblxuXHRcdFx0XHRcdGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjayApIHtcblxuXHRcdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUZyb250ICkge1xuXG5cdFx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuRlJPTlQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGdsLmN1bGxGYWNlKCBnbC5GUk9OVF9BTkRfQkFDSyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50Q3VsbEZhY2UgPSBjdWxsRmFjZTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldExpbmVXaWR0aCggd2lkdGggKSB7XG5cblx0XHRcdGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XG5cblx0XHRcdFx0aWYgKCBsaW5lV2lkdGhBdmFpbGFibGUgKSBnbC5saW5lV2lkdGgoIHdpZHRoICk7XG5cblx0XHRcdFx0Y3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0KCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG5cdFx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XG5cblx0XHRcdFx0ZW5hYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkge1xuXG5cdFx0XHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xuXG5cdFx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG5cdFx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRkaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFNjaXNzb3JUZXN0KCBzY2lzc29yVGVzdCApIHtcblxuXHRcdFx0aWYgKCBzY2lzc29yVGVzdCApIHtcblxuXHRcdFx0XHRlbmFibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyB0ZXh0dXJlXG5cblx0XHRmdW5jdGlvbiBhY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKSB7XG5cblx0XHRcdGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcblxuXHRcdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcblxuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcblx0XHRcdFx0Y3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBiaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XG5cblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ID09PSBudWxsICkge1xuXG5cdFx0XHRcdGFjdGl2ZVRleHR1cmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdO1xuXG5cdFx0XHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcblx0XHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdID0gYm91bmRUZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xuXG5cdFx0XHRcdGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSB8fCBlbXB0eVRleHR1cmVzWyB3ZWJnbFR5cGUgXSApO1xuXG5cdFx0XHRcdGJvdW5kVGV4dHVyZS50eXBlID0gd2ViZ2xUeXBlO1xuXHRcdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlMkQoKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0Z2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRleEltYWdlMkQoKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0Z2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIHNjaXNzb3IoIHNjaXNzb3IgKSB7XG5cblx0XHRcdGlmICggY3VycmVudFNjaXNzb3IuZXF1YWxzKCBzY2lzc29yICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGdsLnNjaXNzb3IoIHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3IudyApO1xuXHRcdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KCBzY2lzc29yICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHZpZXdwb3J0KCB2aWV3cG9ydCApIHtcblxuXHRcdFx0aWYgKCBjdXJyZW50Vmlld3BvcnQuZXF1YWxzKCB2aWV3cG9ydCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRnbC52aWV3cG9ydCggdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQueiwgdmlld3BvcnQudyApO1xuXHRcdFx0XHRjdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KCkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdID09PSAxICkge1xuXG5cdFx0XHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG5cdFx0XHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNhcGFiaWxpdGllcyA9IHt9O1xuXG5cdFx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG5cdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcblxuXHRcdFx0Y3VycmVudFByb2dyYW0gPSBudWxsO1xuXG5cdFx0XHRjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXG5cdFx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblx0XHRcdGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG5cblx0XHRcdGNvbG9yQnVmZmVyLnJlc2V0KCk7XG5cdFx0XHRkZXB0aEJ1ZmZlci5yZXNldCgpO1xuXHRcdFx0c3RlbmNpbEJ1ZmZlci5yZXNldCgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0YnVmZmVyczoge1xuXHRcdFx0XHRjb2xvcjogY29sb3JCdWZmZXIsXG5cdFx0XHRcdGRlcHRoOiBkZXB0aEJ1ZmZlcixcblx0XHRcdFx0c3RlbmNpbDogc3RlbmNpbEJ1ZmZlclxuXHRcdFx0fSxcblxuXHRcdFx0aW5pdEF0dHJpYnV0ZXM6IGluaXRBdHRyaWJ1dGVzLFxuXHRcdFx0ZW5hYmxlQXR0cmlidXRlOiBlbmFibGVBdHRyaWJ1dGUsXG5cdFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yOiBlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yLFxuXHRcdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXM6IGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzLFxuXHRcdFx0ZW5hYmxlOiBlbmFibGUsXG5cdFx0XHRkaXNhYmxlOiBkaXNhYmxlLFxuXHRcdFx0Z2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzOiBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsXG5cblx0XHRcdHVzZVByb2dyYW06IHVzZVByb2dyYW0sXG5cblx0XHRcdHNldEJsZW5kaW5nOiBzZXRCbGVuZGluZyxcblx0XHRcdHNldE1hdGVyaWFsOiBzZXRNYXRlcmlhbCxcblxuXHRcdFx0c2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXG5cdFx0XHRzZXRDdWxsRmFjZTogc2V0Q3VsbEZhY2UsXG5cblx0XHRcdHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxuXHRcdFx0c2V0UG9seWdvbk9mZnNldDogc2V0UG9seWdvbk9mZnNldCxcblxuXHRcdFx0c2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxuXG5cdFx0XHRhY3RpdmVUZXh0dXJlOiBhY3RpdmVUZXh0dXJlLFxuXHRcdFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxuXHRcdFx0Y29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxuXHRcdFx0dGV4SW1hZ2UyRDogdGV4SW1hZ2UyRCxcblxuXHRcdFx0c2Npc3Nvcjogc2Npc3Nvcixcblx0XHRcdHZpZXdwb3J0OiB2aWV3cG9ydCxcblxuXHRcdFx0cmVzZXQ6IHJlc2V0XG5cblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xDYXBhYmlsaXRpZXMoIGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0dmFyIG1heEFuaXNvdHJvcHk7XG5cblx0XHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXG5cdFx0XHRpZiAoIG1heEFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHJldHVybiBtYXhBbmlzb3Ryb3B5O1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG1heEFuaXNvdHJvcHkgPSBnbC5nZXRQYXJhbWV0ZXIoIGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF4QW5pc290cm9weTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICkge1xuXG5cdFx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcblxuXHRcdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcblx0XHRcdFx0ICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gJ2hpZ2hwJztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJlY2lzaW9uID0gJ21lZGl1bXAnO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XG5cblx0XHRcdFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcblx0XHRcdFx0ICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcblxuXHRcdFx0XHRcdHJldHVybiAnbWVkaXVtcCc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAnbG93cCc7XG5cblx0XHR9XG5cblx0XHR2YXIgcHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJztcblx0XHR2YXIgbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKTtcblxuXHRcdGlmICggbWF4UHJlY2lzaW9uICE9PSBwcmVjaXNpb24gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgcHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBtYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcblx0XHRcdHByZWNpc2lvbiA9IG1heFByZWNpc2lvbjtcblxuXHRcdH1cblxuXHRcdHZhciBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID09PSB0cnVlO1xuXG5cdFx0dmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuXHRcdHZhciBtYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdFx0dmFyIG1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XG5cdFx0dmFyIG1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICk7XG5cblx0XHR2YXIgbWF4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XG5cdFx0dmFyIG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xuXHRcdHZhciBtYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xuXHRcdHZhciBtYXhGcmFnbWVudFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICk7XG5cblx0XHR2YXIgdmVydGV4VGV4dHVyZXMgPSBtYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG5cdFx0dmFyIGZsb2F0RnJhZ21lbnRUZXh0dXJlcyA9ICEhIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cdFx0dmFyIGZsb2F0VmVydGV4VGV4dHVyZXMgPSB2ZXJ0ZXhUZXh0dXJlcyAmJiBmbG9hdEZyYWdtZW50VGV4dHVyZXM7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRnZXRNYXhBbmlzb3Ryb3B5OiBnZXRNYXhBbmlzb3Ryb3B5LFxuXHRcdFx0Z2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXG5cblx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxuXHRcdFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblxuXHRcdFx0bWF4VGV4dHVyZXM6IG1heFRleHR1cmVzLFxuXHRcdFx0bWF4VmVydGV4VGV4dHVyZXM6IG1heFZlcnRleFRleHR1cmVzLFxuXHRcdFx0bWF4VGV4dHVyZVNpemU6IG1heFRleHR1cmVTaXplLFxuXHRcdFx0bWF4Q3ViZW1hcFNpemU6IG1heEN1YmVtYXBTaXplLFxuXG5cdFx0XHRtYXhBdHRyaWJ1dGVzOiBtYXhBdHRyaWJ1dGVzLFxuXHRcdFx0bWF4VmVydGV4VW5pZm9ybXM6IG1heFZlcnRleFVuaWZvcm1zLFxuXHRcdFx0bWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxuXHRcdFx0bWF4RnJhZ21lbnRVbmlmb3JtczogbWF4RnJhZ21lbnRVbmlmb3JtcyxcblxuXHRcdFx0dmVydGV4VGV4dHVyZXM6IHZlcnRleFRleHR1cmVzLFxuXHRcdFx0ZmxvYXRGcmFnbWVudFRleHR1cmVzOiBmbG9hdEZyYWdtZW50VGV4dHVyZXMsXG5cdFx0XHRmbG9hdFZlcnRleFRleHR1cmVzOiBmbG9hdFZlcnRleFRleHR1cmVzXG5cblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBncmVnZ21hbiAvIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuXHRcdENhbWVyYS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG5cdFx0dGhpcy5mb3YgPSBmb3YgIT09IHVuZGVmaW5lZCA/IGZvdiA6IDUwO1xuXHRcdHRoaXMuem9vbSA9IDE7XG5cblx0XHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xuXHRcdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xuXHRcdHRoaXMuZm9jdXMgPSAxMDtcblxuXHRcdHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuXHRcdHRoaXMudmlldyA9IG51bGw7XG5cblx0XHR0aGlzLmZpbG1HYXVnZSA9IDM1O1x0Ly8gd2lkdGggb2YgdGhlIGZpbG0gKGRlZmF1bHQgaW4gbWlsbGltZXRlcnMpXG5cdFx0dGhpcy5maWxtT2Zmc2V0ID0gMDtcdC8vIGhvcml6b250YWwgZmlsbSBvZmZzZXQgKHNhbWUgdW5pdCBhcyBnYXVnZSlcblxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdH1cblxuXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDYW1lcmEucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBQZXJzcGVjdGl2ZUNhbWVyYSxcblxuXHRcdGlzUGVyc3BlY3RpdmVDYW1lcmE6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHRDYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xuXHRcdFx0dGhpcy56b29tID0gc291cmNlLnpvb207XG5cblx0XHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHRcdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXHRcdFx0dGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcblxuXHRcdFx0dGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xuXHRcdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XG5cblx0XHRcdHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcblx0XHRcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBGT1YgYnkgZm9jYWwgbGVuZ3RoIGluIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgLmZpbG1HYXVnZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBkZWZhdWx0IGZpbG0gZ2F1Z2UgaXMgMzUsIHNvIHRoYXQgdGhlIGZvY2FsIGxlbmd0aCBjYW4gYmUgc3BlY2lmaWVkIGZvclxuXHRcdCAqIGEgMzVtbSAoZnVsbCBmcmFtZSkgY2FtZXJhLlxuXHRcdCAqXG5cdFx0ICogVmFsdWVzIGZvciBmb2NhbCBsZW5ndGggYW5kIGZpbG0gZ2F1Z2UgbXVzdCBoYXZlIHRoZSBzYW1lIHVuaXQuXG5cdFx0ICovXG5cdFx0c2V0Rm9jYWxMZW5ndGg6IGZ1bmN0aW9uICggZm9jYWxMZW5ndGggKSB7XG5cblx0XHRcdC8vIHNlZSBodHRwOi8vd3d3LmJvYmF0a2lucy5jb20vcGhvdG9ncmFwaHkvdGVjaG5pY2FsL2ZpZWxkX29mX3ZpZXcuaHRtbFxuXHRcdFx0dmFyIHZFeHRlbnRTbG9wZSA9IDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gZm9jYWxMZW5ndGg7XG5cblx0XHRcdHRoaXMuZm92ID0gX01hdGguUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oIHZFeHRlbnRTbG9wZSApO1xuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsY3VsYXRlcyB0aGUgZm9jYWwgbGVuZ3RoIGZyb20gdGhlIGN1cnJlbnQgLmZvdiBhbmQgLmZpbG1HYXVnZS5cblx0XHQgKi9cblx0XHRnZXRGb2NhbExlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdkV4dGVudFNsb3BlID0gTWF0aC50YW4oIF9NYXRoLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApO1xuXG5cdFx0XHRyZXR1cm4gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyB2RXh0ZW50U2xvcGU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RWZmZWN0aXZlRk9WOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfTWF0aC5SQUQyREVHICogMiAqIE1hdGguYXRhbihcblx0XHRcdFx0TWF0aC50YW4oIF9NYXRoLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApIC8gdGhpcy56b29tICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RmlsbVdpZHRoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBwb3J0cmFpdCBmb3JtYXQgKGFzcGVjdCA8IDEpXG5cdFx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbiggdGhpcy5hc3BlY3QsIDEgKTtcblxuXHRcdH0sXG5cblx0XHRnZXRGaWxtSGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlIC8gTWF0aC5tYXgoIHRoaXMuYXNwZWN0LCAxICk7XG5cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxuXHRcdCAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxuXHRcdCAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcblx0XHQgKlxuXHRcdCAqICAgKy0tLSstLS0rLS0tK1xuXHRcdCAqICAgfCBBIHwgQiB8IEMgfFxuXHRcdCAqICAgKy0tLSstLS0rLS0tK1xuXHRcdCAqICAgfCBEIHwgRSB8IEYgfFxuXHRcdCAqICAgKy0tLSstLS0rLS0tK1xuXHRcdCAqXG5cdFx0ICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xuXHRcdCAqXG5cdFx0ICogICB2YXIgdyA9IDE5MjA7XG5cdFx0ICogICB2YXIgaCA9IDEwODA7XG5cdFx0ICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XG5cdFx0ICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xuXHRcdCAqXG5cdFx0ICogICAtLUEtLVxuXHRcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcblx0XHQgKiAgIC0tQi0tXG5cdFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xuXHRcdCAqICAgLS1DLS1cblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG5cdFx0ICogICAtLUQtLVxuXHRcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcblx0XHQgKiAgIC0tRS0tXG5cdFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xuXHRcdCAqICAgLS1GLS1cblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG5cdFx0ICpcblx0XHQgKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG5cdFx0ICovXG5cdFx0c2V0Vmlld09mZnNldDogZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRcdHRoaXMuYXNwZWN0ID0gZnVsbFdpZHRoIC8gZnVsbEhlaWdodDtcblxuXHRcdFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy52aWV3ID0ge1xuXHRcdFx0XHRcdGVuYWJsZWQ6IHRydWUsXG5cdFx0XHRcdFx0ZnVsbFdpZHRoOiAxLFxuXHRcdFx0XHRcdGZ1bGxIZWlnaHQ6IDEsXG5cdFx0XHRcdFx0b2Zmc2V0WDogMCxcblx0XHRcdFx0XHRvZmZzZXRZOiAwLFxuXHRcdFx0XHRcdHdpZHRoOiAxLFxuXHRcdFx0XHRcdGhlaWdodDogMVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XG5cdFx0XHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XG5cdFx0XHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XG5cdFx0XHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XG5cdFx0XHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcblx0XHRcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0fSxcblxuXHRcdGNsZWFyVmlld09mZnNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZVByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG5lYXIgPSB0aGlzLm5lYXIsXG5cdFx0XHRcdHRvcCA9IG5lYXIgKiBNYXRoLnRhbihcblx0XHRcdFx0XHRfTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSxcblx0XHRcdFx0aGVpZ2h0ID0gMiAqIHRvcCxcblx0XHRcdFx0d2lkdGggPSB0aGlzLmFzcGVjdCAqIGhlaWdodCxcblx0XHRcdFx0bGVmdCA9IC0gMC41ICogd2lkdGgsXG5cdFx0XHRcdHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xuXG5cdFx0XHRcdHZhciBmdWxsV2lkdGggPSB2aWV3LmZ1bGxXaWR0aCxcblx0XHRcdFx0XHRmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xuXG5cdFx0XHRcdGxlZnQgKz0gdmlldy5vZmZzZXRYICogd2lkdGggLyBmdWxsV2lkdGg7XG5cdFx0XHRcdHRvcCAtPSB2aWV3Lm9mZnNldFkgKiBoZWlnaHQgLyBmdWxsSGVpZ2h0O1xuXHRcdFx0XHR3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xuXHRcdFx0XHRoZWlnaHQgKj0gdmlldy5oZWlnaHQgLyBmdWxsSGVpZ2h0O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBza2V3ID0gdGhpcy5maWxtT2Zmc2V0O1xuXHRcdFx0aWYgKCBza2V3ICE9PSAwICkgbGVmdCArPSBuZWFyICogc2tldyAvIHRoaXMuZ2V0RmlsbVdpZHRoKCk7XG5cblx0XHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIGxlZnQgKyB3aWR0aCwgdG9wLCB0b3AgLSBoZWlnaHQsIG5lYXIsIHRoaXMuZmFyICk7XG5cblx0XHR9LFxuXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0XHRcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cblx0XHRcdGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xuXHRcdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblxuXHRcdFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcblx0XHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXHRcdFx0ZGF0YS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xuXG5cdFx0XHRkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcblxuXHRcdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xuXG5cdFx0XHRkYXRhLm9iamVjdC5maWxtR2F1Z2UgPSB0aGlzLmZpbG1HYXVnZTtcblx0XHRcdGRhdGEub2JqZWN0LmZpbG1PZmZzZXQgPSB0aGlzLmZpbG1PZmZzZXQ7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gQXJyYXlDYW1lcmEoIGFycmF5ICkge1xuXG5cdFx0UGVyc3BlY3RpdmVDYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5jYW1lcmFzID0gYXJyYXkgfHwgW107XG5cblx0fVxuXG5cdEFycmF5Q2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQXJyYXlDYW1lcmEsXG5cblx0XHRpc0FycmF5Q2FtZXJhOiB0cnVlXG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBXZWJWUk1hbmFnZXIoIHJlbmRlcmVyICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBkZXZpY2UgPSBudWxsO1xuXHRcdHZhciBmcmFtZURhdGEgPSBudWxsO1xuXG5cdFx0dmFyIHBvc2VUYXJnZXQgPSBudWxsO1xuXG5cdFx0dmFyIHN0YW5kaW5nTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgc3RhbmRpbmdNYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1ZSRnJhbWVEYXRhJyBpbiB3aW5kb3cgKSB7XG5cblx0XHRcdGZyYW1lRGF0YSA9IG5ldyB3aW5kb3cuVlJGcmFtZURhdGEoKTtcblxuXHRcdH1cblxuXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciB0ZW1wUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0dmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR2YXIgY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdGNhbWVyYUwuYm91bmRzID0gbmV3IFZlY3RvcjQoIDAuMCwgMC4wLCAwLjUsIDEuMCApO1xuXHRcdGNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xuXG5cdFx0dmFyIGNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRjYW1lcmFSLmJvdW5kcyA9IG5ldyBWZWN0b3I0KCAwLjUsIDAuMCwgMC41LCAxLjAgKTtcblx0XHRjYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcblxuXHRcdHZhciBjYW1lcmFWUiA9IG5ldyBBcnJheUNhbWVyYSggWyBjYW1lcmFMLCBjYW1lcmFSIF0gKTtcblx0XHRjYW1lcmFWUi5sYXllcnMuZW5hYmxlKCAxICk7XG5cdFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSggMiApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBjdXJyZW50U2l6ZSwgY3VycmVudFBpeGVsUmF0aW87XG5cblx0XHRmdW5jdGlvbiBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UoKSB7XG5cblx0XHRcdGlmICggZGV2aWNlICE9PSBudWxsICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSB7XG5cblx0XHRcdFx0dmFyIGV5ZVBhcmFtZXRlcnMgPSBkZXZpY2UuZ2V0RXllUGFyYW1ldGVycyggJ2xlZnQnICk7XG5cdFx0XHRcdHZhciByZW5kZXJXaWR0aCA9IGV5ZVBhcmFtZXRlcnMucmVuZGVyV2lkdGg7XG5cdFx0XHRcdHZhciByZW5kZXJIZWlnaHQgPSBleWVQYXJhbWV0ZXJzLnJlbmRlckhlaWdodDtcblxuXHRcdFx0XHRjdXJyZW50UGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcblx0XHRcdFx0Y3VycmVudFNpemUgPSByZW5kZXJlci5nZXRTaXplKCk7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0RHJhd2luZ0J1ZmZlclNpemUoIHJlbmRlcldpZHRoICogMiwgcmVuZGVySGVpZ2h0LCAxICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHNjb3BlLmVuYWJsZWQgKSB7XG5cblx0XHRcdFx0cmVuZGVyZXIuc2V0RHJhd2luZ0J1ZmZlclNpemUoIGN1cnJlbnRTaXplLndpZHRoLCBjdXJyZW50U2l6ZS5oZWlnaHQsIGN1cnJlbnRQaXhlbFJhdGlvICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndnJkaXNwbGF5cHJlc2VudGNoYW5nZScsIG9uVlJEaXNwbGF5UHJlc2VudENoYW5nZSwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLnVzZXJIZWlnaHQgPSAxLjY7XG5cblx0XHR0aGlzLmdldERldmljZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIGRldmljZTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldERldmljZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIGRldmljZSA9IHZhbHVlO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0UG9zZVRhcmdldCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkgcG9zZVRhcmdldCA9IG9iamVjdDtcblxuXHRcdH07XG5cblx0XHR0aGlzLmdldENhbWVyYSA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoIGRldmljZSA9PT0gbnVsbCApIHJldHVybiBjYW1lcmE7XG5cblx0XHRcdGRldmljZS5kZXB0aE5lYXIgPSBjYW1lcmEubmVhcjtcblx0XHRcdGRldmljZS5kZXB0aEZhciA9IGNhbWVyYS5mYXI7XG5cblx0XHRcdGRldmljZS5nZXRGcmFtZURhdGEoIGZyYW1lRGF0YSApO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgc3RhZ2VQYXJhbWV0ZXJzID0gZGV2aWNlLnN0YWdlUGFyYW1ldGVycztcblxuXHRcdFx0aWYgKCBzdGFnZVBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0c3RhbmRpbmdNYXRyaXguZnJvbUFycmF5KCBzdGFnZVBhcmFtZXRlcnMuc2l0dGluZ1RvU3RhbmRpbmdUcmFuc2Zvcm0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGFuZGluZ01hdHJpeC5tYWtlVHJhbnNsYXRpb24oIDAsIHNjb3BlLnVzZXJIZWlnaHQsIDAgKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdHZhciBwb3NlID0gZnJhbWVEYXRhLnBvc2U7XG5cdFx0XHR2YXIgcG9zZU9iamVjdCA9IHBvc2VUYXJnZXQgIT09IG51bGwgPyBwb3NlVGFyZ2V0IDogY2FtZXJhO1xuXG5cdFx0XHQvLyBXZSB3YW50IHRvIG1hbmlwdWxhdGUgcG9zZU9iamVjdCBieSBpdHMgcG9zaXRpb24gYW5kIHF1YXRlcm5pb24gY29tcG9uZW50cyBzaW5jZSB1c2VycyBtYXkgcmVseSBvbiB0aGVtLlxuXHRcdFx0cG9zZU9iamVjdC5tYXRyaXguY29weSggc3RhbmRpbmdNYXRyaXggKTtcblx0XHRcdHBvc2VPYmplY3QubWF0cml4LmRlY29tcG9zZSggcG9zZU9iamVjdC5wb3NpdGlvbiwgcG9zZU9iamVjdC5xdWF0ZXJuaW9uLCBwb3NlT2JqZWN0LnNjYWxlICk7XG5cblx0XHRcdGlmICggcG9zZS5vcmllbnRhdGlvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0ZW1wUXVhdGVybmlvbi5mcm9tQXJyYXkgKCBwb3NlLm9yaWVudGF0aW9uICk7XG5cdFx0XHRcdHBvc2VPYmplY3QucXVhdGVybmlvbi5tdWx0aXBseSggdGVtcFF1YXRlcm5pb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBvc2UucG9zaXRpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGVtcFF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBzdGFuZGluZ01hdHJpeCApO1xuXHRcdFx0XHR0ZW1wUG9zaXRpb24uZnJvbUFycmF5KCBwb3NlLnBvc2l0aW9uICk7XG5cdFx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseVF1YXRlcm5pb24oIHRlbXBRdWF0ZXJuaW9uICk7XG5cdFx0XHRcdHBvc2VPYmplY3QucG9zaXRpb24uYWRkKCB0ZW1wUG9zaXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwb3NlT2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRcdGlmICggZGV2aWNlLmlzUHJlc2VudGluZyA9PT0gZmFsc2UgKSByZXR1cm4gY2FtZXJhO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRjYW1lcmFMLm5lYXIgPSBjYW1lcmEubmVhcjtcblx0XHRcdGNhbWVyYVIubmVhciA9IGNhbWVyYS5uZWFyO1xuXG5cdFx0XHRjYW1lcmFMLmZhciA9IGNhbWVyYS5mYXI7XG5cdFx0XHRjYW1lcmFSLmZhciA9IGNhbWVyYS5mYXI7XG5cblx0XHRcdGNhbWVyYVZSLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0Y2FtZXJhVlIubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZEludmVyc2UuZnJvbUFycmF5KCBmcmFtZURhdGEubGVmdFZpZXdNYXRyaXggKTtcblx0XHRcdGNhbWVyYVIubWF0cml4V29ybGRJbnZlcnNlLmZyb21BcnJheSggZnJhbWVEYXRhLnJpZ2h0Vmlld01hdHJpeCApO1xuXG5cdFx0XHQvLyBUT0RPIChtcmRvb2IpIERvdWJsZSBjaGVjayB0aGlzIGNvZGVcblxuXHRcdFx0c3RhbmRpbmdNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHN0YW5kaW5nTWF0cml4ICk7XG5cblx0XHRcdGNhbWVyYUwubWF0cml4V29ybGRJbnZlcnNlLm11bHRpcGx5KCBzdGFuZGluZ01hdHJpeEludmVyc2UgKTtcblx0XHRcdGNhbWVyYVIubWF0cml4V29ybGRJbnZlcnNlLm11bHRpcGx5KCBzdGFuZGluZ01hdHJpeEludmVyc2UgKTtcblxuXHRcdFx0dmFyIHBhcmVudCA9IHBvc2VPYmplY3QucGFyZW50O1xuXG5cdFx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZEludmVyc2UubXVsdGlwbHkoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xuXHRcdFx0XHRjYW1lcmFSLm1hdHJpeFdvcmxkSW52ZXJzZS5tdWx0aXBseSggbWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW52TWFwIGFuZCBNaXJyb3IgbmVlZHMgY2FtZXJhLm1hdHJpeFdvcmxkXG5cblx0XHRcdGNhbWVyYUwubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggY2FtZXJhTC5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHRcdGNhbWVyYVIubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggY2FtZXJhUi5tYXRyaXhXb3JsZEludmVyc2UgKTtcblxuXHRcdFx0Y2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmZyb21BcnJheSggZnJhbWVEYXRhLmxlZnRQcm9qZWN0aW9uTWF0cml4ICk7XG5cdFx0XHRjYW1lcmFSLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KCBmcmFtZURhdGEucmlnaHRQcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdC8vIEhBQ0sgKG1yZG9vYilcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnIvaXNzdWVzLzIwM1xuXG5cdFx0XHRjYW1lcmFWUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgbGF5ZXJzID0gZGV2aWNlLmdldExheWVycygpO1xuXG5cdFx0XHRpZiAoIGxheWVycy5sZW5ndGggKSB7XG5cblx0XHRcdFx0dmFyIGxheWVyID0gbGF5ZXJzWyAwIF07XG5cblx0XHRcdFx0aWYgKCBsYXllci5sZWZ0Qm91bmRzICE9PSBudWxsICYmIGxheWVyLmxlZnRCb3VuZHMubGVuZ3RoID09PSA0ICkge1xuXG5cdFx0XHRcdFx0Y2FtZXJhTC5ib3VuZHMuZnJvbUFycmF5KCBsYXllci5sZWZ0Qm91bmRzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbGF5ZXIucmlnaHRCb3VuZHMgIT09IG51bGwgJiYgbGF5ZXIucmlnaHRCb3VuZHMubGVuZ3RoID09PSA0ICkge1xuXG5cdFx0XHRcdFx0Y2FtZXJhUi5ib3VuZHMuZnJvbUFycmF5KCBsYXllci5yaWdodEJvdW5kcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2FtZXJhVlI7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTdGFuZGluZ01hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHN0YW5kaW5nTWF0cml4O1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc3VibWl0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggZGV2aWNlICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSBkZXZpY2Uuc3VibWl0RnJhbWUoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd2cmRpc3BsYXlwcmVzZW50Y2hhbmdlJywgb25WUkRpc3BsYXlQcmVzZW50Q2hhbmdlICk7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBXZWJHTEV4dGVuc2lvbnMoIGdsICkge1xuXG5cdFx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdXRUJHTF9kZXB0aF90ZXh0dXJlJzpcblx0XHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XG5cdFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XG5cdFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJzpcblx0XHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG5cdFx0XHRcdHJldHVybiBleHRlbnNpb247XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHRzY2h3XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFdlYkdMQ2xpcHBpbmcoKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzLFxuXG5cdFx0XHRnbG9iYWxTdGF0ZSA9IG51bGwsXG5cdFx0XHRudW1HbG9iYWxQbGFuZXMgPSAwLFxuXHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcblx0XHRcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZSxcblxuXHRcdFx0cGxhbmUgPSBuZXcgUGxhbmUoKSxcblx0XHRcdHZpZXdOb3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLFxuXG5cdFx0XHR1bmlmb3JtID0geyB2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6IGZhbHNlIH07XG5cblx0XHR0aGlzLnVuaWZvcm0gPSB1bmlmb3JtO1xuXHRcdHRoaXMubnVtUGxhbmVzID0gMDtcblx0XHR0aGlzLm51bUludGVyc2VjdGlvbiA9IDA7XG5cblx0XHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZywgY2FtZXJhICkge1xuXG5cdFx0XHR2YXIgZW5hYmxlZCA9XG5cdFx0XHRcdHBsYW5lcy5sZW5ndGggIT09IDAgfHxcblx0XHRcdFx0ZW5hYmxlTG9jYWxDbGlwcGluZyB8fFxuXHRcdFx0XHQvLyBlbmFibGUgc3RhdGUgb2YgcHJldmlvdXMgZnJhbWUgLSB0aGUgY2xpcHBpbmcgY29kZSBoYXMgdG9cblx0XHRcdFx0Ly8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxuXHRcdFx0XHRudW1HbG9iYWxQbGFuZXMgIT09IDAgfHxcblx0XHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cblx0XHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZW5hYmxlTG9jYWxDbGlwcGluZztcblxuXHRcdFx0Z2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgMCApO1xuXHRcdFx0bnVtR2xvYmFsUGxhbmVzID0gcGxhbmVzLmxlbmd0aDtcblxuXHRcdFx0cmV0dXJuIGVuYWJsZWQ7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5iZWdpblNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJlbmRlcmluZ1NoYWRvd3MgPSB0cnVlO1xuXHRcdFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZW5kU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuXHRcdFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoIHBsYW5lcywgY2xpcEludGVyc2VjdGlvbiwgY2xpcFNoYWRvd3MsIGNhbWVyYSwgY2FjaGUsIGZyb21DYWNoZSApIHtcblxuXHRcdFx0aWYgKCAhIGxvY2FsQ2xpcHBpbmdFbmFibGVkIHx8IHBsYW5lcyA9PT0gbnVsbCB8fCBwbGFuZXMubGVuZ3RoID09PSAwIHx8IHJlbmRlcmluZ1NoYWRvd3MgJiYgISBjbGlwU2hhZG93cyApIHtcblxuXHRcdFx0XHQvLyB0aGVyZSdzIG5vIGxvY2FsIGNsaXBwaW5nXG5cblx0XHRcdFx0aWYgKCByZW5kZXJpbmdTaGFkb3dzICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhlcmUncyBubyBnbG9iYWwgY2xpcHBpbmdcblxuXHRcdFx0XHRcdHByb2plY3RQbGFuZXMoIG51bGwgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgbkdsb2JhbCA9IHJlbmRlcmluZ1NoYWRvd3MgPyAwIDogbnVtR2xvYmFsUGxhbmVzLFxuXHRcdFx0XHRcdGxHbG9iYWwgPSBuR2xvYmFsICogNCxcblxuXHRcdFx0XHRcdGRzdEFycmF5ID0gY2FjaGUuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xuXG5cdFx0XHRcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTsgLy8gZW5zdXJlIHVuaXF1ZSBzdGF0ZVxuXG5cdFx0XHRcdGRzdEFycmF5ID0gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGxHbG9iYWwsIGZyb21DYWNoZSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbEdsb2JhbDsgKysgaSApIHtcblxuXHRcdFx0XHRcdGRzdEFycmF5WyBpIF0gPSBnbG9iYWxTdGF0ZVsgaSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWNoZS5jbGlwcGluZ1N0YXRlID0gZHN0QXJyYXk7XG5cdFx0XHRcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gY2xpcEludGVyc2VjdGlvbiA/IHRoaXMubnVtUGxhbmVzIDogMDtcblx0XHRcdFx0dGhpcy5udW1QbGFuZXMgKz0gbkdsb2JhbDtcblxuXHRcdFx0fVxuXG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcblxuXHRcdFx0aWYgKCB1bmlmb3JtLnZhbHVlICE9PSBnbG9iYWxTdGF0ZSApIHtcblxuXHRcdFx0XHR1bmlmb3JtLnZhbHVlID0gZ2xvYmFsU3RhdGU7XG5cdFx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSBudW1HbG9iYWxQbGFuZXMgPiAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjb3BlLm51bVBsYW5lcyA9IG51bUdsb2JhbFBsYW5lcztcblx0XHRcdHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgZHN0T2Zmc2V0LCBza2lwVHJhbnNmb3JtICkge1xuXG5cdFx0XHR2YXIgblBsYW5lcyA9IHBsYW5lcyAhPT0gbnVsbCA/IHBsYW5lcy5sZW5ndGggOiAwLFxuXHRcdFx0XHRkc3RBcnJheSA9IG51bGw7XG5cblx0XHRcdGlmICggblBsYW5lcyAhPT0gMCApIHtcblxuXHRcdFx0XHRkc3RBcnJheSA9IHVuaWZvcm0udmFsdWU7XG5cblx0XHRcdFx0aWYgKCBza2lwVHJhbnNmb3JtICE9PSB0cnVlIHx8IGRzdEFycmF5ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dmFyIGZsYXRTaXplID0gZHN0T2Zmc2V0ICsgblBsYW5lcyAqIDQsXG5cdFx0XHRcdFx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcblxuXHRcdFx0XHRcdHZpZXdOb3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0XHRpZiAoIGRzdEFycmF5ID09PSBudWxsIHx8IGRzdEFycmF5Lmxlbmd0aCA8IGZsYXRTaXplICkge1xuXG5cdFx0XHRcdFx0XHRkc3RBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGZsYXRTaXplICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGk0ID0gZHN0T2Zmc2V0OyBpICE9PSBuUGxhbmVzOyArKyBpLCBpNCArPSA0ICkge1xuXG5cdFx0XHRcdFx0XHRwbGFuZS5jb3B5KCBwbGFuZXNbIGkgXSApLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCwgdmlld05vcm1hbE1hdHJpeCApO1xuXG5cdFx0XHRcdFx0XHRwbGFuZS5ub3JtYWwudG9BcnJheSggZHN0QXJyYXksIGk0ICk7XG5cdFx0XHRcdFx0XHRkc3RBcnJheVsgaTQgKyAzIF0gPSBwbGFuZS5jb25zdGFudDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5O1xuXHRcdFx0XHR1bmlmb3JtLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xuXG5cdFx0XHRyZXR1cm4gZHN0QXJyYXk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHRoZXNwaXRlIC8gaHR0cDovL3d3dy50d2l0dGVyLmNvbS90aGVzcGl0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBXZWJHTFV0aWxzKCBnbCwgZXh0ZW5zaW9ucyApIHtcblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnQoIHAgKSB7XG5cblx0XHRcdHZhciBleHRlbnNpb247XG5cblx0XHRcdGlmICggcCA9PT0gUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gZ2wuUkVQRUFUO1xuXHRcdFx0aWYgKCBwID09PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIGdsLkNMQU1QX1RPX0VER0U7XG5cdFx0XHRpZiAoIHAgPT09IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gZ2wuTUlSUk9SRURfUkVQRUFUO1xuXG5cdFx0XHRpZiAoIHAgPT09IE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gZ2wuTkVBUkVTVDtcblx0XHRcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcblx0XHRcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cblx0XHRcdGlmICggcCA9PT0gTGluZWFyRmlsdGVyICkgcmV0dXJuIGdsLkxJTkVBUjtcblx0XHRcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XG5cdFx0XHRpZiAoIHAgPT09IExpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblxuXHRcdFx0aWYgKCBwID09PSBVbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xuXHRcdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcblx0XHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG5cblx0XHRcdGlmICggcCA9PT0gQnl0ZVR5cGUgKSByZXR1cm4gZ2wuQllURTtcblx0XHRcdGlmICggcCA9PT0gU2hvcnRUeXBlICkgcmV0dXJuIGdsLlNIT1JUO1xuXHRcdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVDtcblx0XHRcdGlmICggcCA9PT0gSW50VHlwZSApIHJldHVybiBnbC5JTlQ7XG5cdFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9JTlQ7XG5cdFx0XHRpZiAoIHAgPT09IEZsb2F0VHlwZSApIHJldHVybiBnbC5GTE9BVDtcblxuXHRcdFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkge1xuXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwID09PSBBbHBoYUZvcm1hdCApIHJldHVybiBnbC5BTFBIQTtcblx0XHRcdGlmICggcCA9PT0gUkdCRm9ybWF0ICkgcmV0dXJuIGdsLlJHQjtcblx0XHRcdGlmICggcCA9PT0gUkdCQUZvcm1hdCApIHJldHVybiBnbC5SR0JBO1xuXHRcdFx0aWYgKCBwID09PSBMdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gZ2wuTFVNSU5BTkNFO1xuXHRcdFx0aWYgKCBwID09PSBMdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBnbC5MVU1JTkFOQ0VfQUxQSEE7XG5cdFx0XHRpZiAoIHAgPT09IERlcHRoRm9ybWF0ICkgcmV0dXJuIGdsLkRFUFRIX0NPTVBPTkVOVDtcblx0XHRcdGlmICggcCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkgcmV0dXJuIGdsLkRFUFRIX1NURU5DSUw7XG5cblx0XHRcdGlmICggcCA9PT0gQWRkRXF1YXRpb24gKSByZXR1cm4gZ2wuRlVOQ19BREQ7XG5cdFx0XHRpZiAoIHAgPT09IFN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gZ2wuRlVOQ19TVUJUUkFDVDtcblx0XHRcdGlmICggcCA9PT0gUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xuXG5cdFx0XHRpZiAoIHAgPT09IFplcm9GYWN0b3IgKSByZXR1cm4gZ2wuWkVSTztcblx0XHRcdGlmICggcCA9PT0gT25lRmFjdG9yICkgcmV0dXJuIGdsLk9ORTtcblx0XHRcdGlmICggcCA9PT0gU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuU1JDX0NPTE9SO1xuXHRcdFx0aWYgKCBwID09PSBPbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIGdsLk9ORV9NSU5VU19TUkNfQ09MT1I7XG5cdFx0XHRpZiAoIHAgPT09IFNyY0FscGhhRmFjdG9yICkgcmV0dXJuIGdsLlNSQ19BTFBIQTtcblx0XHRcdGlmICggcCA9PT0gT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuXHRcdFx0aWYgKCBwID09PSBEc3RBbHBoYUZhY3RvciApIHJldHVybiBnbC5EU1RfQUxQSEE7XG5cdFx0XHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcblxuXHRcdFx0aWYgKCBwID09PSBEc3RDb2xvckZhY3RvciApIHJldHVybiBnbC5EU1RfQ09MT1I7XG5cdFx0XHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcblx0XHRcdGlmICggcCA9PT0gU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBnbC5TUkNfQUxQSEFfU0FUVVJBVEU7XG5cblx0XHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8XG5cdFx0XHRcdHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgfHxcblx0XHRcdFx0cCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHtcblxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHAgPT09IFJHQl9FVEMxX0Zvcm1hdCApIHtcblxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQgfHxcblx0XHRcdFx0cCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgfHxcblx0XHRcdFx0cCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0IHx8XG5cdFx0XHRcdHAgPT09IFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCB8fFxuXHRcdFx0XHRwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YycgKTtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHAgPT09IE1pbkVxdWF0aW9uIHx8IHAgPT09IE1heEVxdWF0aW9uICkge1xuXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGlmICggcCA9PT0gTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XG5cdFx0XHRcdFx0aWYgKCBwID09PSBNYXhFcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUFYX0VYVDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwID09PSBVbnNpZ25lZEludDI0OFR5cGUgKSB7XG5cblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xuXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7IGNvbnZlcnQ6IGNvbnZlcnQgfTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFVuaWZvcm1zQ2FjaGUoKSB7XG5cblx0XHR2YXIgbGlnaHRzID0ge307XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0XHRcdFx0aWYgKCBsaWdodHNbIGxpZ2h0LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBsaWdodHNbIGxpZ2h0LmlkIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB1bmlmb3JtcztcblxuXHRcdFx0XHRzd2l0Y2ggKCBsaWdodC50eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cblx0XHRcdFx0XHRcdFx0c2hhZG93OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcblx0XHRcdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXG5cdFx0XHRcdFx0XHRcdGNvbmVDb3M6IDAsXG5cdFx0XHRcdFx0XHRcdHBlbnVtYnJhQ29zOiAwLFxuXHRcdFx0XHRcdFx0XHRkZWNheTogMCxcblxuXHRcdFx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxuXHRcdFx0XHRcdFx0XHRkZWNheTogMCxcblxuXHRcdFx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuXHRcdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYU5lYXI6IDEsXG5cdFx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYUZhcjogMTAwMFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdHNreUNvbG9yOiBuZXcgQ29sb3IoKSxcblx0XHRcdFx0XHRcdFx0Z3JvdW5kQ29sb3I6IG5ldyBDb2xvcigpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdSZWN0QXJlYUxpZ2h0Jzpcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRcdFx0XHRoYWxmV2lkdGg6IG5ldyBWZWN0b3IzKCksXG5cdFx0XHRcdFx0XHRcdGhhbGZIZWlnaHQ6IG5ldyBWZWN0b3IzKClcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHNldCBSZWN0QXJlYUxpZ2h0IHNoYWRvdyB1bmlmb3Jtc1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdHZhciBjb3VudCA9IDA7XG5cblx0ZnVuY3Rpb24gV2ViR0xMaWdodHMoKSB7XG5cblx0XHR2YXIgY2FjaGUgPSBuZXcgVW5pZm9ybXNDYWNoZSgpO1xuXG5cdFx0dmFyIHN0YXRlID0ge1xuXG5cdFx0XHRpZDogY291bnQgKyssXG5cblx0XHRcdGhhc2g6ICcnLFxuXG5cdFx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcblx0XHRcdGRpcmVjdGlvbmFsOiBbXSxcblx0XHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiBbXSxcblx0XHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiBbXSxcblx0XHRcdHNwb3Q6IFtdLFxuXHRcdFx0c3BvdFNoYWRvd01hcDogW10sXG5cdFx0XHRzcG90U2hhZG93TWF0cml4OiBbXSxcblx0XHRcdHJlY3RBcmVhOiBbXSxcblx0XHRcdHBvaW50OiBbXSxcblx0XHRcdHBvaW50U2hhZG93TWFwOiBbXSxcblx0XHRcdHBvaW50U2hhZG93TWF0cml4OiBbXSxcblx0XHRcdGhlbWk6IFtdXG5cblx0XHR9O1xuXG5cdFx0dmFyIHZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBtYXRyaXg0ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbWF0cml4NDIgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0ZnVuY3Rpb24gc2V0dXAoIGxpZ2h0cywgc2hhZG93cywgY2FtZXJhICkge1xuXG5cdFx0XHR2YXIgciA9IDAsIGcgPSAwLCBiID0gMDtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcblx0XHRcdHZhciBwb2ludExlbmd0aCA9IDA7XG5cdFx0XHR2YXIgc3BvdExlbmd0aCA9IDA7XG5cdFx0XHR2YXIgcmVjdEFyZWFMZW5ndGggPSAwO1xuXHRcdFx0dmFyIGhlbWlMZW5ndGggPSAwO1xuXG5cdFx0XHR2YXIgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXG5cdFx0XHRcdHZhciBjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0XHR2YXIgaW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdFx0XHR2YXIgc2hhZG93TWFwID0gKCBsaWdodC5zaGFkb3cgJiYgbGlnaHQuc2hhZG93Lm1hcCApID8gbGlnaHQuc2hhZG93Lm1hcC50ZXh0dXJlIDogbnVsbDtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0LmlzQW1iaWVudExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0ciArPSBjb2xvci5yICogaW50ZW5zaXR5O1xuXHRcdFx0XHRcdGcgKz0gY29sb3IuZyAqIGludGVuc2l0eTtcblx0XHRcdFx0XHRiICs9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggdmVjdG9yMyApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvdyA9IGxpZ2h0LmNhc3RTaGFkb3c7XG5cblx0XHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHNoYWRvd01hcDtcblx0XHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XG5cdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0XHRcdGRpcmVjdGlvbmFsTGVuZ3RoICsrO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzU3BvdExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0dmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIHZlY3RvcjMgKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5jb25lQ29zID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XG5cdFx0XHRcdFx0dW5pZm9ybXMucGVudW1icmFDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKiAoIDEgLSBsaWdodC5wZW51bWJyYSApICk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvdyA9IGxpZ2h0LmNhc3RTaGFkb3c7XG5cblx0XHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdGF0ZS5zcG90U2hhZG93TWFwWyBzcG90TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hdHJpeFsgc3BvdExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcblx0XHRcdFx0XHRzdGF0ZS5zcG90WyBzcG90TGVuZ3RoIF0gPSB1bmlmb3JtcztcblxuXHRcdFx0XHRcdHNwb3RMZW5ndGggKys7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNSZWN0QXJlYUxpZ2h0ICkge1xuXG5cdFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdFx0Ly8gKGEpIGludGVuc2l0eSBpcyB0aGUgdG90YWwgdmlzaWJsZSBsaWdodCBlbWl0dGVkXG5cdFx0XHRcdFx0Ly91bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgLyAoIGxpZ2h0LndpZHRoICogbGlnaHQuaGVpZ2h0ICogTWF0aC5QSSApICk7XG5cblx0XHRcdFx0XHQvLyAoYikgaW50ZW5zaXR5IGlzIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBsaWdodFxuXHRcdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdFx0Ly8gZXh0cmFjdCBsb2NhbCByb3RhdGlvbiBvZiBsaWdodCB0byBkZXJpdmUgd2lkdGgvaGVpZ2h0IGhhbGYgdmVjdG9yc1xuXHRcdFx0XHRcdG1hdHJpeDQyLmlkZW50aXR5KCk7XG5cdFx0XHRcdFx0bWF0cml4NC5jb3B5KCBsaWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdG1hdHJpeDQucHJlbXVsdGlwbHkoIHZpZXdNYXRyaXggKTtcblx0XHRcdFx0XHRtYXRyaXg0Mi5leHRyYWN0Um90YXRpb24oIG1hdHJpeDQgKTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmhhbGZXaWR0aC5zZXQoIGxpZ2h0LndpZHRoICogMC41LCAwLjAsIDAuMCApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmhhbGZIZWlnaHQuc2V0KCAwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wICk7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmhhbGZIZWlnaHQuYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xuXG5cdFx0XHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgZGlzdGFuY2U/XG5cdFx0XHRcdFx0Ly8gdW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuXHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhWyByZWN0QXJlYUxlbmd0aCBdID0gdW5pZm9ybXM7XG5cblx0XHRcdFx0XHRyZWN0QXJlYUxlbmd0aCArKztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0XHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xuXG5cdFx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xuXHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93Q2FtZXJhTmVhciA9IHNoYWRvdy5jYW1lcmEubmVhcjtcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0NhbWVyYUZhciA9IHNoYWRvdy5jYW1lcmEuZmFyO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXBbIHBvaW50TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XG5cdFx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXRyaXhbIHBvaW50TGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xuXHRcdFx0XHRcdHN0YXRlLnBvaW50WyBwb2ludExlbmd0aCBdID0gdW5pZm9ybXM7XG5cblx0XHRcdFx0XHRwb2ludExlbmd0aCArKztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0hlbWlzcGhlcmVMaWdodCApIHtcblxuXHRcdFx0XHRcdHZhciB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNreUNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXHRcdFx0XHRcdHVuaWZvcm1zLmdyb3VuZENvbG9yLmNvcHkoIGxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0c3RhdGUuaGVtaVsgaGVtaUxlbmd0aCBdID0gdW5pZm9ybXM7XG5cblx0XHRcdFx0XHRoZW1pTGVuZ3RoICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5hbWJpZW50WyAwIF0gPSByO1xuXHRcdFx0c3RhdGUuYW1iaWVudFsgMSBdID0gZztcblx0XHRcdHN0YXRlLmFtYmllbnRbIDIgXSA9IGI7XG5cblx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xuXHRcdFx0c3RhdGUuc3BvdC5sZW5ndGggPSBzcG90TGVuZ3RoO1xuXHRcdFx0c3RhdGUucmVjdEFyZWEubGVuZ3RoID0gcmVjdEFyZWFMZW5ndGg7XG5cdFx0XHRzdGF0ZS5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcblx0XHRcdHN0YXRlLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcblxuXHRcdFx0c3RhdGUuaGFzaCA9IHN0YXRlLmlkICsgJywnICsgZGlyZWN0aW9uYWxMZW5ndGggKyAnLCcgKyBwb2ludExlbmd0aCArICcsJyArIHNwb3RMZW5ndGggKyAnLCcgKyByZWN0QXJlYUxlbmd0aCArICcsJyArIGhlbWlMZW5ndGggKyAnLCcgKyBzaGFkb3dzLmxlbmd0aDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzZXR1cDogc2V0dXAsXG5cdFx0XHRzdGF0ZTogc3RhdGVcblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICovXG5cblx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJTdGF0ZSgpIHtcblxuXHRcdHZhciBsaWdodHMgPSBuZXcgV2ViR0xMaWdodHMoKTtcblxuXHRcdHZhciBsaWdodHNBcnJheSA9IFtdO1xuXHRcdHZhciBzaGFkb3dzQXJyYXkgPSBbXTtcblx0XHR2YXIgc3ByaXRlc0FycmF5ID0gW107XG5cblx0XHRmdW5jdGlvbiBpbml0KCkge1xuXG5cdFx0XHRsaWdodHNBcnJheS5sZW5ndGggPSAwO1xuXHRcdFx0c2hhZG93c0FycmF5Lmxlbmd0aCA9IDA7XG5cdFx0XHRzcHJpdGVzQXJyYXkubGVuZ3RoID0gMDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHB1c2hMaWdodCggbGlnaHQgKSB7XG5cblx0XHRcdGxpZ2h0c0FycmF5LnB1c2goIGxpZ2h0ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoU2hhZG93KCBzaGFkb3dMaWdodCApIHtcblxuXHRcdFx0c2hhZG93c0FycmF5LnB1c2goIHNoYWRvd0xpZ2h0ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoU3ByaXRlKCBzaGFkb3dMaWdodCApIHtcblxuXHRcdFx0c3ByaXRlc0FycmF5LnB1c2goIHNoYWRvd0xpZ2h0ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cExpZ2h0cyggY2FtZXJhICkge1xuXG5cdFx0XHRsaWdodHMuc2V0dXAoIGxpZ2h0c0FycmF5LCBzaGFkb3dzQXJyYXksIGNhbWVyYSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHN0YXRlID0ge1xuXHRcdFx0bGlnaHRzQXJyYXk6IGxpZ2h0c0FycmF5LFxuXHRcdFx0c2hhZG93c0FycmF5OiBzaGFkb3dzQXJyYXksXG5cdFx0XHRzcHJpdGVzQXJyYXk6IHNwcml0ZXNBcnJheSxcblxuXHRcdFx0bGlnaHRzOiBsaWdodHNcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRzdGF0ZTogc3RhdGUsXG5cdFx0XHRzZXR1cExpZ2h0czogc2V0dXBMaWdodHMsXG5cblx0XHRcdHB1c2hMaWdodDogcHVzaExpZ2h0LFxuXHRcdFx0cHVzaFNoYWRvdzogcHVzaFNoYWRvdyxcblx0XHRcdHB1c2hTcHJpdGU6IHB1c2hTcHJpdGVcblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlclN0YXRlcygpIHtcblxuXHRcdHZhciByZW5kZXJTdGF0ZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGdldCggc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdFx0dmFyIGhhc2ggPSBzY2VuZS5pZCArICcsJyArIGNhbWVyYS5pZDtcblxuXHRcdFx0dmFyIHJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVzWyBoYXNoIF07XG5cblx0XHRcdGlmICggcmVuZGVyU3RhdGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZW5kZXJTdGF0ZSA9IG5ldyBXZWJHTFJlbmRlclN0YXRlKCk7XG5cdFx0XHRcdHJlbmRlclN0YXRlc1sgaGFzaCBdID0gcmVuZGVyU3RhdGU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlbmRlclN0YXRlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuXHRcdFx0cmVuZGVyU3RhdGVzID0ge307XG5cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRkaXNwb3NlOiBkaXNwb3NlXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlcmVyKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgUkVWSVNJT04gKTtcblxuXHRcdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG5cdFx0dmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKSxcblx0XHRcdF9jb250ZXh0ID0gcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiBudWxsLFxuXG5cdFx0XHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXG5cdFx0XHRfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcblx0XHRcdF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxuXHRcdFx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuXHRcdFx0X3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXG5cdFx0XHRfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXG5cdFx0XHRfcG93ZXJQcmVmZXJlbmNlID0gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlIDogJ2RlZmF1bHQnO1xuXG5cdFx0dmFyIGN1cnJlbnRSZW5kZXJMaXN0ID0gbnVsbDtcblx0XHR2YXIgY3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXHRcdHRoaXMuY29udGV4dCA9IG51bGw7XG5cblx0XHQvLyBjbGVhcmluZ1xuXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xuXHRcdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0XHQvLyBzY2VuZSBncmFwaFxuXG5cdFx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XG5cblx0XHQvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcblxuXHRcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcblx0XHR0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XG5cblx0XHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuXHRcdHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7XHQvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHR0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcblx0XHR0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cblx0XHQvLyBwaHlzaWNhbCBsaWdodHNcblxuXHRcdHRoaXMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPSBmYWxzZTtcblxuXHRcdC8vIHRvbmUgbWFwcGluZ1xuXG5cdFx0dGhpcy50b25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nO1xuXHRcdHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMDtcblx0XHR0aGlzLnRvbmVNYXBwaW5nV2hpdGVQb2ludCA9IDEuMDtcblxuXHRcdC8vIG1vcnBoc1xuXG5cdFx0dGhpcy5tYXhNb3JwaFRhcmdldHMgPSA4O1xuXHRcdHRoaXMubWF4TW9ycGhOb3JtYWxzID0gNDtcblxuXHRcdC8vIGludGVybmFsIHByb3BlcnRpZXNcblxuXHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cblx0XHRcdF9pc0NvbnRleHRMb3N0ID0gZmFsc2UsXG5cblx0XHRcdC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cblx0XHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbCxcblx0XHRcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJyxcblxuXHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsLFxuXHRcdFx0X2N1cnJlbnRBcnJheUNhbWVyYSA9IG51bGwsXG5cblx0XHRcdF9jdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLFxuXHRcdFx0X2N1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKSxcblx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBudWxsLFxuXG5cdFx0XHQvL1xuXG5cdFx0XHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXG5cblx0XHRcdC8vXG5cblx0XHRcdF93aWR0aCA9IF9jYW52YXMud2lkdGgsXG5cdFx0XHRfaGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXG5cblx0XHRcdF9waXhlbFJhdGlvID0gMSxcblxuXHRcdFx0X3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApLFxuXHRcdFx0X3NjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICksXG5cdFx0XHRfc2Npc3NvclRlc3QgPSBmYWxzZSxcblxuXHRcdFx0Ly8gZnJ1c3R1bVxuXG5cdFx0XHRfZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCksXG5cblx0XHRcdC8vIGNsaXBwaW5nXG5cblx0XHRcdF9jbGlwcGluZyA9IG5ldyBXZWJHTENsaXBwaW5nKCksXG5cdFx0XHRfY2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG5cdFx0XHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcblxuXHRcdFx0Ly8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKSxcblxuXHRcdFx0X3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpLFxuXG5cdFx0XHQvLyBpbmZvXG5cblx0XHRcdF9pbmZvTWVtb3J5ID0ge1xuXHRcdFx0XHRnZW9tZXRyaWVzOiAwLFxuXHRcdFx0XHR0ZXh0dXJlczogMFxuXHRcdFx0fSxcblxuXHRcdFx0X2luZm9SZW5kZXIgPSB7XG5cblx0XHRcdFx0ZnJhbWU6IDAsXG5cdFx0XHRcdGNhbGxzOiAwLFxuXHRcdFx0XHR2ZXJ0aWNlczogMCxcblx0XHRcdFx0ZmFjZXM6IDAsXG5cdFx0XHRcdHBvaW50czogMFxuXG5cdFx0XHR9O1xuXG5cdFx0dGhpcy5pbmZvID0ge1xuXG5cdFx0XHRyZW5kZXI6IF9pbmZvUmVuZGVyLFxuXHRcdFx0bWVtb3J5OiBfaW5mb01lbW9yeSxcblx0XHRcdHByb2dyYW1zOiBudWxsLFxuXHRcdFx0YXV0b1Jlc2V0OiB0cnVlLFxuXHRcdFx0cmVzZXQ6IHJlc2V0SW5mb1xuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc2V0SW5mbygpIHtcblxuXHRcdFx0X2luZm9SZW5kZXIuZnJhbWUgKys7XG5cdFx0XHRfaW5mb1JlbmRlci5jYWxscyA9IDA7XG5cdFx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyA9IDA7XG5cdFx0XHRfaW5mb1JlbmRlci5mYWNlcyA9IDA7XG5cdFx0XHRfaW5mb1JlbmRlci5wb2ludHMgPSAwO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpIHtcblxuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5pdGlhbGl6ZVxuXG5cdFx0dmFyIF9nbDtcblxuXHRcdHRyeSB7XG5cblx0XHRcdHZhciBjb250ZXh0QXR0cmlidXRlcyA9IHtcblx0XHRcdFx0YWxwaGE6IF9hbHBoYSxcblx0XHRcdFx0ZGVwdGg6IF9kZXB0aCxcblx0XHRcdFx0c3RlbmNpbDogX3N0ZW5jaWwsXG5cdFx0XHRcdGFudGlhbGlhczogX2FudGlhbGlhcyxcblx0XHRcdFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuXHRcdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXG5cdFx0XHRcdHBvd2VyUHJlZmVyZW5jZTogX3Bvd2VyUHJlZmVyZW5jZVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZXZlbnQgbGlzdGVuZXJzIG11c3QgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgV2ViR0wgY29udGV4dCBpcyBjcmVhdGVkLCBzZWUgIzEyNzUzXG5cblx0XHRcdF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXHRcdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSApO1xuXG5cdFx0XHRfZ2wgPSBfY29udGV4dCB8fCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcsIGNvbnRleHRBdHRyaWJ1dGVzICkgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJywgY29udGV4dEF0dHJpYnV0ZXMgKTtcblxuXHRcdFx0aWYgKCBfZ2wgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0LicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gU29tZSBleHBlcmltZW50YWwtd2ViZ2wgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBoYXZlIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdFxuXG5cdFx0XHRpZiAoIF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHsgJ3JhbmdlTWluJzogMSwgJ3JhbmdlTWF4JzogMSwgJ3ByZWNpc2lvbic6IDEgfTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IubWVzc2FnZSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgc3RhdGU7XG5cdFx0dmFyIHByb3BlcnRpZXMsIHRleHR1cmVzLCBhdHRyaWJ1dGVzLCBnZW9tZXRyaWVzLCBvYmplY3RzO1xuXHRcdHZhciBwcm9ncmFtQ2FjaGUsIHJlbmRlckxpc3RzLCByZW5kZXJTdGF0ZXM7XG5cblx0XHR2YXIgYmFja2dyb3VuZCwgbW9ycGh0YXJnZXRzLCBidWZmZXJSZW5kZXJlciwgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXHRcdHZhciBzcHJpdGVSZW5kZXJlcjtcblxuXHRcdHZhciB1dGlscztcblxuXHRcdGZ1bmN0aW9uIGluaXRHTENvbnRleHQoKSB7XG5cblx0XHRcdGV4dGVuc2lvbnMgPSBuZXcgV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG5cdFx0XHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XG5cdFx0XHRleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKTtcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRcdFx0dXRpbHMgPSBuZXcgV2ViR0xVdGlscyggX2dsLCBleHRlbnNpb25zICk7XG5cblx0XHRcdGNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyggX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICk7XG5cblx0XHRcdHN0YXRlID0gbmV3IFdlYkdMU3RhdGUoIF9nbCwgZXh0ZW5zaW9ucywgdXRpbHMgKTtcblx0XHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XG5cdFx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xuXG5cdFx0XHRwcm9wZXJ0aWVzID0gbmV3IFdlYkdMUHJvcGVydGllcygpO1xuXHRcdFx0dGV4dHVyZXMgPSBuZXcgV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCB1dGlscywgX2luZm9NZW1vcnksIF9pbmZvUmVuZGVyICk7XG5cdFx0XHRhdHRyaWJ1dGVzID0gbmV3IFdlYkdMQXR0cmlidXRlcyggX2dsICk7XG5cdFx0XHRnZW9tZXRyaWVzID0gbmV3IFdlYkdMR2VvbWV0cmllcyggX2dsLCBhdHRyaWJ1dGVzLCBfaW5mb01lbW9yeSApO1xuXHRcdFx0b2JqZWN0cyA9IG5ldyBXZWJHTE9iamVjdHMoIGdlb21ldHJpZXMsIF9pbmZvUmVuZGVyICk7XG5cdFx0XHRtb3JwaHRhcmdldHMgPSBuZXcgV2ViR0xNb3JwaHRhcmdldHMoIF9nbCApO1xuXHRcdFx0cHJvZ3JhbUNhY2hlID0gbmV3IFdlYkdMUHJvZ3JhbXMoIF90aGlzLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKTtcblx0XHRcdHJlbmRlckxpc3RzID0gbmV3IFdlYkdMUmVuZGVyTGlzdHMoKTtcblx0XHRcdHJlbmRlclN0YXRlcyA9IG5ldyBXZWJHTFJlbmRlclN0YXRlcygpO1xuXG5cdFx0XHRiYWNrZ3JvdW5kID0gbmV3IFdlYkdMQmFja2dyb3VuZCggX3RoaXMsIHN0YXRlLCBnZW9tZXRyaWVzLCBfcHJlbXVsdGlwbGllZEFscGhhICk7XG5cblx0XHRcdGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcblx0XHRcdGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuXG5cdFx0XHRzcHJpdGVSZW5kZXJlciA9IG5ldyBXZWJHTFNwcml0ZVJlbmRlcmVyKCBfdGhpcywgX2dsLCBzdGF0ZSwgdGV4dHVyZXMsIGNhcGFiaWxpdGllcyApO1xuXG5cdFx0XHRfdGhpcy5pbmZvLnByb2dyYW1zID0gcHJvZ3JhbUNhY2hlLnByb2dyYW1zO1xuXG5cdFx0XHRfdGhpcy5jb250ZXh0ID0gX2dsO1xuXHRcdFx0X3RoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xuXHRcdFx0X3RoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cdFx0XHRfdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcblx0XHRcdF90aGlzLnJlbmRlckxpc3RzID0gcmVuZGVyTGlzdHM7XG5cdFx0XHRfdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdEdMQ29udGV4dCgpO1xuXG5cdFx0Ly8gdnJcblxuXHRcdHZhciB2ciA9IG5ldyBXZWJWUk1hbmFnZXIoIF90aGlzICk7XG5cblx0XHR0aGlzLnZyID0gdnI7XG5cblx0XHQvLyBzaGFkb3cgbWFwXG5cblx0XHR2YXIgc2hhZG93TWFwID0gbmV3IFdlYkdMU2hhZG93TWFwKCBfdGhpcywgb2JqZWN0cywgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XG5cblx0XHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcblxuXHRcdC8vIEFQSVxuXG5cdFx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2dsO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBfZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcblx0XHRcdGlmICggZXh0ZW5zaW9uICkgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5mb3JjZUNvbnRleHRSZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICk7XG5cdFx0XHRpZiAoIGV4dGVuc2lvbiApIGV4dGVuc2lvbi5yZXN0b3JlQ29udGV4dCgpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIF9waXhlbFJhdGlvO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcblxuXHRcdFx0dGhpcy5zZXRTaXplKCBfd2lkdGgsIF9oZWlnaHQsIGZhbHNlICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR3aWR0aDogX3dpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IF9oZWlnaHRcblx0XHRcdH07XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcblxuXHRcdFx0dmFyIGRldmljZSA9IHZyLmdldERldmljZSgpO1xuXG5cdFx0XHRpZiAoIGRldmljZSAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENhblxcJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0X3dpZHRoID0gd2lkdGg7XG5cdFx0XHRfaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0XHRfY2FudmFzLndpZHRoID0gd2lkdGggKiBfcGl4ZWxSYXRpbztcblx0XHRcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogX3BpeGVsUmF0aW87XG5cblx0XHRcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xuXG5cdFx0XHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRcdF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5nZXREcmF3aW5nQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0d2lkdGg6IF93aWR0aCAqIF9waXhlbFJhdGlvLFxuXHRcdFx0XHRoZWlnaHQ6IF9oZWlnaHQgKiBfcGl4ZWxSYXRpb1xuXHRcdFx0fTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvICkge1xuXG5cdFx0XHRfd2lkdGggPSB3aWR0aDtcblx0XHRcdF9oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHRcdF9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuXHRcdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblxuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q3VycmVudFZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRWaWV3cG9ydDtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0XHRfdmlld3BvcnQuc2V0KCB4LCBfaGVpZ2h0IC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodCApO1xuXHRcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRcdF9zY2lzc29yLnNldCggeCwgX2hlaWdodCAtIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHQgKTtcblx0XHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcblxuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9zY2lzc29yVGVzdCA9IGJvb2xlYW4gKTtcblxuXHRcdH07XG5cblx0XHQvLyBDbGVhcmluZ1xuXG5cdFx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gYmFja2dyb3VuZC5nZXRDbGVhckNvbG9yKCk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRiYWNrZ3JvdW5kLnNldENsZWFyQ29sb3IuYXBwbHkoIGJhY2tncm91bmQsIGFyZ3VtZW50cyApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIGJhY2tncm91bmQuZ2V0Q2xlYXJBbHBoYSgpO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0YmFja2dyb3VuZC5zZXRDbGVhckFscGhhLmFwcGx5KCBiYWNrZ3JvdW5kLCBhcmd1bWVudHMgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cblx0XHRcdHZhciBiaXRzID0gMDtcblxuXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcblx0XHRcdGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XG5cdFx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG5cdFx0XHRfZ2wuY2xlYXIoIGJpdHMgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY2xlYXIoIHRydWUsIGZhbHNlLCBmYWxzZSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5jbGVhciggZmFsc2UsIHRydWUsIGZhbHNlICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuY2xlYXIoIGZhbHNlLCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG5cdFx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0XHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcblxuXHRcdH07XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcblx0XHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UgKTtcblxuXHRcdFx0cmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuXHRcdFx0cmVuZGVyU3RhdGVzLmRpc3Bvc2UoKTtcblx0XHRcdHByb3BlcnRpZXMuZGlzcG9zZSgpO1xuXHRcdFx0b2JqZWN0cy5kaXNwb3NlKCk7XG5cblx0XHRcdHZyLmRpc3Bvc2UoKTtcblxuXHRcdFx0c3RvcEFuaW1hdGlvbigpO1xuXG5cdFx0fTtcblxuXHRcdC8vIEV2ZW50c1xuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XG5cblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LicgKTtcblxuXHRcdFx0X2lzQ29udGV4dExvc3QgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0UmVzdG9yZSggLyogZXZlbnQgKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nICk7XG5cblx0XHRcdF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XG5cblx0XHRcdGluaXRHTENvbnRleHQoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTWF0ZXJpYWxEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0XHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cblx0XHRcdGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuXHRcdGZ1bmN0aW9uIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XG5cblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbTtcblxuXHRcdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBwcm9ncmFtSW5mbyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbUluZm8gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0SW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG5cdFx0XHRvYmplY3QucmVuZGVyKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdHZhciBidWZmZXJzID0gcHJvcGVydGllcy5nZXQoIG9iamVjdCApO1xuXG5cdFx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBidWZmZXJzLm5vcm1hbCApIGJ1ZmZlcnMubm9ybWFsID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cdFx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcblxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbiApO1xuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMubm9ybWFsICk7XG5cblx0XHRcdFx0aWYgKCAhIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgJiZcblx0XHRcdFx0XHQhIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgJiZcblx0XHRcdFx0XHQhIG1hdGVyaWFsLmlzTWVzaE5vcm1hbE1hdGVyaWFsICYmXG5cdFx0XHRcdFx0bWF0ZXJpYWwuZmxhdFNoYWRpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3QuY291bnQgKiAzOyBpIDwgbDsgaSArPSA5ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XG5cblx0XHRcdFx0XHRcdHZhciBueCA9ICggYXJyYXlbIGkgKyAwIF0gKyBhcnJheVsgaSArIDMgXSArIGFycmF5WyBpICsgNiBdICkgLyAzO1xuXHRcdFx0XHRcdFx0dmFyIG55ID0gKCBhcnJheVsgaSArIDEgXSArIGFycmF5WyBpICsgNCBdICsgYXJyYXlbIGkgKyA3IF0gKSAvIDM7XG5cdFx0XHRcdFx0XHR2YXIgbnogPSAoIGFycmF5WyBpICsgMiBdICsgYXJyYXlbIGkgKyA1IF0gKyBhcnJheVsgaSArIDggXSApIC8gMztcblxuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyAwIF0gPSBueDtcblx0XHRcdFx0XHRcdGFycmF5WyBpICsgMSBdID0gbnk7XG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDIgXSA9IG56O1xuXG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDMgXSA9IG54O1xuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyA0IF0gPSBueTtcblx0XHRcdFx0XHRcdGFycmF5WyBpICsgNSBdID0gbno7XG5cblx0XHRcdFx0XHRcdGFycmF5WyBpICsgNiBdID0gbng7XG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDcgXSA9IG55O1xuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyA4IF0gPSBuejtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG5cdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZXMubm9ybWFsICk7XG5cblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC51dkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cblx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlcy51diApO1xuXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IE5vQ29sb3JzICkge1xuXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLmNvbG9yICk7XG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG5cdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZXMuY29sb3IgKTtcblxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG5cdFx0XHRfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XG5cblx0XHRcdG9iamVjdC5jb3VudCA9IDA7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKSB7XG5cblx0XHRcdHZhciBmcm9udEZhY2VDVyA9ICggb2JqZWN0LmlzTWVzaCAmJiBvYmplY3QubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDAgKTtcblxuXHRcdFx0c3RhdGUuc2V0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmcm9udEZhY2VDVyApO1xuXG5cdFx0XHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cdFx0XHR2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKTtcblxuXHRcdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xuXG5cdFx0XHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnlQcm9ncmFtO1xuXHRcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0bW9ycGh0YXJnZXRzLnVwZGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0gKTtcblxuXHRcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHR2YXIgcmFuZ2VGYWN0b3IgPSAxO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRpbmRleCA9IGdlb21ldHJpZXMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xuXHRcdFx0XHRyYW5nZUZhY3RvciA9IDI7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGF0dHJpYnV0ZTtcblx0XHRcdHZhciByZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KCBpbmRleCApO1xuXG5cdFx0XHRcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xuXHRcdFx0XHRyZW5kZXJlci5zZXRJbmRleCggYXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG5cdFx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIGRhdGFDb3VudCA9IEluZmluaXR5O1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGRhdGFDb3VudCA9IGluZGV4LmNvdW50O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGRhdGFDb3VudCA9IHBvc2l0aW9uLmNvdW50O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciByYW5nZVN0YXJ0ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLnN0YXJ0ICogcmFuZ2VGYWN0b3I7XG5cdFx0XHR2YXIgcmFuZ2VDb3VudCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCAqIHJhbmdlRmFjdG9yO1xuXG5cdFx0XHR2YXIgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciA6IDA7XG5cdFx0XHR2YXIgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgKiByYW5nZUZhY3RvciA6IEluZmluaXR5O1xuXG5cdFx0XHR2YXIgZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIHJhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKTtcblx0XHRcdHZhciBkcmF3RW5kID0gTWF0aC5taW4oIGRhdGFDb3VudCwgcmFuZ2VTdGFydCArIHJhbmdlQ291bnQsIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICkgLSAxO1xuXG5cdFx0XHR2YXIgZHJhd0NvdW50ID0gTWF0aC5tYXgoIDAsIGRyYXdFbmQgLSBkcmF3U3RhcnQgKyAxICk7XG5cblx0XHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIG9iamVjdC5pc01lc2ggKSB7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBvYmplY3QuZHJhd01vZGUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgVHJpYW5nbGVzRHJhd01vZGU6XG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgVHJpYW5nbGVTdHJpcERyYXdNb2RlOlxuXHRcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVfU1RSSVAgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgVHJpYW5nbGVGYW5EcmF3TW9kZTpcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX0ZBTiApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZSApIHtcblxuXHRcdFx0XHR2YXIgbGluZVdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xuXG5cdFx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxuXG5cdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaW5lU2VnbWVudHMgKSB7XG5cblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lTG9vcCApIHtcblxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX0xPT1AgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfU1RSSVAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1BvaW50cyApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuUE9JTlRTICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPiAwICkge1xuXG5cdFx0XHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdGFydEluZGV4ID09PSB1bmRlZmluZWQgKSBzdGFydEluZGV4ID0gMDtcblxuXHRcdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblxuXHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cblx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZSA+PSAwICkge1xuXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBub3JtYWxpemVkID0gZ2VvbWV0cnlBdHRyaWJ1dGUubm9ybWFsaXplZDtcblx0XHRcdFx0XHRcdHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldCggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdFx0Ly8gVE9ETyBBdHRyaWJ1dGUgbWF5IG5vdCBiZSBhdmFpbGFibGUgb24gY29udGV4dCByZXN0b3JlXG5cblx0XHRcdFx0XHRcdGlmICggYXR0cmlidXRlID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XG5cdFx0XHRcdFx0XHR2YXIgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuXHRcdFx0XHRcdFx0dmFyIGJ5dGVzUGVyRWxlbWVudCA9IGF0dHJpYnV0ZS5ieXRlc1BlckVsZW1lbnQ7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZGF0YSA9IGdlb21ldHJ5QXR0cmlidXRlLmRhdGE7XG5cdFx0XHRcdFx0XHRcdHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGEgJiYgZGF0YS5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZGF0YS5tZXNoUGVyQXR0cmlidXRlICogZGF0YS5jb3VudDtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSAqIGJ5dGVzUGVyRWxlbWVudCwgKCBzdGFydEluZGV4ICogc3RyaWRlICsgb2Zmc2V0ICkgKiBieXRlc1BlckVsZW1lbnQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKiBnZW9tZXRyeUF0dHJpYnV0ZS5jb3VudDtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIDAsIHN0YXJ0SW5kZXggKiBzaXplICogYnl0ZXNQZXJFbGVtZW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQ29tcGlsZVxuXG5cdFx0dGhpcy5jb21waWxlID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZXMuZ2V0KCBzY2VuZSwgY2FtZXJhICk7XG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCgpO1xuXG5cdFx0XHRzY2VuZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QuaXNMaWdodCApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoTGlnaHQoIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3coIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHMoIGNhbWVyYSApO1xuXG5cdFx0XHRzY2VuZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBvYmplY3QubWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdC5tYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QubWF0ZXJpYWwubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGluaXRNYXRlcmlhbCggb2JqZWN0Lm1hdGVyaWFsWyBpIF0sIHNjZW5lLmZvZywgb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGluaXRNYXRlcmlhbCggb2JqZWN0Lm1hdGVyaWFsLCBzY2VuZS5mb2csIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fTtcblxuXHRcdC8vIEFuaW1hdGlvbiBMb29wXG5cblx0XHR2YXIgaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHR2YXIgb25BbmltYXRpb25GcmFtZSA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBzdGFydEFuaW1hdGlvbigpIHtcblxuXHRcdFx0aWYgKCBpc0FuaW1hdGluZyApIHJldHVybjtcblxuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkxvb3BGcmFtZSgpO1xuXG5cdFx0XHRpc0FuaW1hdGluZyA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdG9wQW5pbWF0aW9uKCkge1xuXG5cdFx0XHRpc0FuaW1hdGluZyA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkxvb3BGcmFtZSgpIHtcblxuXHRcdFx0dmFyIGRldmljZSA9IHZyLmdldERldmljZSgpO1xuXG5cdFx0XHRpZiAoIGRldmljZSAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkge1xuXG5cdFx0XHRcdGRldmljZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGFuaW1hdGlvbkxvb3AgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBhbmltYXRpb25Mb29wICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFuaW1hdGlvbkxvb3AoIHRpbWUgKSB7XG5cblx0XHRcdGlmICggaXNBbmltYXRpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHRvbkFuaW1hdGlvbkZyYW1lKCB0aW1lICk7XG5cblx0XHRcdHJlcXVlc3RBbmltYXRpb25Mb29wRnJhbWUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYW5pbWF0ZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdG9uQW5pbWF0aW9uRnJhbWUgPSBjYWxsYmFjaztcblx0XHRcdG9uQW5pbWF0aW9uRnJhbWUgIT09IG51bGwgPyBzdGFydEFuaW1hdGlvbigpIDogc3RvcEFuaW1hdGlvbigpO1xuXG5cdFx0fTtcblxuXHRcdC8vIFJlbmRlcmluZ1xuXG5cdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0aWYgKCAhICggY2FtZXJhICYmIGNhbWVyYS5pc0NhbWVyYSApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBfaXNDb250ZXh0TG9zdCApIHJldHVybjtcblxuXHRcdFx0Ly8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxuXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuXHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG5cdFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0aWYgKCB2ci5lbmFibGVkICkge1xuXG5cdFx0XHRcdGNhbWVyYSA9IHZyLmdldENhbWVyYSggY2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVzLmdldCggc2NlbmUsIGNhbWVyYSApO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLmluaXQoKTtcblxuXHRcdFx0c2NlbmUub25CZWZvcmVSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcblx0XHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cdFx0XHRfY2xpcHBpbmdFbmFibGVkID0gX2NsaXBwaW5nLmluaXQoIHRoaXMuY2xpcHBpbmdQbGFuZXMsIF9sb2NhbENsaXBwaW5nRW5hYmxlZCwgY2FtZXJhICk7XG5cblx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0ID0gcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgY2FtZXJhICk7XG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5pbml0KCk7XG5cblx0XHRcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEsIF90aGlzLnNvcnRPYmplY3RzICk7XG5cblx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3Quc29ydCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggX2NsaXBwaW5nRW5hYmxlZCApIF9jbGlwcGluZy5iZWdpblNoYWRvd3MoKTtcblxuXHRcdFx0dmFyIHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG5cblx0XHRcdHNoYWRvd01hcC5yZW5kZXIoIHNoYWRvd3NBcnJheSwgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHMoIGNhbWVyYSApO1xuXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuZW5kU2hhZG93cygpO1xuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIHRoaXMuaW5mby5hdXRvUmVzZXQgKSB0aGlzLmluZm8ucmVzZXQoKTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXQgPSBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0YmFja2dyb3VuZC5yZW5kZXIoIGN1cnJlbnRSZW5kZXJMaXN0LCBzY2VuZSwgY2FtZXJhLCBmb3JjZUNsZWFyICk7XG5cblx0XHRcdC8vIHJlbmRlciBzY2VuZVxuXG5cdFx0XHR2YXIgb3BhcXVlT2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0Lm9wYXF1ZTtcblx0XHRcdHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc3BhcmVudDtcblxuXHRcdFx0aWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHZhciBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcblxuXHRcdFx0XHRpZiAoIG9wYXF1ZU9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXHRcdFx0XHRpZiAoIHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggKSByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuXHRcdFx0XHRpZiAoIG9wYXF1ZU9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXG5cblx0XHRcdFx0aWYgKCB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY3VzdG9tIHJlbmRlcmVyc1xuXG5cdFx0XHR2YXIgc3ByaXRlc0FycmF5ID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnNwcml0ZXNBcnJheTtcblxuXHRcdFx0c3ByaXRlUmVuZGVyZXIucmVuZGVyKCBzcHJpdGVzQXJyYXksIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdFx0Ly8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0dGV4dHVyZXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIHRydWUgKTtcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggdHJ1ZSApO1xuXHRcdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKCB0cnVlICk7XG5cblx0XHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIGZhbHNlICk7XG5cblx0XHRcdHNjZW5lLm9uQWZ0ZXJSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhICk7XG5cblx0XHRcdGlmICggdnIuZW5hYmxlZCApIHtcblxuXHRcdFx0XHR2ci5zdWJtaXRGcmFtZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIF9nbC5maW5pc2goKTtcblxuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcblxuXHRcdH07XG5cblx0XHQvKlxuXHRcdC8vIFRPRE8gRHVwbGljYXRlZCBjb2RlIChGcnVzdHVtKVxuXG5cdFx0dmFyIF9zcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0XHRmdW5jdGlvbiBpc09iamVjdFZpZXdhYmxlKCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXG5cdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICkuXG5cdFx0XHRhcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRyZXR1cm4gaXNTcGhlcmVWaWV3YWJsZSggX3NwaGVyZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTcHJpdGVWaWV3YWJsZSggc3ByaXRlICkge1xuXG5cdFx0XHRfc3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdF9zcGhlcmUucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2O1xuXHRcdFx0X3NwaGVyZS5hcHBseU1hdHJpeDQoIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRyZXR1cm4gaXNTcGhlcmVWaWV3YWJsZSggX3NwaGVyZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTcGhlcmVWaWV3YWJsZSggc3BoZXJlICkge1xuXG5cdFx0XHRpZiAoICEgX2ZydXN0dW0uaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBudW1QbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xuXG5cdFx0XHRpZiAoIG51bVBsYW5lcyA9PT0gMCApIHJldHVybiB0cnVlO1xuXG5cdFx0XHR2YXIgcGxhbmVzID0gX3RoaXMuY2xpcHBpbmdQbGFuZXMsXG5cblx0XHRcdFx0Y2VudGVyID0gc3BoZXJlLmNlbnRlcixcblx0XHRcdFx0bmVnUmFkID0gLSBzcGhlcmUucmFkaXVzLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0ZG8ge1xuXG5cdFx0XHRcdC8vIG91dCB3aGVuIGRlZXBlciB0aGFuIHJhZGl1cyBpbiB0aGUgbmVnYXRpdmUgaGFsZnNwYWNlXG5cdFx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKSA8IG5lZ1JhZCApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fSB3aGlsZSAoICsrIGkgIT09IG51bVBsYW5lcyApO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblx0XHQqL1xuXG5cdFx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEsIHNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0dmFyIHZpc2libGUgPSBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKTtcblxuXHRcdFx0aWYgKCB2aXNpYmxlICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LmlzTGlnaHQgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUucHVzaExpZ2h0KCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoU2hhZG93KCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNTcHJpdGUgKSB7XG5cblx0XHRcdFx0XHRpZiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c1Nwcml0ZSggb2JqZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoU3ByaXRlKCBvYmplY3QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHNvcnRPYmplY3RzICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApXG5cdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIG51bGwsIG9iamVjdC5tYXRlcmlhbCwgX3ZlY3RvcjMueiwgbnVsbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3Quc2tlbGV0b24udXBkYXRlKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggc29ydE9iamVjdHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIF92ZWN0b3IzLnosIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC52aXNpYmxlICkge1xuXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgc29ydE9iamVjdHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xuXG5cdFx0XHRcdHZhciBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gdW5kZWZpbmVkID8gcmVuZGVySXRlbS5tYXRlcmlhbCA6IG92ZXJyaWRlTWF0ZXJpYWw7XG5cdFx0XHRcdHZhciBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XG5cblx0XHRcdFx0aWYgKCBjYW1lcmEuaXNBcnJheUNhbWVyYSApIHtcblxuXHRcdFx0XHRcdF9jdXJyZW50QXJyYXlDYW1lcmEgPSBjYW1lcmE7XG5cblx0XHRcdFx0XHR2YXIgY2FtZXJhcyA9IGNhbWVyYS5jYW1lcmFzO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGNhbWVyYXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjYW1lcmEyID0gY2FtZXJhc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhMi5sYXllcnMgKSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgYm91bmRzID0gY2FtZXJhMi5ib3VuZHM7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHggPSBib3VuZHMueCAqIF93aWR0aDtcblx0XHRcdFx0XHRcdFx0dmFyIHkgPSBib3VuZHMueSAqIF9oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdHZhciB3aWR0aCA9IGJvdW5kcy56ICogX3dpZHRoO1xuXHRcdFx0XHRcdFx0XHR2YXIgaGVpZ2h0ID0gYm91bmRzLncgKiBfaGVpZ2h0O1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0LnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XG5cblx0XHRcdFx0XHRcdFx0cmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEyLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X2N1cnJlbnRBcnJheUNhbWVyYSA9IG51bGw7XG5cblx0XHRcdFx0XHRyZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKSB7XG5cblx0XHRcdG9iamVjdC5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoIHNjZW5lLCBfY3VycmVudEFycmF5Q2FtZXJhIHx8IGNhbWVyYSApO1xuXG5cdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0b2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblxuXHRcdFx0aWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdFx0dmFyIGZyb250RmFjZUNXID0gKCBvYmplY3QuaXNNZXNoICYmIG9iamVjdC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMCApO1xuXG5cdFx0XHRcdHN0YXRlLnNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKTtcblxuXHRcdFx0XHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgc2NlbmUuZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cblx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblxuXHRcdFx0XHRyZW5kZXJPYmplY3RJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgc2NlbmUuZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3Qub25BZnRlclJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoIHNjZW5lLCBfY3VycmVudEFycmF5Q2FtZXJhIHx8IGNhbWVyYSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgZm9nLCBvYmplY3QgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0dmFyIGxpZ2h0cyA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5saWdodHM7XG5cdFx0XHR2YXIgc2hhZG93c0FycmF5ID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLnNoYWRvd3NBcnJheTtcblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyhcblx0XHRcdFx0bWF0ZXJpYWwsIGxpZ2h0cy5zdGF0ZSwgc2hhZG93c0FycmF5LCBmb2csIF9jbGlwcGluZy5udW1QbGFuZXMsIF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb24sIG9iamVjdCApO1xuXG5cdFx0XHR2YXIgY29kZSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ29kZSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblxuXHRcdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbTtcblx0XHRcdHZhciBwcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gbmV3IG1hdGVyaWFsXG5cdFx0XHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggcHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xuXG5cdFx0XHRcdC8vIGNoYW5nZWQgZ2xzbCBvciBwYXJhbWV0ZXJzXG5cdFx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoICE9PSBsaWdodHMuc3RhdGUuaGFzaCApIHtcblxuXHRcdFx0XHRwcm9wZXJ0aWVzLnVwZGF0ZSggbWF0ZXJpYWwsICdsaWdodHNIYXNoJywgbGlnaHRzLnN0YXRlLmhhc2ggKTtcblx0XHRcdFx0cHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gc2FtZSBnbHNsIGFuZCB1bmlmb3JtIGxpc3Rcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG9ubHkgcmVidWlsZCB1bmlmb3JtIGxpc3Rcblx0XHRcdFx0cHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcHJvZ3JhbUNoYW5nZSApIHtcblxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2hhZGVyID0gU2hhZGVyTGliWyBwYXJhbWV0ZXJzLnNoYWRlcklEIF07XG5cblx0XHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKSxcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBtYXRlcmlhbC51bmlmb3Jtcyxcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxuXHRcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0ZXJpYWwub25CZWZvcmVDb21waWxlKCBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyICk7XG5cblx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1DYWNoZS5hY3F1aXJlUHJvZ3JhbSggbWF0ZXJpYWwsIG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIsIHBhcmFtZXRlcnMsIGNvZGUgKTtcblxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRcdG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBpIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyLnVuaWZvcm1zO1xuXG5cdFx0XHRpZiAoICEgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJlxuXHRcdFx0XHQhIG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgfHxcblx0XHRcdFx0bWF0ZXJpYWwuY2xpcHBpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzID0gX2NsaXBwaW5nLm51bVBsYW5lcztcblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiA9IF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb247XG5cdFx0XHRcdHVuaWZvcm1zLmNsaXBwaW5nUGxhbmVzID0gX2NsaXBwaW5nLnVuaWZvcm07XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyA9IGZvZztcblxuXHRcdFx0Ly8gc3RvcmUgdGhlIGxpZ2h0IHNldHVwIGl0IHdhcyBjcmVhdGVkIGZvclxuXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCA9IGxpZ2h0cy5zdGF0ZS5oYXNoO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0cyApIHtcblxuXHRcdFx0XHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcblxuXHRcdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5hbWJpZW50O1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbDtcblx0XHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90O1xuXHRcdFx0XHR1bmlmb3Jtcy5yZWN0QXJlYUxpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5yZWN0QXJlYTtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnQ7XG5cdFx0XHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuaGVtaTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg7XG5cdFx0XHRcdHVuaWZvcm1zLnNwb3RTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvd01hcDtcblx0XHRcdFx0dW5pZm9ybXMuc3BvdFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90U2hhZG93TWF0cml4O1xuXHRcdFx0XHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludFNoYWRvd01hcDtcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3dNYXRyaXg7XG5cdFx0XHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBhZGQgYXJlYSBsaWdodHMgc2hhZG93IGluZm8gdG8gdW5pZm9ybXNcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcHJvZ1VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcblx0XHRcdFx0dW5pZm9ybXNMaXN0ID1cblx0XHRcdFx0XHRXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSggcHJvZ1VuaWZvcm1zLnNlcSwgdW5pZm9ybXMgKTtcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IHVuaWZvcm1zTGlzdDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xuXG5cdFx0XHRfdXNlZFRleHR1cmVVbml0cyA9IDA7XG5cblx0XHRcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblx0XHRcdHZhciBsaWdodHMgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUubGlnaHRzO1xuXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuXHRcdFx0XHRcdHZhciB1c2VDYWNoZSA9XG5cdFx0XHRcdFx0XHRjYW1lcmEgPT09IF9jdXJyZW50Q2FtZXJhICYmXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5pZCA9PT0gX2N1cnJlbnRNYXRlcmlhbElkO1xuXG5cdFx0XHRcdFx0Ly8gd2UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aCBzb21lIENsaXBwaW5nR3JvdXBcblx0XHRcdFx0XHQvLyBvYmplY3QgaW5zdGVhZCBvZiB0aGUgbWF0ZXJpYWwsIG9uY2UgaXQgYmVjb21lcyBmZWFzaWJsZVxuXHRcdFx0XHRcdC8vICgjODQ2NSwgIzgzNzkpXG5cdFx0XHRcdFx0X2NsaXBwaW5nLnNldFN0YXRlKFxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMsIG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb24sIG1hdGVyaWFsLmNsaXBTaGFkb3dzLFxuXHRcdFx0XHRcdFx0Y2FtZXJhLCBtYXRlcmlhbFByb3BlcnRpZXMsIHVzZUNhY2hlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5mb2cgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyAhPT0gZm9nICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmxpZ2h0cyAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gbGlnaHRzLnN0YXRlLmhhc2ggKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQoIG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gX2NsaXBwaW5nLm51bVBsYW5lcyB8fFxuXHRcdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1JbnRlcnNlY3Rpb24gIT09IF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb24gKSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHRpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApO1xuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xuXHRcdFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuXHRcdFx0dmFyIHJlZnJlc2hMaWdodHMgPSBmYWxzZTtcblxuXHRcdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcblx0XHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcblx0XHRcdFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIudW5pZm9ybXM7XG5cblx0XHRcdGlmICggc3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICkgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuXHRcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XG5cblx0XHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XG5cblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XG5cblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAncHJvamVjdGlvbk1hdHJpeCcsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLFxuXHRcdFx0XHRcdFx0Mi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdm9pZCB1bm5lZWRlZCB1bmlmb3JtIHVwZGF0ZXMgcGVyIEFycmF5Q2FtZXJhJ3Mgc3ViLWNhbWVyYVxuXG5cdFx0XHRcdGlmICggX2N1cnJlbnRDYW1lcmEgIT09ICggX2N1cnJlbnRBcnJheUNhbWVyYSB8fCBjYW1lcmEgKSApIHtcblxuXHRcdFx0XHRcdF9jdXJyZW50Q2FtZXJhID0gKCBfY3VycmVudEFycmF5Q2FtZXJhIHx8IGNhbWVyYSApO1xuXG5cdFx0XHRcdFx0Ly8gbGlnaHRpbmcgdW5pZm9ybXMgZGVwZW5kIG9uIHRoZSBjYW1lcmEgc28gZW5mb3JjZSBhbiB1cGRhdGVcblx0XHRcdFx0XHQvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxuXHRcdFx0XHRcdC8vIHRoZSBuZXh0IG1hdGVyaWFsIHRoYXQgZG9lcyBnZXRzIGFjdGl2YXRlZDpcblxuXHRcdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHRcdC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxuXHRcdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1x0XHQvLyByZW1haW5zIHNldCB1bnRpbCB1cGRhdGUgZG9uZVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cdFx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8XG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5lbnZNYXAgKSB7XG5cblx0XHRcdFx0XHR2YXIgdUNhbVBvcyA9IHBfdW5pZm9ybXMubWFwLmNhbWVyYVBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0aWYgKCB1Q2FtUG9zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVDYW1Qb3Muc2V0VmFsdWUoIF9nbCxcblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8XG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHxcblx0XHRcdFx0XHRtYXRlcmlhbC5za2lubmluZyApIHtcblxuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3ZpZXdNYXRyaXgnLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxuXHRcdFx0Ly8gYXV0by1zZXR0aW5nIG9mIHRleHR1cmUgdW5pdCBmb3IgYm9uZSB0ZXh0dXJlIG11c3QgZ28gYmVmb3JlIG90aGVyIHRleHR1cmVzXG5cdFx0XHQvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeCcgKTtcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScgKTtcblxuXHRcdFx0XHR2YXIgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XG5cblx0XHRcdFx0aWYgKCBza2VsZXRvbiApIHtcblxuXHRcdFx0XHRcdHZhciBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xuXG5cdFx0XHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2VsZXRvbi5ib25lVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcblx0XHRcdFx0XHRcdFx0Ly8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuXHRcdFx0XHRcdFx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxuXHRcdFx0XHRcdFx0XHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcblx0XHRcdFx0XHRcdFx0Ly8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG5cdFx0XHRcdFx0XHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxuXG5cblx0XHRcdFx0XHRcdFx0dmFyIHNpemUgPSBNYXRoLnNxcnQoIGJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxuXHRcdFx0XHRcdFx0XHRzaXplID0gX01hdGguY2VpbFBvd2VyT2ZUd28oIHNpemUgKTtcblx0XHRcdFx0XHRcdFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKiBzaXplICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxuXHRcdFx0XHRcdFx0XHRib25lTWF0cmljZXMuc2V0KCBza2VsZXRvbi5ib25lTWF0cmljZXMgKTsgLy8gY29weSBjdXJyZW50IHZhbHVlc1xuXG5cdFx0XHRcdFx0XHRcdHZhciBib25lVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcblx0XHRcdFx0XHRcdFx0Ym9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdHNrZWxldG9uLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcztcblx0XHRcdFx0XHRcdFx0c2tlbGV0b24uYm9uZVRleHR1cmUgPSBib25lVGV4dHVyZTtcblx0XHRcdFx0XHRcdFx0c2tlbGV0b24uYm9uZVRleHR1cmVTaXplID0gc2l6ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdib25lVGV4dHVyZScsIHNrZWxldG9uLmJvbmVUZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdib25lVGV4dHVyZVNpemUnLCBza2VsZXRvbi5ib25lVGV4dHVyZVNpemUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgc2tlbGV0b24sICdib25lTWF0cmljZXMnICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLCBfdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlICk7XG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3RvbmVNYXBwaW5nV2hpdGVQb2ludCcsIF90aGlzLnRvbmVNYXBwaW5nV2hpdGVQb2ludCApO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubGlnaHRzICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbWF0ZXJpYWwgcmVxdWlyZXMgbGlnaHRpbmcgaW5mb1xuXG5cdFx0XHRcdFx0Ly8gbm90ZTogYWxsIGxpZ2h0aW5nIHVuaWZvcm1zIGFyZSBhbHdheXMgc2V0IGNvcnJlY3RseVxuXHRcdFx0XHRcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcblx0XHRcdFx0XHQvLyB2YWx1ZXNcblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcblx0XHRcdFx0XHQvLyB0aGUgR0wgc3RhdGUgd2hlbiByZXF1aXJlZFxuXG5cdFx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHJlZnJlc2hMaWdodHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcblxuXHRcdFx0XHRpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNUb29uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGh5c2ljYWwoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0RlcHRoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTm9ybWFsKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc0xpbmVEYXNoZWRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1BvaW50c01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUG9pbnRzKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtX3VuaWZvcm1zLmNvbG9yLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cdFx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdEFyZWFMaWdodCBUZXh0dXJlXG5cdFx0XHRcdC8vIFRPRE8gKG1yZG9vYik6IEZpbmQgYSBuaWNlciBpbXBsZW1lbnRhdGlvblxuXG5cdFx0XHRcdGlmICggbV91bmlmb3Jtcy5sdGNfMSAhPT0gdW5kZWZpbmVkICkgbV91bmlmb3Jtcy5sdGNfMS52YWx1ZSA9IFVuaWZvcm1zTGliLkxUQ18xO1xuXHRcdFx0XHRpZiAoIG1fdW5pZm9ybXMubHRjXzIgIT09IHVuZGVmaW5lZCApIG1fdW5pZm9ybXMubHRjXzIudmFsdWUgPSBVbmlmb3Jtc0xpYi5MVENfMjtcblxuXHRcdFx0XHRXZWJHTFVuaWZvcm1zLnVwbG9hZCggX2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCBfdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiBtYXRlcmlhbC51bmlmb3Jtc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQoIF9nbCwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCwgbV91bmlmb3JtcywgX3RoaXMgKTtcblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29tbW9uIG1hdHJpY2VzXG5cblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsVmlld01hdHJpeCcsIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ25vcm1hbE1hdHJpeCcsIG9iamVjdC5ub3JtYWxNYXRyaXggKTtcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsTWF0cml4Jywgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdFx0fVxuXG5cdFx0Ly8gVW5pZm9ybXMgKHJlZnJlc2ggdW5pZm9ybXMgb2JqZWN0cylcblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jb2xvciApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5lbWlzc2l2ZSApLm11bHRpcGx5U2NhbGFyKCBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcblxuXHRcdFx0XHQvLyBkb24ndCBmbGlwIEN1YmVUZXh0dXJlIGVudk1hcHMsIGZsaXAgZXZlcnl0aGluZyBlbHNlOlxuXHRcdFx0XHQvLyAgV2ViR0xSZW5kZXJUYXJnZXRDdWJlIHdpbGwgYmUgZmxpcHBlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS50ZXh0dXJlIHdpbGwgYmUgZmxpcHBlZCBiZWNhdXNlIGl0J3MgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxuXHRcdFx0XHQvLyB0aGlzIGNoZWNrIG11c3QgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSwgb3IgcmVtb3ZlZCBlbnRpcmVseSwgaWYgV2ViR0xSZW5kZXJUYXJnZXRDdWJlIHVzZXMgYSBDdWJlVGV4dHVyZSBpbiB0aGUgZnV0dXJlXG5cdFx0XHRcdHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoICEgKCBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLmlzQ3ViZVRleHR1cmUgKSApID8gMSA6IC0gMTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XG5cdFx0XHRcdHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hb01hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuXHRcdFx0Ly8gMS4gY29sb3IgbWFwXG5cdFx0XHQvLyAyLiBzcGVjdWxhciBtYXBcblx0XHRcdC8vIDMuIG5vcm1hbCBtYXBcblx0XHRcdC8vIDQuIGJ1bXAgbWFwXG5cdFx0XHQvLyA1LiBhbHBoYSBtYXBcblx0XHRcdC8vIDYuIGVtaXNzaXZlIG1hcFxuXG5cdFx0XHR2YXIgdXZTY2FsZU1hcDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcblxuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0aWYgKCB1dlNjYWxlTWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0XHR1dlNjYWxlTWFwID0gdXZTY2FsZU1hcC50ZXh0dXJlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHV2U2NhbGVNYXAubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcblx0XHRcdFx0XHR2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XG5cdFx0XHRcdFx0dmFyIHJvdGF0aW9uID0gdXZTY2FsZU1hcC5yb3RhdGlvbjtcblx0XHRcdFx0XHR2YXIgY2VudGVyID0gdXZTY2FsZU1hcC5jZW50ZXI7XG5cblx0XHRcdFx0XHR1dlNjYWxlTWFwLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnksIHJvdGF0aW9uLCBjZW50ZXIueCwgY2VudGVyLnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weSggdXZTY2FsZU1hcC5tYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2goIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcblx0XHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcblx0XHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQb2ludHMoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXHRcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cdFx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZSAqIF9waXhlbFJhdGlvO1xuXHRcdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfaGVpZ2h0ICogMC41O1xuXG5cdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gbWF0ZXJpYWwubWFwLm9mZnNldDtcblx0XHRcdFx0XHR2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcblx0XHRcdFx0XHR2YXIgcm90YXRpb24gPSBtYXRlcmlhbC5tYXAucm90YXRpb247XG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IG1hdGVyaWFsLm1hcC5jZW50ZXI7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5tYXAubWF0cml4LnNldFV2VHJhbnNmb3JtKCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSwgcm90YXRpb24sIGNlbnRlci54LCBjZW50ZXIueSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5tYXAubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyggdW5pZm9ybXMsIGZvZyApIHtcblxuXHRcdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XG5cblx0XHRcdGlmICggZm9nLmlzRm9nICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcblx0XHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcblxuXHRcdFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xuXHRcdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgoIG1hdGVyaWFsLnNoaW5pbmVzcywgMWUtNCApOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Rvb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmdyYWRpZW50TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmdyYWRpZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZ3JhZGllbnRNYXA7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRcdHVuaWZvcm1zLnJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzcztcblx0XHRcdHVuaWZvcm1zLm1ldGFsbmVzcy52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzcztcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMucm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLm1ldGFsbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cblx0XHRcdFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXG5cdFx0XHRcdHVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcEludGVuc2l0eTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGh5c2ljYWwoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdFx0dW5pZm9ybXMuY2xlYXJDb2F0LnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0O1xuXHRcdFx0dW5pZm9ybXMuY2xlYXJDb2F0Um91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzO1xuXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEZXB0aCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHVuaWZvcm1zLnJlZmVyZW5jZVBvc2l0aW9uLnZhbHVlLmNvcHkoIG1hdGVyaWFsLnJlZmVyZW5jZVBvc2l0aW9uICk7XG5cdFx0XHR1bmlmb3Jtcy5uZWFyRGlzdGFuY2UudmFsdWUgPSBtYXRlcmlhbC5uZWFyRGlzdGFuY2U7XG5cdFx0XHR1bmlmb3Jtcy5mYXJEaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLmZhckRpc3RhbmNlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTm9ybWFsKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cblx0XHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggdW5pZm9ybXMsIHZhbHVlICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHRcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0XHR9XG5cblx0XHQvLyBUZXh0dXJlc1xuXG5cdFx0ZnVuY3Rpb24gYWxsb2NUZXh0dXJlVW5pdCgpIHtcblxuXHRcdFx0dmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XG5cblx0XHRcdGlmICggdGV4dHVyZVVuaXQgPj0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcblxuXHRcdH1cblxuXHRcdHRoaXMuYWxsb2NUZXh0dXJlVW5pdCA9IGFsbG9jVGV4dHVyZVVuaXQ7XG5cblx0XHQvLyB0aGlzLnNldFRleHR1cmUyRCA9IHNldFRleHR1cmUyRDtcblx0XHR0aGlzLnNldFRleHR1cmUyRCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgd2FybmVkID0gZmFsc2U7XG5cblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBwZWVsIHRleHR1cmUudGV4dHVyZVxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIHdhcm5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZTJEOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlwiICk7XG5cdFx0XHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGV4dHVyZSA9IHRleHR1cmUudGV4dHVyZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCkgKTtcblxuXHRcdHRoaXMuc2V0VGV4dHVyZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgd2FybmVkID0gZmFsc2U7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBzZXRUZXh0dXJlKCB0ZXh0dXJlLCBzbG90ICkge1xuXG5cdFx0XHRcdGlmICggISB3YXJuZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldFRleHR1cmUgaXMgZGVwcmVjYXRlZCwgdXNlIHNldFRleHR1cmUyRCBpbnN0ZWFkLlwiICk7XG5cdFx0XHRcdFx0d2FybmVkID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCkgKTtcblxuXHRcdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHBlZWwgdGV4dHVyZS50ZXh0dXJlXG5cdFx0XHRcdGlmICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIHdhcm5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZUN1YmU6IGRvbid0IHVzZSBjdWJlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiApO1xuXHRcdFx0XHRcdFx0d2FybmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGN1cnJlbnRseSByZWx5aW5nIG9uIHRoZSBmYWN0IHRoYXQgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnRleHR1cmUgaXMgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxuXHRcdFx0XHQvLyBUT0RPOiB1bmlmeSB0aGVzZSBjb2RlIHBhdGhzXG5cdFx0XHRcdGlmICggKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNDdWJlVGV4dHVyZSApIHx8XG5cdFx0XHRcdFx0KCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcblxuXHRcdFx0XHRcdC8vIENvbXByZXNzZWRUZXh0dXJlIGNhbiBoYXZlIEFycmF5IGluIGltYWdlIDovXG5cblx0XHRcdFx0XHQvLyB0aGlzIGZ1bmN0aW9uIGFsb25lIHNob3VsZCB0YWtlIGNhcmUgb2YgY3ViZSB0ZXh0dXJlc1xuXHRcdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGFzc3VtZWQ6IHRleHR1cmUgcHJvcGVydHkgb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlXG5cblx0XHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZUR5bmFtaWMoIHRleHR1cmUsIHNsb3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9KCkgKTtcblxuXHRcdHRoaXMuZ2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQ7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICYmIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZyYW1lYnVmZmVyID0gbnVsbDtcblx0XHRcdHZhciBpc0N1YmUgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0dmFyIF9fd2ViZ2xGcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cblx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XG5cdFx0XHRcdFx0aXNDdWJlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weSggcmVuZGVyVGFyZ2V0LnZpZXdwb3J0ICk7XG5cdFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCByZW5kZXJUYXJnZXQuc2Npc3NvciApO1xuXHRcdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gcmVuZGVyVGFyZ2V0LnNjaXNzb3JUZXN0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICk7XG5cdFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xuXHRcdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gX3NjaXNzb3JUZXN0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggX2N1cnJlbnRGcmFtZWJ1ZmZlciAhPT0gZnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXHRcdFx0XHRfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcblx0XHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3NvciApO1xuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9jdXJyZW50U2Npc3NvclRlc3QgKTtcblxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCByZW5kZXJUYXJnZXQuYWN0aXZlTWlwTWFwTGV2ZWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XG5cblx0XHRcdGlmICggISAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0XHR2YXIgcmVzdG9yZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0XHRyZXN0b3JlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cdFx0XHRcdFx0dmFyIHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcblx0XHRcdFx0XHR2YXIgdGV4dHVyZVR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIHRleHR1cmVGb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGV4dHVyZVR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUgJiYgdXRpbHMuY29udmVydCggdGV4dHVyZVR5cGUgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSApICYmIC8vIElFMTEsIEVkZ2UgYW5kIENocm9tZSBNYWMgPCA1MiAoIzk1MTMpXG5cdFx0XHRcdFx0XHQhICggdGV4dHVyZVR5cGUgPT09IEZsb2F0VHlwZSAmJiAoIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICkgfHwgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnICkgKSApICYmIC8vIENocm9tZSBNYWMgPj0gNTIgYW5kIEZpcmVmb3hcblx0XHRcdFx0XHRcdCEgKCB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50IGVuc3VyZXMgdmFsaWQgcmVhZCByZXF1ZXN0cyAobm8gb3V0LW9mLWJvdW5kcyBwaXhlbHMsIHNlZSAjODYwNClcblxuXHRcdFx0XHRcdFx0aWYgKCAoIHggPj0gMCAmJiB4IDw9ICggcmVuZGVyVGFyZ2V0LndpZHRoIC0gd2lkdGggKSApICYmICggeSA+PSAwICYmIHkgPD0gKCByZW5kZXJUYXJnZXQuaGVpZ2h0IC0gaGVpZ2h0ICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRfZ2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlVHlwZSApLCBidWZmZXIgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBmaW5hbGx5IHtcblxuXHRcdFx0XHRcdGlmICggcmVzdG9yZSApIHtcblxuXHRcdFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmUgPSBmdW5jdGlvbiAoIHBvc2l0aW9uLCB0ZXh0dXJlLCBsZXZlbCApIHtcblxuXHRcdFx0dmFyIHdpZHRoID0gdGV4dHVyZS5pbWFnZS53aWR0aDtcblx0XHRcdHZhciBoZWlnaHQgPSB0ZXh0dXJlLmltYWdlLmhlaWdodDtcblx0XHRcdHZhciBpbnRlcm5hbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0ICk7XG5cblx0XHRcdHRoaXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCAwICk7XG5cblx0XHRcdF9nbC5jb3B5VGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVsIHx8IDAsIGludGVybmFsRm9ybWF0LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB3aWR0aCwgaGVpZ2h0LCAwICk7XG5cblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gRm9nRXhwMiggY29sb3IsIGRlbnNpdHkgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSAnJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XG5cdFx0dGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xuXG5cdH1cblxuXHRGb2dFeHAyLnByb3RvdHlwZS5pc0ZvZ0V4cDIgPSB0cnVlO1xuXG5cdEZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBGb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcblxuXHR9O1xuXG5cdEZvZ0V4cDIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggLyogbWV0YSAqLyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnRm9nRXhwMicsXG5cdFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcblx0XHRcdGRlbnNpdHk6IHRoaXMuZGVuc2l0eVxuXHRcdH07XG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gRm9nKCBjb2xvciwgbmVhciwgZmFyICkge1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuXG5cdFx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xuXHRcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxuXHR9XG5cblx0Rm9nLnByb3RvdHlwZS5pc0ZvZyA9IHRydWU7XG5cblx0Rm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgRm9nKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cblx0fTtcblxuXHRGb2cucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggLyogbWV0YSAqLyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiAnRm9nJyxcblx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuXHRcdFx0bmVhcjogdGhpcy5uZWFyLFxuXHRcdFx0ZmFyOiB0aGlzLmZhclxuXHRcdH07XG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gU2NlbmUoKSB7XG5cblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXG5cdFx0dGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcblx0XHR0aGlzLmZvZyA9IG51bGw7XG5cdFx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXG5cblx0fVxuXG5cdFNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogU2NlbmUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRpZiAoIHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsICkgdGhpcy5iYWNrZ3JvdW5kID0gc291cmNlLmJhY2tncm91bmQuY2xvbmUoKTtcblx0XHRcdGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xuXHRcdFx0aWYgKCBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cblx0XHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHNvdXJjZS5hdXRvVXBkYXRlO1xuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZCAhPT0gbnVsbCApIGRhdGEub2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCBtZXRhICk7XG5cdFx0XHRpZiAoIHRoaXMuZm9nICE9PSBudWxsICkgZGF0YS5vYmplY3QuZm9nID0gdGhpcy5mb2cudG9KU09OKCk7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8aGV4Pixcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcblx0ICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKClcblx0ICogfVxuXHQgKi9cblxuXHRmdW5jdGlvbiBTcHJpdGVNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXHRcdHRoaXMubWFwID0gbnVsbDtcblxuXHRcdHRoaXMucm90YXRpb24gPSAwO1xuXG5cdFx0dGhpcy5mb2cgPSBmYWxzZTtcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcml0ZU1hdGVyaWFsO1xuXHRTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuaXNTcHJpdGVNYXRlcmlhbCA9IHRydWU7XG5cblx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0XHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gU3ByaXRlKCBtYXRlcmlhbCApIHtcblxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgU3ByaXRlTWF0ZXJpYWwoKTtcblxuXHRcdHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjIoIDAuNSwgMC41ICk7XG5cblx0fVxuXG5cdFNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IFNwcml0ZSxcblxuXHRcdGlzU3ByaXRlOiB0cnVlLFxuXG5cdFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgd29ybGRTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0d29ybGRQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblx0XHRcdFx0cmF5Y2FzdGVyLnJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCB3b3JsZFBvc2l0aW9uLCBpbnRlcnNlY3RQb2ludCApO1xuXG5cdFx0XHRcdHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHZhciBndWVzc1NpemVTcSA9IHdvcmxkU2NhbGUueCAqIHdvcmxkU2NhbGUueSAvIDQ7XG5cblx0XHRcdFx0aWYgKCB3b3JsZFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKCBpbnRlcnNlY3RQb2ludCApID4gZ3Vlc3NTaXplU3EgKSByZXR1cm47XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3RQb2ludC5jbG9uZSgpLFxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpICksXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0XHRpZiAoIHNvdXJjZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHRoaXMuY2VudGVyLmNvcHkoIHNvdXJjZS5jZW50ZXIgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIExPRCgpIHtcblxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMT0QnO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdGxldmVsczoge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogW11cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fVxuXG5cdExPRC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IExPRCxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIGZhbHNlICk7XG5cblx0XHRcdHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0XHR0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRhZGRMZXZlbDogZnVuY3Rpb24gKCBvYmplY3QsIGRpc3RhbmNlICkge1xuXG5cdFx0XHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cblx0XHRcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGV2ZWxzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIG9iamVjdDogb2JqZWN0IH0gKTtcblxuXHRcdFx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG5cdFx0fSxcblxuXHRcdGdldE9iamVjdEZvckRpc3RhbmNlOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG5cdFx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcblxuXHRcdH0sXG5cblx0XHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xuXG5cdFx0XHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHRcdH07XG5cblx0XHR9KCkgKSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xuXG5cdFx0XHRcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuXHRcdFx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XG5cblx0XHRcdFx0XHRsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA+PSBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0XHRkYXRhLm9iamVjdC5sZXZlbHMgPSBbXTtcblxuXHRcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcblxuXHRcdFx0XHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xuXHRcdFx0XHRcdG9iamVjdDogbGV2ZWwub2JqZWN0LnV1aWQsXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG5cdCAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuXHQgKi9cblxuXHRmdW5jdGlvbiBTa2VsZXRvbiggYm9uZXMsIGJvbmVJbnZlcnNlcyApIHtcblxuXHRcdC8vIGNvcHkgdGhlIGJvbmUgYXJyYXlcblxuXHRcdGJvbmVzID0gYm9uZXMgfHwgW107XG5cblx0XHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZXMubGVuZ3RoICogMTYgKTtcblxuXHRcdC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXG5cblx0XHRpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzLnNsaWNlKCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b24gYm9uZUludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xuXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgTWF0cml4NCgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFNrZWxldG9uLnByb3RvdHlwZSwge1xuXG5cdFx0Y2FsY3VsYXRlSW52ZXJzZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRcdGlmICggdGhpcy5ib25lc1sgaSBdICkge1xuXG5cdFx0XHRcdFx0aW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBpIF0ubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0cG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgYm9uZSwgaSwgaWw7XG5cblx0XHRcdC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBib25lICkge1xuXG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcblxuXHRcdFx0XHRcdFx0Ym9uZS5tYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRcdGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBvZmZzZXRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0dmFyIGlkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXHRcdFx0XHR2YXIgYm9uZUludmVyc2VzID0gdGhpcy5ib25lSW52ZXJzZXM7XG5cdFx0XHRcdHZhciBib25lTWF0cmljZXMgPSB0aGlzLmJvbmVNYXRyaWNlcztcblx0XHRcdFx0dmFyIGJvbmVUZXh0dXJlID0gdGhpcy5ib25lVGV4dHVyZTtcblxuXHRcdFx0XHQvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXG5cdFx0XHRcdFx0dmFyIG1hdHJpeCA9IGJvbmVzWyBpIF0gPyBib25lc1sgaSBdLm1hdHJpeFdvcmxkIDogaWRlbnRpdHlNYXRyaXg7XG5cblx0XHRcdFx0XHRvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCBib25lSW52ZXJzZXNbIGkgXSApO1xuXHRcdFx0XHRcdG9mZnNldE1hdHJpeC50b0FycmF5KCBib25lTWF0cmljZXMsIGkgKiAxNiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJvbmVUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fSApKCksXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFNrZWxldG9uKCB0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcyApO1xuXG5cdFx0fSxcblxuXHRcdGdldEJvbmVCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBib25lLm5hbWUgPT09IG5hbWUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYm9uZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuXHQgKi9cblxuXHRmdW5jdGlvbiBCb25lKCkge1xuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0JvbmUnO1xuXG5cdH1cblxuXHRCb25lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQm9uZSxcblxuXHRcdGlzQm9uZTogdHJ1ZVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRNZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcblxuXHRcdHRoaXMuYmluZE1vZGUgPSAnYXR0YWNoZWQnO1xuXHRcdHRoaXMuYmluZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHR2YXIgYm9uZXMgPSB0aGlzLmluaXRCb25lcygpO1xuXHRcdHZhciBza2VsZXRvbiA9IG5ldyBTa2VsZXRvbiggYm9uZXMgKTtcblxuXHRcdHRoaXMuYmluZCggc2tlbGV0b24sIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHR9XG5cblx0U2tpbm5lZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IFNraW5uZWRNZXNoLFxuXG5cdFx0aXNTa2lubmVkTWVzaDogdHJ1ZSxcblxuXHRcdGluaXRCb25lczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgYm9uZXMgPSBbXSwgYm9uZSwgZ2JvbmU7XG5cdFx0XHR2YXIgaSwgaWw7XG5cblx0XHRcdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmJvbmVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gZmlyc3QsIGNyZWF0ZSBhcnJheSBvZiAnQm9uZScgb2JqZWN0cyBmcm9tIGdlb21ldHJ5IGRhdGFcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBpIF07XG5cblx0XHRcdFx0XHQvLyBjcmVhdGUgbmV3ICdCb25lJyBvYmplY3RcblxuXHRcdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXHRcdFx0XHRcdGJvbmVzLnB1c2goIGJvbmUgKTtcblxuXHRcdFx0XHRcdC8vIGFwcGx5IHZhbHVlc1xuXG5cdFx0XHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcblx0XHRcdFx0XHRib25lLnBvc2l0aW9uLmZyb21BcnJheSggZ2JvbmUucG9zICk7XG5cdFx0XHRcdFx0Ym9uZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggZ2JvbmUucm90cSApO1xuXHRcdFx0XHRcdGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlY29uZCwgY3JlYXRlIGJvbmUgaGllcmFyY2h5XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCAoIGdib25lLnBhcmVudCAhPT0gLSAxICkgJiYgKCBnYm9uZS5wYXJlbnQgIT09IG51bGwgKSAmJiAoIGJvbmVzWyBnYm9uZS5wYXJlbnQgXSAhPT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgYm9uZXMgaW4gdGhlIGhpZXJhcmNoeVxuXG5cdFx0XHRcdFx0XHRib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lc1sgaSBdICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyB0b3Btb3N0IGJvbmUsIGltbWVkaWF0ZSBjaGlsZCBvZiB0aGUgc2tpbm5lZCBtZXNoXG5cblx0XHRcdFx0XHRcdHRoaXMuYWRkKCBib25lc1sgaSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG5vdyB0aGUgYm9uZXMgYXJlIHBhcnQgb2YgdGhlIHNjZW5lIGdyYXBoIGFuZCBjaGlsZHJlbiBvZiB0aGUgc2tpbm5lZCBtZXNoLlxuXHRcdFx0Ly8gbGV0J3MgdXBkYXRlIHRoZSBjb3JyZXNwb25kaW5nIG1hdHJpY2VzXG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0cmV0dXJuIGJvbmVzO1xuXG5cdFx0fSxcblxuXHRcdGJpbmQ6IGZ1bmN0aW9uICggc2tlbGV0b24sIGJpbmRNYXRyaXggKSB7XG5cblx0XHRcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuXHRcdFx0aWYgKCBiaW5kTWF0cml4ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuXHRcdFx0XHRiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuXHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCBiaW5kTWF0cml4ICk7XG5cblx0XHR9LFxuXG5cdFx0cG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcblxuXHRcdH0sXG5cblx0XHRub3JtYWxpemVTa2luV2VpZ2h0czogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgc2NhbGUsIGk7XG5cblx0XHRcdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcblxuXHRcdFx0XHRcdHNjYWxlID0gMS4wIC8gc3cubWFuaGF0dGFuTGVuZ3RoKCk7XG5cblx0XHRcdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuXHRcdFx0XHRcdFx0c3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzdy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdHZhciB2ZWMgPSBuZXcgVmVjdG9yNCgpO1xuXG5cdFx0XHRcdHZhciBza2luV2VpZ2h0ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQ7XG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBza2luV2VpZ2h0LmNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmVjLnggPSBza2luV2VpZ2h0LmdldFgoIGkgKTtcblx0XHRcdFx0XHR2ZWMueSA9IHNraW5XZWlnaHQuZ2V0WSggaSApO1xuXHRcdFx0XHRcdHZlYy56ID0gc2tpbldlaWdodC5nZXRaKCBpICk7XG5cdFx0XHRcdFx0dmVjLncgPSBza2luV2VpZ2h0LmdldFcoIGkgKTtcblxuXHRcdFx0XHRcdHNjYWxlID0gMS4wIC8gdmVjLm1hbmhhdHRhbkxlbmd0aCgpO1xuXG5cdFx0XHRcdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdFx0XHRcdHZlYy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZlYy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjLngsIHZlYy55LCB2ZWMueiwgdmVjLncgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuXHRcdFx0TWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHRcdFx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSAnYXR0YWNoZWQnICkge1xuXG5cdFx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmJpbmRNb2RlID09PSAnZGV0YWNoZWQnICkge1xuXG5cdFx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tpbm5lZE1lc2g6IFVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqICBjb2xvcjogPGhleD4sXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxuXHQgKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuXHQgKiAgbGluZWpvaW46IFwicm91bmRcIlxuXHQgKiB9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIExpbmVCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cdFx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcblx0XHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcblxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUJhc2ljTWF0ZXJpYWw7XG5cblx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0XHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG5cdFx0dGhpcy5saW5lY2FwID0gc291cmNlLmxpbmVjYXA7XG5cdFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcblxuXHRcdGlmICggbW9kZSA9PT0gMSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZTogcGFyYW1ldGVyIFRIUkVFLkxpbmVQaWVjZXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gQ3JlYXRlZCBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR9XG5cblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZSc7XG5cblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuXHR9XG5cblx0TGluZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IExpbmUsXG5cblx0XHRpc0xpbmU6IHRydWUsXG5cblx0XHRjb21wdXRlTGluZURpc3RhbmNlczogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBzdGFydCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgZW5kID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0Ly8gd2UgYXNzdW1lIG5vbi1pbmRleGVkIGdlb21ldHJ5XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBbIDAgXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpIC0gMSApO1xuXHRcdFx0XHRcdFx0XHRlbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKTtcblxuXHRcdFx0XHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpIF0gPSBsaW5lRGlzdGFuY2VzWyBpIC0gMSBdO1xuXHRcdFx0XHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpIF0gKz0gc3RhcnQuZGlzdGFuY2VUbyggZW5kICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGxpbmVEaXN0YW5jZXMsIDEgKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZS5jb21wdXRlTGluZURpc3RhbmNlcygpOiBDb21wdXRhdGlvbiBvbmx5IHBvc3NpYmxlIHdpdGggbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnkuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdFx0XHR2YXIgbGluZURpc3RhbmNlcyA9IGdlb21ldHJ5LmxpbmVEaXN0YW5jZXM7XG5cblx0XHRcdFx0XHRsaW5lRGlzdGFuY2VzWyAwIF0gPSAwO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bGluZURpc3RhbmNlc1sgaSBdID0gbGluZURpc3RhbmNlc1sgaSAtIDEgXTtcblx0XHRcdFx0XHRcdGxpbmVEaXN0YW5jZXNbIGkgXSArPSB2ZXJ0aWNlc1sgaSAtIDEgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpICksXG5cblx0XHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcblx0XHRcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xuXHRcdFx0XHR2YXIgcHJlY2lzaW9uU3EgPSBwcmVjaXNpb24gKiBwcmVjaXNpb247XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdFx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcblx0XHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuXHRcdFx0XHR2YXIgdlN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIHZFbmQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR2YXIgaW50ZXJTZWdtZW50ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIGludGVyUmF5ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIHN0ZXAgPSAoIHRoaXMgJiYgdGhpcy5pc0xpbmVTZWdtZW50cyApID8gMiA6IDE7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgYiA9IGluZGljZXNbIGkgKyAxIF07XG5cblx0XHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXHRcdFx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuXHRcdFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XG5cblx0XHRcdFx0XHRcdFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSApO1xuXHRcdFx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSArIDMgKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG5cdFx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuXHRcdFx0XHRcdFx0XHRcdGluZGV4OiBpLFxuXHRcdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdFx0XHR2YXIgbmJWZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpICs9IHN0ZXAgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cblx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9KCkgKSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0TGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuXG5cdH1cblxuXHRMaW5lU2VnbWVudHMucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGluZS5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IExpbmVTZWdtZW50cyxcblxuXHRcdGlzTGluZVNlZ21lbnRzOiB0cnVlLFxuXG5cdFx0Y29tcHV0ZUxpbmVEaXN0YW5jZXM6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgc3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIGVuZCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBjb21wdXRlTGluZURpc3RhbmNlcygpIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdC8vIHdlIGFzc3VtZSBub24taW5kZXhlZCBnZW9tZXRyeVxuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdHZhciBsaW5lRGlzdGFuY2VzID0gW107XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICk7XG5cdFx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpIF0gPSAoIGkgPT09IDAgKSA/IDAgOiBsaW5lRGlzdGFuY2VzWyBpIC0gMSBdO1xuXHRcdFx0XHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpICsgMSBdID0gbGluZURpc3RhbmNlc1sgaSBdICsgc3RhcnQuZGlzdGFuY2VUbyggZW5kICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbGluZURpc3RhbmNlJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGxpbmVEaXN0YW5jZXMsIDEgKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZVNlZ21lbnRzLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCk6IENvbXB1dGF0aW9uIG9ubHkgcG9zc2libGUgd2l0aCBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeS4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXHRcdFx0XHRcdHZhciBsaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlcztcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0c3RhcnQuY29weSggdmVydGljZXNbIGkgXSApO1xuXHRcdFx0XHRcdFx0ZW5kLmNvcHkoIHZlcnRpY2VzWyBpICsgMSBdICk7XG5cblx0XHRcdFx0XHRcdGxpbmVEaXN0YW5jZXNbIGkgXSA9ICggaSA9PT0gMCApID8gMCA6IGxpbmVEaXN0YW5jZXNbIGkgLSAxIF07XG5cdFx0XHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpICsgMSBdID0gbGluZURpc3RhbmNlc1sgaSBdICsgc3RhcnQuZGlzdGFuY2VUbyggZW5kICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpIClcblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbWdyZXRlciAvIGh0dHA6Ly9naXRodWIuY29tL21ncmV0ZXJcblx0ICovXG5cblx0ZnVuY3Rpb24gTGluZUxvb3AoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRcdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGluZUxvb3AnO1xuXG5cdH1cblxuXHRMaW5lTG9vcC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaW5lLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogTGluZUxvb3AsXG5cblx0XHRpc0xpbmVMb29wOiB0cnVlLFxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8aGV4Pixcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBzaXplOiA8ZmxvYXQ+LFxuXHQgKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD5cblx0ICogfVxuXHQgKi9cblxuXHRmdW5jdGlvbiBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5zaXplID0gMTtcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XG5cblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0UG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50c01hdGVyaWFsO1xuXG5cdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5pc1BvaW50c01hdGVyaWFsID0gdHJ1ZTtcblxuXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5zaXplID0gc291cmNlLnNpemU7XG5cdFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRzJztcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG5cdH1cblxuXHRQb2ludHMucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBQb2ludHMsXG5cblx0XHRpc1BvaW50czogdHJ1ZSxcblxuXHRcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHR2YXIgcmF5ID0gbmV3IFJheSgpO1xuXHRcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gdGhpcztcblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblx0XHRcdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcblxuXHRcdFx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHNwaGVyZS5yYWRpdXMgKz0gdGhyZXNob2xkO1xuXG5cdFx0XHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cblx0XHRcdFx0dmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xuXHRcdFx0XHR2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0ZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XG5cblx0XHRcdFx0XHR2YXIgcmF5UG9pbnREaXN0YW5jZVNxID0gcmF5LmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcblx0XHRcdFx0XHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHRkaXN0YW5jZVRvUmF5OiBNYXRoLnNxcnQoIHJheVBvaW50RGlzdGFuY2VTcSApLFxuXHRcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXG5cdFx0XHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBpICogMyApO1xuXG5cdFx0XHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH0oKSApLFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gR3JvdXAoKSB7XG5cblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xuXG5cdH1cblxuXHRHcm91cC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IEdyb3VwLFxuXG5cdFx0aXNHcm91cDogdHJ1ZVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gVmlkZW9UZXh0dXJlKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0VGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG5cdH1cblxuXHRWaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IFZpZGVvVGV4dHVyZSxcblxuXHRcdGlzVmlkZW9UZXh0dXJlOiB0cnVlLFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2aWRlbyA9IHRoaXMuaW1hZ2U7XG5cblx0XHRcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSApIHtcblxuXHRcdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gQ29tcHJlc3NlZFRleHR1cmUoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XG5cblx0XHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcblxuXHRcdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblx0XHR0aGlzLm1pcG1hcHMgPSBtaXBtYXBzO1xuXG5cdFx0Ly8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcblx0XHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxuXG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuXG5cdFx0Ly8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuXHRcdC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0fVxuXG5cdENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XG5cdENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbXByZXNzZWRUZXh0dXJlO1xuXG5cdENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIC8gQG1hdHRkZXNsXG5cdCAqIEBhdXRob3IgYXRpeCAvIGFydGh1cnNpbGJlci5kZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBEZXB0aFRleHR1cmUoIHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCApIHtcblxuXHRcdGZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogRGVwdGhGb3JtYXQ7XG5cblx0XHRpZiAoIGZvcm1hdCAhPT0gRGVwdGhGb3JtYXQgJiYgZm9ybWF0ICE9PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0JyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcblx0XHRpZiAoIHR5cGUgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG5cblx0XHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG5cblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHNcdD0gZmFsc2U7XG5cblx0fVxuXG5cdERlcHRoVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuXHREZXB0aFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVwdGhUZXh0dXJlO1xuXHREZXB0aFRleHR1cmUucHJvdG90eXBlLmlzRGVwdGhUZXh0dXJlID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICovXG5cblx0ZnVuY3Rpb24gV2lyZWZyYW1lR2VvbWV0cnkoIGdlb21ldHJ5ICkge1xuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1dpcmVmcmFtZUdlb21ldHJ5JztcblxuXHRcdC8vIGJ1ZmZlclxuXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHR2YXIgaSwgaiwgbCwgbywgb2w7XG5cdFx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgZWRnZXMgPSB7fSwgZSwgZWRnZTEsIGVkZ2UyO1xuXHRcdHZhciBrZXksIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblx0XHR2YXIgdmVydGV4O1xuXG5cdFx0Ly8gZGlmZmVyZW50IGxvZ2ljIGZvciBHZW9tZXRyeSBhbmQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0Ly8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWRnZXMgd2l0aG91dCBkdXBsaWNhdGVzXG5cblx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdGVkZ2UxID0gZmFjZVsga2V5c1sgaiBdIF07XG5cdFx0XHRcdFx0ZWRnZTIgPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcblx0XHRcdFx0XHRlZGdlWyAwIF0gPSBNYXRoLm1pbiggZWRnZTEsIGVkZ2UyICk7IC8vIHNvcnRpbmcgcHJldmVudHMgZHVwbGljYXRlc1xuXHRcdFx0XHRcdGVkZ2VbIDEgXSA9IE1hdGgubWF4KCBlZGdlMSwgZWRnZTIgKTtcblxuXHRcdFx0XHRcdGtleSA9IGVkZ2VbIDAgXSArICcsJyArIGVkZ2VbIDEgXTtcblxuXHRcdFx0XHRcdGlmICggZWRnZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGVkZ2VzWyBrZXkgXSA9IHsgaW5kZXgxOiBlZGdlWyAwIF0sIGluZGV4MjogZWRnZVsgMSBdIH07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXG5cblx0XHRcdGZvciAoIGtleSBpbiBlZGdlcyApIHtcblxuXHRcdFx0XHRlID0gZWRnZXNbIGtleSBdO1xuXG5cdFx0XHRcdHZlcnRleCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBlLmluZGV4MSBdO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0dmVydGV4ID0gZ2VvbWV0cnkudmVydGljZXNbIGUuaW5kZXgyIF07XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uLCBpbmRpY2VzLCBncm91cHM7XG5cdFx0XHR2YXIgZ3JvdXAsIHN0YXJ0LCBjb3VudDtcblx0XHRcdHZhciBpbmRleDEsIGluZGV4MjtcblxuXHRcdFx0dmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0cG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRncm91cHMgPSBbIHsgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzLmNvdW50LCBtYXRlcmlhbEluZGV4OiAwIH0gXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRmb3IgKCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XG5cblx0XHRcdFx0XHRncm91cCA9IGdyb3Vwc1sgbyBdO1xuXG5cdFx0XHRcdFx0c3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHRjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IHN0YXJ0LCBsID0gKCBzdGFydCArIGNvdW50ICk7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRlZGdlMSA9IGluZGljZXMuZ2V0WCggaSArIGogKTtcblx0XHRcdFx0XHRcdFx0ZWRnZTIgPSBpbmRpY2VzLmdldFgoIGkgKyAoIGogKyAxICkgJSAzICk7XG5cdFx0XHRcdFx0XHRcdGVkZ2VbIDAgXSA9IE1hdGgubWluKCBlZGdlMSwgZWRnZTIgKTsgLy8gc29ydGluZyBwcmV2ZW50cyBkdXBsaWNhdGVzXG5cdFx0XHRcdFx0XHRcdGVkZ2VbIDEgXSA9IE1hdGgubWF4KCBlZGdlMSwgZWRnZTIgKTtcblxuXHRcdFx0XHRcdFx0XHRrZXkgPSBlZGdlWyAwIF0gKyAnLCcgKyBlZGdlWyAxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBlZGdlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGVkZ2VzWyBrZXkgXSA9IHsgaW5kZXgxOiBlZGdlWyAwIF0sIGluZGV4MjogZWRnZVsgMSBdIH07XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXG5cblx0XHRcdFx0Zm9yICgga2V5IGluIGVkZ2VzICkge1xuXG5cdFx0XHRcdFx0ZSA9IGVkZ2VzWyBrZXkgXTtcblxuXHRcdFx0XHRcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgZS5pbmRleDEgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0XHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGUuaW5kZXgyICk7XG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRcdHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9ICggcG9zaXRpb24uY291bnQgLyAzICk7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHQvLyB0aHJlZSBlZGdlcyBwZXIgdHJpYW5nbGUsIGFuIGVkZ2UgaXMgcmVwcmVzZW50ZWQgYXMgKGluZGV4MSwgaW5kZXgyKVxuXHRcdFx0XHRcdFx0Ly8gZS5nLiB0aGUgZmlyc3QgdHJpYW5nbGUgaGFzIHRoZSBmb2xsb3dpbmcgZWRnZXM6ICgwLDEpLCgxLDIpLCgyLDApXG5cblx0XHRcdFx0XHRcdGluZGV4MSA9IDMgKiBpICsgajtcblx0XHRcdFx0XHRcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgxICk7XG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0XHRcdGluZGV4MiA9IDMgKiBpICsgKCAoIGogKyAxICkgJSAzICk7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MiApO1xuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXG5cdH1cblxuXHRXaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0V2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2lyZWZyYW1lR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqXG5cdCAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcblx0ICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcblx0ICovXG5cblx0Ly8gUGFyYW1ldHJpY0dlb21ldHJ5XG5cblx0ZnVuY3Rpb24gUGFyYW1ldHJpY0dlb21ldHJ5KCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0ZnVuYzogZnVuYyxcblx0XHRcdHNsaWNlczogc2xpY2VzLFxuXHRcdFx0c3RhY2tzOiBzdGFja3Ncblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkgKTtcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9XG5cblx0UGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRQYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyYW1ldHJpY0dlb21ldHJ5O1xuXG5cdC8vIFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XG5cblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdGZ1bmM6IGZ1bmMsXG5cdFx0XHRzbGljZXM6IHNsaWNlcyxcblx0XHRcdHN0YWNrczogc3RhY2tzXG5cdFx0fTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdHZhciBpbmRpY2VzID0gW107XG5cdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHR2YXIgdXZzID0gW107XG5cblx0XHR2YXIgRVBTID0gMC4wMDAwMTtcblxuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIHAwID0gbmV3IFZlY3RvcjMoKSwgcDEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBwdSA9IG5ldyBWZWN0b3IzKCksIHB2ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciBpLCBqO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0dmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdiA9IGkgLyBzdGFja3M7XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgdSA9IGogLyBzbGljZXM7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0cDAgPSBmdW5jKCB1LCB2LCBwMCApO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBwMC54LCBwMC55LCBwMC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0Ly8gYXBwcm94aW1hdGUgdGFuZ2VudCB2ZWN0b3JzIHZpYSBmaW5pdGUgZGlmZmVyZW5jZXNcblxuXHRcdFx0XHRpZiAoIHUgLSBFUFMgPj0gMCApIHtcblxuXHRcdFx0XHRcdHAxID0gZnVuYyggdSAtIEVQUywgdiwgcDEgKTtcblx0XHRcdFx0XHRwdS5zdWJWZWN0b3JzKCBwMCwgcDEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cDEgPSBmdW5jKCB1ICsgRVBTLCB2LCBwMSApO1xuXHRcdFx0XHRcdHB1LnN1YlZlY3RvcnMoIHAxLCBwMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHYgLSBFUFMgPj0gMCApIHtcblxuXHRcdFx0XHRcdHAxID0gZnVuYyggdSwgdiAtIEVQUywgcDEgKTtcblx0XHRcdFx0XHRwdi5zdWJWZWN0b3JzKCBwMCwgcDEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cDEgPSBmdW5jKCB1LCB2ICsgRVBTLCBwMSApO1xuXHRcdFx0XHRcdHB2LnN1YlZlY3RvcnMoIHAxLCBwMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcm9zcyBwcm9kdWN0IG9mIHRhbmdlbnQgdmVjdG9ycyByZXR1cm5zIHN1cmZhY2Ugbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFsLmNyb3NzVmVjdG9ycyggcHUsIHB2ICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIHUsIHYgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciBhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuXHRcdFx0XHR2YXIgYiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XG5cdFx0XHRcdHZhciBjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xuXHRcdFx0XHR2YXIgZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xuXG5cdFx0XHRcdC8vIGZhY2VzIG9uZSBhbmQgdHdvXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0UGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xuXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKi9cblxuXHQvLyBQb2x5aGVkcm9uR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBQb2x5aGVkcm9uR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0dmVydGljZXM6IHZlcnRpY2VzLFxuXHRcdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApICk7XG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0fVxuXG5cdFBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0UG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHloZWRyb25HZW9tZXRyeTtcblxuXHQvLyBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcblxuXHRcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0dmVydGljZXM6IHZlcnRpY2VzLFxuXHRcdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cdFx0ZGV0YWlsID0gZGV0YWlsIHx8IDA7XG5cblx0XHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXG5cblx0XHR2YXIgdmVydGV4QnVmZmVyID0gW107XG5cdFx0dmFyIHV2QnVmZmVyID0gW107XG5cblx0XHQvLyB0aGUgc3ViZGl2aXNpb24gY3JlYXRlcyB0aGUgdmVydGV4IGJ1ZmZlciBkYXRhXG5cblx0XHRzdWJkaXZpZGUoIGRldGFpbCApO1xuXG5cdFx0Ly8gYWxsIHZlcnRpY2VzIHNob3VsZCBsaWUgb24gYSBjb25jZXB0dWFsIHNwaGVyZSB3aXRoIGEgZ2l2ZW4gcmFkaXVzXG5cblx0XHRhcHBwbHlSYWRpdXMoIHJhZGl1cyApO1xuXG5cdFx0Ly8gZmluYWxseSwgY3JlYXRlIHRoZSB1diBkYXRhXG5cblx0XHRnZW5lcmF0ZVVWcygpO1xuXG5cdFx0Ly8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIuc2xpY2UoKSwgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkJ1ZmZlciwgMiApICk7XG5cblx0XHRpZiAoIGRldGFpbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmbGF0IG5vcm1hbHNcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xuXG5cdFx0fVxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBkZXRhaWwgKSB7XG5cblx0XHRcdHZhciBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBiID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc29uIHdpdGggdGhlIGdpdmVuIGRldGFpbCB2YWx1ZVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdC8vIGdldCB0aGUgdmVydGljZXMgb2YgdGhlIGZhY2VcblxuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMCBdLCBhICk7XG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAxIF0sIGIgKTtcblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDIgXSwgYyApO1xuXG5cdFx0XHRcdC8vIHBlcmZvcm0gc3ViZGl2aXNpb25cblxuXHRcdFx0XHRzdWJkaXZpZGVGYWNlKCBhLCBiLCBjLCBkZXRhaWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICkge1xuXG5cdFx0XHR2YXIgY29scyA9IE1hdGgucG93KCAyLCBkZXRhaWwgKTtcblxuXHRcdFx0Ly8gd2UgdXNlIHRoaXMgbXVsdGlkaW1lbnNpb25hbCBhcnJheSBhcyBhIGRhdGEgc3RydWN0dXJlIGZvciBjcmVhdGluZyB0aGUgc3ViZGl2aXNpb25cblxuXHRcdFx0dmFyIHYgPSBbXTtcblxuXHRcdFx0dmFyIGksIGo7XG5cblx0XHRcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0dlsgaSBdID0gW107XG5cblx0XHRcdFx0dmFyIGFqID0gYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICk7XG5cdFx0XHRcdHZhciBiaiA9IGIuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApO1xuXG5cdFx0XHRcdHZhciByb3dzID0gY29scyAtIGk7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcblxuXHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xuXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IGFqO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBrID0gTWF0aC5mbG9vciggaiAvIDIgKTtcblxuXHRcdFx0XHRcdGlmICggaiAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayArIDEgXSApO1xuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgXSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFwcHBseVJhZGl1cyggcmFkaXVzICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHRcdHZlcnRleC5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cblx0XHRcdFx0dmVydGV4QnVmZmVyWyBpICsgMCBdID0gdmVydGV4Lng7XG5cdFx0XHRcdHZlcnRleEJ1ZmZlclsgaSArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF07XG5cdFx0XHRcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyWyBpICsgMSBdO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlclsgaSArIDIgXTtcblxuXHRcdFx0XHR2YXIgdSA9IGF6aW11dGgoIHZlcnRleCApIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0XHRcdHZhciB2ID0gaW5jbGluYXRpb24oIHZlcnRleCApIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb3JyZWN0VVZzKCk7XG5cblx0XHRcdGNvcnJlY3RTZWFtKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3JyZWN0U2VhbSgpIHtcblxuXHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHV2QnVmZmVyLmxlbmd0aDsgaSArPSA2ICkge1xuXG5cdFx0XHRcdC8vIHV2IGRhdGEgb2YgYSBzaW5nbGUgZmFjZVxuXG5cdFx0XHRcdHZhciB4MCA9IHV2QnVmZmVyWyBpICsgMCBdO1xuXHRcdFx0XHR2YXIgeDEgPSB1dkJ1ZmZlclsgaSArIDIgXTtcblx0XHRcdFx0dmFyIHgyID0gdXZCdWZmZXJbIGkgKyA0IF07XG5cblx0XHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KCB4MCwgeDEsIHgyICk7XG5cdFx0XHRcdHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIHgxLCB4MiApO1xuXG5cdFx0XHRcdC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcblxuXHRcdFx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHgwIDwgMC4yICkgdXZCdWZmZXJbIGkgKyAwIF0gKz0gMTtcblx0XHRcdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZCdWZmZXJbIGkgKyAyIF0gKz0gMTtcblx0XHRcdFx0XHRpZiAoIHgyIDwgMC4yICkgdXZCdWZmZXJbIGkgKyA0IF0gKz0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHB1c2hWZXJ0ZXgoIHZlcnRleCApIHtcblxuXHRcdFx0dmVydGV4QnVmZmVyLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFZlcnRleEJ5SW5kZXgoIGluZGV4LCB2ZXJ0ZXggKSB7XG5cblx0XHRcdHZhciBzdHJpZGUgPSBpbmRleCAqIDM7XG5cblx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIHN0cmlkZSArIDAgXTtcblx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIHN0cmlkZSArIDEgXTtcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIHN0cmlkZSArIDIgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RVVnMoKSB7XG5cblx0XHRcdHZhciBhID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBiID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIGNlbnRyb2lkID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHR2YXIgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSA5LCBqICs9IDYgKSB7XG5cblx0XHRcdFx0YS5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDAgXSwgdmVydGV4QnVmZmVyWyBpICsgMSBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gKTtcblx0XHRcdFx0Yi5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDMgXSwgdmVydGV4QnVmZmVyWyBpICsgNCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA1IF0gKTtcblx0XHRcdFx0Yy5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDYgXSwgdmVydGV4QnVmZmVyWyBpICsgNyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA4IF0gKTtcblxuXHRcdFx0XHR1dkEuc2V0KCB1dkJ1ZmZlclsgaiArIDAgXSwgdXZCdWZmZXJbIGogKyAxIF0gKTtcblx0XHRcdFx0dXZCLnNldCggdXZCdWZmZXJbIGogKyAyIF0sIHV2QnVmZmVyWyBqICsgMyBdICk7XG5cdFx0XHRcdHV2Qy5zZXQoIHV2QnVmZmVyWyBqICsgNCBdLCB1dkJ1ZmZlclsgaiArIDUgXSApO1xuXG5cdFx0XHRcdGNlbnRyb2lkLmNvcHkoIGEgKS5hZGQoIGIgKS5hZGQoIGMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcblxuXHRcdFx0XHR2YXIgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcblxuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QSwgaiArIDAsIGEsIGF6aSApO1xuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QiwgaiArIDIsIGIsIGF6aSApO1xuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QywgaiArIDQsIGMsIGF6aSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3JyZWN0VVYoIHV2LCBzdHJpZGUsIHZlY3RvciwgYXppbXV0aCApIHtcblxuXHRcdFx0aWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB7XG5cblx0XHRcdFx0dXZCdWZmZXJbIHN0cmlkZSBdID0gdXYueCAtIDE7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkge1xuXG5cdFx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxuXG5cdFx0ZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcblxuXHRcdH1cblxuXG5cdFx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG5cdFx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoIC0gdmVjdG9yLnksIE1hdGguc3FydCggKCB2ZWN0b3IueCAqIHZlY3Rvci54ICkgKyAoIHZlY3Rvci56ICogdmVjdG9yLnogKSApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeTtcblxuXHQvKipcblx0ICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKi9cblxuXHQvLyBUZXRyYWhlZHJvbkdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gVGV0cmFoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSApO1xuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG5cdH1cblxuXHRUZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRldHJhaGVkcm9uR2VvbWV0cnk7XG5cblx0Ly8gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gW1xuXHRcdFx0MSwgMSwgMSwgXHQtIDEsIC0gMSwgMSwgXHQtIDEsIDEsIC0gMSwgXHQxLCAtIDEsIC0gMVxuXHRcdF07XG5cblx0XHR2YXIgaW5kaWNlcyA9IFtcblx0XHRcdDIsIDEsIDAsIFx0MCwgMywgMixcdDEsIDMsIDAsXHQyLCAzLCAxXG5cdFx0XTtcblxuXHRcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdH1cblxuXHRUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqL1xuXG5cdC8vIE9jdGFoZWRyb25HZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIE9jdGFoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9XG5cblx0T2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRPY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xuXG5cdC8vIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXG5cdFx0XHQxLCAwLCAwLCBcdC0gMSwgMCwgMCxcdDAsIDEsIDAsXG5cdFx0XHQwLCAtIDEsIDAsIFx0MCwgMCwgMSxcdDAsIDAsIC0gMVxuXHRcdF07XG5cblx0XHR2YXIgaW5kaWNlcyA9IFtcblx0XHRcdDAsIDIsIDQsXHQwLCA0LCAzLFx0MCwgMywgNSxcblx0XHRcdDAsIDUsIDIsXHQxLCAyLCA1LFx0MSwgNSwgMyxcblx0XHRcdDEsIDMsIDQsXHQxLCA0LCAyXG5cdFx0XTtcblxuXHRcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICovXG5cblx0Ly8gSWNvc2FoZWRyb25HZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIEljb3NhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9XG5cblx0SWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0SWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJY29zYWhlZHJvbkdlb21ldHJ5O1xuXG5cdC8vIEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcblxuXHRcdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXG5cdFx0XHQtIDEsIHQsIDAsIFx0MSwgdCwgMCwgXHQtIDEsIC0gdCwgMCwgXHQxLCAtIHQsIDAsXG5cdFx0XHQgMCwgLSAxLCB0LCBcdDAsIDEsIHQsXHQwLCAtIDEsIC0gdCwgXHQwLCAxLCAtIHQsXG5cdFx0XHQgdCwgMCwgLSAxLCBcdHQsIDAsIDEsIFx0LSB0LCAwLCAtIDEsIFx0LSB0LCAwLCAxXG5cdFx0XTtcblxuXHRcdHZhciBpbmRpY2VzID0gW1xuXHRcdFx0IDAsIDExLCA1LCBcdDAsIDUsIDEsIFx0MCwgMSwgNywgXHQwLCA3LCAxMCwgXHQwLCAxMCwgMTEsXG5cdFx0XHQgMSwgNSwgOSwgXHQ1LCAxMSwgNCxcdDExLCAxMCwgMixcdDEwLCA3LCA2LFx0NywgMSwgOCxcblx0XHRcdCAzLCA5LCA0LCBcdDMsIDQsIDIsXHQzLCAyLCA2LFx0MywgNiwgOCxcdDMsIDgsIDksXG5cdFx0XHQgNCwgOSwgNSwgXHQyLCA0LCAxMSxcdDYsIDIsIDEwLFx0OCwgNiwgNyxcdDksIDgsIDFcblx0XHRdO1xuXG5cdFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqL1xuXG5cdC8vIERvZGVjYWhlZHJvbkdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gRG9kZWNhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSApO1xuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG5cdH1cblxuXHREb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0RG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG5cblx0Ly8gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0XHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXHRcdHZhciByID0gMSAvIHQ7XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXG5cblx0XHRcdC8vICjCsTEsIMKxMSwgwrExKVxuXHRcdFx0LSAxLCAtIDEsIC0gMSxcdC0gMSwgLSAxLCAxLFxuXHRcdFx0LSAxLCAxLCAtIDEsIC0gMSwgMSwgMSxcblx0XHRcdDEsIC0gMSwgLSAxLCAxLCAtIDEsIDEsXG5cdFx0XHQxLCAxLCAtIDEsIDEsIDEsIDEsXG5cblx0XHRcdC8vICgwLCDCsTEvz4YsIMKxz4YpXG5cdFx0XHQgMCwgLSByLCAtIHQsIDAsIC0gciwgdCxcblx0XHRcdCAwLCByLCAtIHQsIDAsIHIsIHQsXG5cblx0XHRcdC8vICjCsTEvz4YsIMKxz4YsIDApXG5cdFx0XHQtIHIsIC0gdCwgMCwgLSByLCB0LCAwLFxuXHRcdFx0IHIsIC0gdCwgMCwgciwgdCwgMCxcblxuXHRcdFx0Ly8gKMKxz4YsIDAsIMKxMS/Philcblx0XHRcdC0gdCwgMCwgLSByLCB0LCAwLCAtIHIsXG5cdFx0XHQtIHQsIDAsIHIsIHQsIDAsIHJcblx0XHRdO1xuXG5cdFx0dmFyIGluZGljZXMgPSBbXG5cdFx0XHQzLCAxMSwgNywgXHQzLCA3LCAxNSwgXHQzLCAxNSwgMTMsXG5cdFx0XHQ3LCAxOSwgMTcsIFx0NywgMTcsIDYsIFx0NywgNiwgMTUsXG5cdFx0XHQxNywgNCwgOCwgXHQxNywgOCwgMTAsIFx0MTcsIDEwLCA2LFxuXHRcdFx0OCwgMCwgMTYsIFx0OCwgMTYsIDIsIFx0OCwgMiwgMTAsXG5cdFx0XHQwLCAxMiwgMSwgXHQwLCAxLCAxOCwgXHQwLCAxOCwgMTYsXG5cdFx0XHQ2LCAxMCwgMiwgXHQ2LCAyLCAxMywgXHQ2LCAxMywgMTUsXG5cdFx0XHQyLCAxNiwgMTgsIFx0MiwgMTgsIDMsIFx0MiwgMywgMTMsXG5cdFx0XHQxOCwgMSwgOSwgXHQxOCwgOSwgMTEsIFx0MTgsIDExLCAzLFxuXHRcdFx0NCwgMTQsIDEyLCBcdDQsIDEyLCAwLCBcdDQsIDAsIDgsXG5cdFx0XHQxMSwgOSwgNSwgXHQxMSwgNSwgMTksIFx0MTEsIDE5LCA3LFxuXHRcdFx0MTksIDUsIDE0LCBcdDE5LCAxNCwgNCwgXHQxOSwgNCwgMTcsXG5cdFx0XHQxLCAxMiwgMTQsIFx0MSwgMTQsIDUsIFx0MSwgNSwgOVxuXHRcdF07XG5cblx0XHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0RG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igb29zbW94aWVjb2RlIC8gaHR0cHM6Ly9naXRodWIuY29tL29vc21veGllY29kZVxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG5cdCAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxuXHQgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKlxuXHQgKi9cblxuXHQvLyBUdWJlR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBUdWJlR2VvbWV0cnkoIHBhdGgsIHR1YnVsYXJTZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkLCB0YXBlciApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cGF0aDogcGF0aCxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRjbG9zZWQ6IGNsb3NlZFxuXHRcdH07XG5cblx0XHRpZiAoIHRhcGVyICE9PSB1bmRlZmluZWQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5UdWJlR2VvbWV0cnk6IHRhcGVyIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0dmFyIGJ1ZmZlckdlb21ldHJ5ID0gbmV3IFR1YmVCdWZmZXJHZW9tZXRyeSggcGF0aCwgdHVidWxhclNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQgKTtcblxuXHRcdC8vIGV4cG9zZSBpbnRlcm5hbHNcblxuXHRcdHRoaXMudGFuZ2VudHMgPSBidWZmZXJHZW9tZXRyeS50YW5nZW50cztcblx0XHR0aGlzLm5vcm1hbHMgPSBidWZmZXJHZW9tZXRyeS5ub3JtYWxzO1xuXHRcdHRoaXMuYmlub3JtYWxzID0gYnVmZmVyR2VvbWV0cnkuYmlub3JtYWxzO1xuXG5cdFx0Ly8gY3JlYXRlIGdlb21ldHJ5XG5cblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggYnVmZmVyR2VvbWV0cnkgKTtcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9XG5cblx0VHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHViZUdlb21ldHJ5O1xuXG5cdC8vIFR1YmVCdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFR1YmVCdWZmZXJHZW9tZXRyeSggcGF0aCwgdHVidWxhclNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQgKSB7XG5cblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVHViZUJ1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHBhdGg6IHBhdGgsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0Y2xvc2VkOiBjbG9zZWRcblx0XHR9O1xuXG5cdFx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY0O1xuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXHRcdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0XHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XG5cblx0XHR2YXIgZnJhbWVzID0gcGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCB0dWJ1bGFyU2VnbWVudHMsIGNsb3NlZCApO1xuXG5cdFx0Ly8gZXhwb3NlIGludGVybmFsc1xuXG5cdFx0dGhpcy50YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cztcblx0XHR0aGlzLm5vcm1hbHMgPSBmcmFtZXMubm9ybWFscztcblx0XHR0aGlzLmJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdHZhciBQID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciBpLCBqO1xuXG5cdFx0Ly8gYnVmZmVyXG5cblx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdHZhciB1dnMgPSBbXTtcblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlciBkYXRhXG5cblx0XHRnZW5lcmF0ZUJ1ZmZlckRhdGEoKTtcblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0Ly8gZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlckRhdGEoKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGdlbmVyYXRlU2VnbWVudCggaSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBub3QgY2xvc2VkLCBnZW5lcmF0ZSB0aGUgbGFzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHNcblx0XHRcdC8vIGF0IHRoZSByZWd1bGFyIHBvc2l0aW9uIG9uIHRoZSBnaXZlbiBwYXRoXG5cdFx0XHQvL1xuXHRcdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgZHVwbGljYXRlIHRoZSBmaXJzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHMgKHV2cyB3aWxsIGRpZmZlcilcblxuXHRcdFx0Z2VuZXJhdGVTZWdtZW50KCAoIGNsb3NlZCA9PT0gZmFsc2UgKSA/IHR1YnVsYXJTZWdtZW50cyA6IDAgKTtcblxuXHRcdFx0Ly8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cblx0XHRcdC8vIHRoaXMgbWFrZXMgaXQgZWFzeSBjb21wdXRlIGNvcnJlY3QgdmFsdWVzIGZvciBjbG9zZWQgZ2VvbWV0cmllc1xuXG5cdFx0XHRnZW5lcmF0ZVVWcygpO1xuXG5cdFx0XHQvLyBmaW5hbGx5IGNyZWF0ZSBmYWNlc1xuXG5cdFx0XHRnZW5lcmF0ZUluZGljZXMoKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudCggaSApIHtcblxuXHRcdFx0Ly8gd2UgdXNlIGdldFBvaW50QXQgdG8gc2FtcGxlIGV2ZW5seSBkaXN0cmlidXRlZCBwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gcGF0aFxuXG5cdFx0XHRQID0gcGF0aC5nZXRQb2ludEF0KCBpIC8gdHVidWxhclNlZ21lbnRzLCBQICk7XG5cblx0XHRcdC8vIHJldHJpZXZlIGNvcnJlc3BvbmRpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbFxuXG5cdFx0XHR2YXIgTiA9IGZyYW1lcy5ub3JtYWxzWyBpIF07XG5cdFx0XHR2YXIgQiA9IGZyYW1lcy5iaW5vcm1hbHNbIGkgXTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgbm9ybWFscyBhbmQgdmVydGljZXMgZm9yIHRoZSBjdXJyZW50IHNlZ21lbnRcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0XHR2YXIgc2luID0gTWF0aC5zaW4oIHYgKTtcblx0XHRcdFx0dmFyIGNvcyA9IC0gTWF0aC5jb3MoIHYgKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwueCA9ICggY29zICogTi54ICsgc2luICogQi54ICk7XG5cdFx0XHRcdG5vcm1hbC55ID0gKCBjb3MgKiBOLnkgKyBzaW4gKiBCLnkgKTtcblx0XHRcdFx0bm9ybWFsLnogPSAoIGNvcyAqIE4ueiArIHNpbiAqIEIueiApO1xuXHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcblx0XHRcdFx0dmVydGV4LnkgPSBQLnkgKyByYWRpdXMgKiBub3JtYWwueTtcblx0XHRcdFx0dmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlSW5kaWNlcygpIHtcblxuXHRcdFx0Zm9yICggaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xuXHRcdFx0XHRcdHZhciBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XG5cdFx0XHRcdFx0dmFyIGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XG5cdFx0XHRcdFx0dmFyIGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblxuXHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0XHR1di54ID0gaSAvIHR1YnVsYXJTZWdtZW50cztcblx0XHRcdFx0XHR1di55ID0gaiAvIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0VHViZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRUdWJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHViZUJ1ZmZlckdlb21ldHJ5O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG9vc21veGllY29kZVxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKlxuXHQgKiBiYXNlZCBvbiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcHF0b3J1cy9cblx0ICovXG5cblx0Ly8gVG9ydXNLbm90R2VvbWV0cnlcblxuXHRmdW5jdGlvbiBUb3J1c0tub3RHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdHA6IHAsXG5cdFx0XHRxOiBxXG5cdFx0fTtcblxuXHRcdGlmICggaGVpZ2h0U2NhbGUgIT09IHVuZGVmaW5lZCApIGNvbnNvbGUud2FybiggJ1RIUkVFLlRvcnVzS25vdEdlb21ldHJ5OiBoZWlnaHRTY2FsZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnNjYWxlKCB4LCB5LCB6ICkgaW5zdGVhZC4nICk7XG5cblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEgKSApO1xuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG5cdH1cblxuXHRUb3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNLbm90R2VvbWV0cnk7XG5cblx0Ly8gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxICkge1xuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEJ1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0dHViZTogdHViZSxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0cDogcCxcblx0XHRcdHE6IHFcblx0XHR9O1xuXG5cdFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cdFx0dHViZSA9IHR1YmUgfHwgMC40O1xuXHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApIHx8IDY0O1xuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xuXHRcdHAgPSBwIHx8IDI7XG5cdFx0cSA9IHEgfHwgMztcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdHZhciBpbmRpY2VzID0gW107XG5cdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHR2YXIgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHR2YXIgaSwgajtcblxuXHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIFAxID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgUDIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIEIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBUID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgTiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7ICsrIGkgKSB7XG5cblx0XHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ2VtZW50XG5cblx0XHRcdHZhciB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIHAgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0Ly8gbm93IHdlIGNhbGN1bGF0ZSB0d28gcG9pbnRzLiBQMSBpcyBvdXIgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmUsIFAyIGlzIGEgbGl0dGxlIGZhcnRoZXIgYWhlYWQuXG5cdFx0XHQvLyB0aGVzZSBwb2ludHMgYXJlIHVzZWQgdG8gY3JlYXRlIGEgc3BlY2lhbCBcImNvb3JkaW5hdGUgc3BhY2VcIiwgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB2ZXJ0ZXggcG9zaXRpb25zXG5cblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBQMSApO1xuXHRcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1ICsgMC4wMSwgcCwgcSwgcmFkaXVzLCBQMiApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcblxuXHRcdFx0VC5zdWJWZWN0b3JzKCBQMiwgUDEgKTtcblx0XHRcdE4uYWRkVmVjdG9ycyggUDIsIFAxICk7XG5cdFx0XHRCLmNyb3NzVmVjdG9ycyggVCwgTiApO1xuXHRcdFx0Ti5jcm9zc1ZlY3RvcnMoIEIsIFQgKTtcblxuXHRcdFx0Ly8gbm9ybWFsaXplIEIsIE4uIFQgY2FuIGJlIGlnbm9yZWQsIHdlIGRvbid0IHVzZSBpdFxuXG5cdFx0XHRCLm5vcm1hbGl6ZSgpO1xuXHRcdFx0Ti5ub3JtYWxpemUoKTtcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7ICsrIGogKSB7XG5cblx0XHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgdmVydGljZXMuIHRoZXkgYXJlIG5vdGhpbmcgbW9yZSB0aGFuIGFuIGV4dHJ1c2lvbiBvZiB0aGUgdG9ydXMgY3VydmUuXG5cdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZXh0cnVkZSBhIHNoYXBlIGluIHRoZSB4eS1wbGFuZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxjdWxhdGUgYSB6LXZhbHVlLlxuXG5cdFx0XHRcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0XHRcdHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7XG5cdFx0XHRcdHZhciBjeSA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIGZpbmFsIHZlcnRleCBwb3NpdGlvbi5cblx0XHRcdFx0Ly8gZmlyc3Qgd2Ugb3JpZW50IHRoZSBleHRydXNpb24gd2l0aCBvdXIgYmFzaXMgdmVjdG9zLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAxLnggKyAoIGN4ICogTi54ICsgY3kgKiBCLnggKTtcblx0XHRcdFx0dmVydGV4LnkgPSBQMS55ICsgKCBjeCAqIE4ueSArIGN5ICogQi55ICk7XG5cdFx0XHRcdHZlcnRleC56ID0gUDEueiArICggY3ggKiBOLnogKyBjeSAqIEIueiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWwgKFAxIGlzIGFsd2F5cyB0aGUgY2VudGVyL29yaWdpbiBvZiB0aGUgZXh0cnVzaW9uLCB0aHVzIHdlIGNhbiB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWwpXG5cblx0XHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgUDEgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHRcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yICggaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0dmFyIGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xuXHRcdFx0XHR2YXIgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xuXHRcdFx0XHR2YXIgYyA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblx0XHRcdFx0dmFyIGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHQvLyB0aGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlXG5cblx0XHRmdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24gKSB7XG5cblx0XHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XG5cdFx0XHR2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xuXHRcdFx0dmFyIHF1T3ZlclAgPSBxIC8gcCAqIHU7XG5cdFx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0XHRwb3NpdGlvbi54ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuXHRcdFx0cG9zaXRpb24ueSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcblx0XHRcdHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRUb3J1c0tub3RCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igb29zbW94aWVjb2RlXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqL1xuXG5cdC8vIFRvcnVzR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBUb3J1c0dlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0dHViZTogdHViZSxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0YXJjOiBhcmNcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUb3J1c0J1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApICk7XG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0fVxuXG5cdFRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNHZW9tZXRyeTtcblxuXHQvLyBUb3J1c0J1ZmZlckdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gVG9ydXNCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XG5cblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVG9ydXNCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdGFyYzogYXJjXG5cdFx0fTtcblxuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXHRcdHR1YmUgPSB0dWJlIHx8IDAuNDtcblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICkgfHwgODtcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKSB8fCA2O1xuXHRcdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdHZhciBpbmRpY2VzID0gW107XG5cdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHR2YXIgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHR2YXIgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciBqLCBpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG5cdFx0XHRcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XG5cdFx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcblx0XHRcdFx0Y2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbiggdSApO1xuXHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHRcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yICggaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0dmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcblx0XHRcdFx0dmFyIGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xuXHRcdFx0XHR2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblx0XHRcdFx0dmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0VG9ydXNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0VG9ydXNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0J1ZmZlckdlb21ldHJ5O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKiBQb3J0IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQgKHYyLjEuMilcblx0ICovXG5cblx0dmFyIEVhcmN1dCA9IHtcblxuXHRcdHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiAoIGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0gKSB7XG5cblx0XHRcdGRpbSA9IGRpbSB8fCAyO1xuXG5cdFx0XHR2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG5cdFx0XHRcdG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1sgMCBdICogZGltIDogZGF0YS5sZW5ndGgsXG5cdFx0XHRcdG91dGVyTm9kZSA9IGxpbmtlZExpc3QoIGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUgKSxcblx0XHRcdFx0dHJpYW5nbGVzID0gW107XG5cblx0XHRcdGlmICggISBvdXRlck5vZGUgKSByZXR1cm4gdHJpYW5nbGVzO1xuXG5cdFx0XHR2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuXHRcdFx0aWYgKCBoYXNIb2xlcyApIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKTtcblxuXHRcdFx0Ly8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG5cblx0XHRcdGlmICggZGF0YS5sZW5ndGggPiA4MCAqIGRpbSApIHtcblxuXHRcdFx0XHRtaW5YID0gbWF4WCA9IGRhdGFbIDAgXTtcblx0XHRcdFx0bWluWSA9IG1heFkgPSBkYXRhWyAxIF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0gKSB7XG5cblx0XHRcdFx0XHR4ID0gZGF0YVsgaSBdO1xuXHRcdFx0XHRcdHkgPSBkYXRhWyBpICsgMSBdO1xuXHRcdFx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcblx0XHRcdFx0XHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XG5cdFx0XHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xuXHRcdFx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cblxuXHRcdFx0XHRpbnZTaXplID0gTWF0aC5tYXgoIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSApO1xuXHRcdFx0XHRpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDEgLyBpbnZTaXplIDogMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRlYXJjdXRMaW5rZWQoIG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcblxuXHRcdFx0cmV0dXJuIHRyaWFuZ2xlcztcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuXG5cdGZ1bmN0aW9uIGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlICkge1xuXG5cdFx0dmFyIGksIGxhc3Q7XG5cblx0XHRpZiAoIGNsb2Nrd2lzZSA9PT0gKCBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSA+IDAgKSApIHtcblxuXHRcdFx0Zm9yICggaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZvciAoIGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsYXN0ICYmIGVxdWFscyggbGFzdCwgbGFzdC5uZXh0ICkgKSB7XG5cblx0XHRcdHJlbW92ZU5vZGUoIGxhc3QgKTtcblx0XHRcdGxhc3QgPSBsYXN0Lm5leHQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbGFzdDtcblxuXHR9XG5cblx0Ly8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcblxuXHRmdW5jdGlvbiBmaWx0ZXJQb2ludHMoIHN0YXJ0LCBlbmQgKSB7XG5cblx0XHRpZiAoICEgc3RhcnQgKSByZXR1cm4gc3RhcnQ7XG5cdFx0aWYgKCAhIGVuZCApIGVuZCA9IHN0YXJ0O1xuXG5cdFx0dmFyIHAgPSBzdGFydCwgYWdhaW47XG5cblx0XHRkbyB7XG5cblx0XHRcdGFnYWluID0gZmFsc2U7XG5cblx0XHRcdGlmICggISBwLnN0ZWluZXIgJiYgKCBlcXVhbHMoIHAsIHAubmV4dCApIHx8IGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPT09IDAgKSApIHtcblxuXHRcdFx0XHRyZW1vdmVOb2RlKCBwICk7XG5cdFx0XHRcdHAgPSBlbmQgPSBwLnByZXY7XG5cdFx0XHRcdGlmICggcCA9PT0gcC5uZXh0ICkgYnJlYWs7XG5cdFx0XHRcdGFnYWluID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0XHR9XG5cblx0XHR9IHdoaWxlICggYWdhaW4gfHwgcCAhPT0gZW5kICk7XG5cblx0XHRyZXR1cm4gZW5kO1xuXG5cdH1cblxuXHQvLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcblxuXHRmdW5jdGlvbiBlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MgKSB7XG5cblx0XHRpZiAoICEgZWFyICkgcmV0dXJuO1xuXG5cdFx0Ly8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuXG5cdFx0aWYgKCAhIHBhc3MgJiYgaW52U2l6ZSApIGluZGV4Q3VydmUoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXG5cdFx0dmFyIHN0b3AgPSBlYXIsIHByZXYsIG5leHQ7XG5cblx0XHQvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcblxuXHRcdHdoaWxlICggZWFyLnByZXYgIT09IGVhci5uZXh0ICkge1xuXG5cdFx0XHRwcmV2ID0gZWFyLnByZXY7XG5cdFx0XHRuZXh0ID0gZWFyLm5leHQ7XG5cblx0XHRcdGlmICggaW52U2l6ZSA/IGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSA6IGlzRWFyKCBlYXIgKSApIHtcblxuXHRcdFx0XHQvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuXHRcdFx0XHR0cmlhbmdsZXMucHVzaCggcHJldi5pIC8gZGltICk7XG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBlYXIuaSAvIGRpbSApO1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaCggbmV4dC5pIC8gZGltICk7XG5cblx0XHRcdFx0cmVtb3ZlTm9kZSggZWFyICk7XG5cblx0XHRcdFx0Ly8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcblx0XHRcdFx0ZWFyID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRzdG9wID0gbmV4dC5uZXh0O1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGVhciA9IG5leHQ7XG5cblx0XHRcdC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG5cblx0XHRcdGlmICggZWFyID09PSBzdG9wICkge1xuXG5cdFx0XHRcdC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG5cblx0XHRcdFx0aWYgKCAhIHBhc3MgKSB7XG5cblx0XHRcdFx0XHRlYXJjdXRMaW5rZWQoIGZpbHRlclBvaW50cyggZWFyICksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxICk7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBlYXIsIHRyaWFuZ2xlcywgZGltICk7XG5cdFx0XHRcdFx0ZWFyY3V0TGlua2VkKCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyICk7XG5cblx0XHRcdFx0Ly8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXNzID09PSAyICkge1xuXG5cdFx0XHRcdFx0c3BsaXRFYXJjdXQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5cblx0ZnVuY3Rpb24gaXNFYXIoIGVhciApIHtcblxuXHRcdHZhciBhID0gZWFyLnByZXYsXG5cdFx0XHRiID0gZWFyLFxuXHRcdFx0YyA9IGVhci5uZXh0O1xuXG5cdFx0aWYgKCBhcmVhKCBhLCBiLCBjICkgPj0gMCApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuXHRcdC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG5cdFx0dmFyIHAgPSBlYXIubmV4dC5uZXh0O1xuXG5cdFx0d2hpbGUgKCBwICE9PSBlYXIucHJldiApIHtcblxuXHRcdFx0aWYgKCBwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0XHR2YXIgYSA9IGVhci5wcmV2LFxuXHRcdFx0YiA9IGVhcixcblx0XHRcdGMgPSBlYXIubmV4dDtcblxuXHRcdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cblx0XHQvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuXG5cdFx0dmFyIG1pblRYID0gYS54IDwgYi54ID8gKCBhLnggPCBjLnggPyBhLnggOiBjLnggKSA6ICggYi54IDwgYy54ID8gYi54IDogYy54ICksXG5cdFx0XHRtaW5UWSA9IGEueSA8IGIueSA/ICggYS55IDwgYy55ID8gYS55IDogYy55ICkgOiAoIGIueSA8IGMueSA/IGIueSA6IGMueSApLFxuXHRcdFx0bWF4VFggPSBhLnggPiBiLnggPyAoIGEueCA+IGMueCA/IGEueCA6IGMueCApIDogKCBiLnggPiBjLnggPyBiLnggOiBjLnggKSxcblx0XHRcdG1heFRZID0gYS55ID4gYi55ID8gKCBhLnkgPiBjLnkgPyBhLnkgOiBjLnkgKSA6ICggYi55ID4gYy55ID8gYi55IDogYy55ICk7XG5cblx0XHQvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuXG5cdFx0dmFyIG1pblogPSB6T3JkZXIoIG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgaW52U2l6ZSApLFxuXHRcdFx0bWF4WiA9IHpPcmRlciggbWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XG5cblx0XHQvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcblxuXHRcdHZhciBwID0gZWFyLm5leHRaO1xuXG5cdFx0d2hpbGUgKCBwICYmIHAueiA8PSBtYXhaICkge1xuXG5cdFx0XHRpZiAoIHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG5cdFx0XHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSApICYmXG5cdFx0XHRcdFx0YXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0cCA9IHAubmV4dFo7XG5cblx0XHR9XG5cblx0XHQvLyB0aGVuIGxvb2sgZm9yIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcblxuXHRcdHAgPSBlYXIucHJldlo7XG5cblx0XHR3aGlsZSAoIHAgJiYgcC56ID49IG1pblogKSB7XG5cblx0XHRcdGlmICggcCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcblx0XHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiZcblx0XHRcdFx0XHRhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHAgPSBwLnByZXZaO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdC8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5cblx0ZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggc3RhcnQsIHRyaWFuZ2xlcywgZGltICkge1xuXG5cdFx0dmFyIHAgPSBzdGFydDtcblxuXHRcdGRvIHtcblxuXHRcdFx0dmFyIGEgPSBwLnByZXYsIGIgPSBwLm5leHQubmV4dDtcblxuXHRcdFx0aWYgKCAhIGVxdWFscyggYSwgYiApICYmIGludGVyc2VjdHMoIGEsIHAsIHAubmV4dCwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBiLCBhICkgKSB7XG5cblx0XHRcdFx0dHJpYW5nbGVzLnB1c2goIGEuaSAvIGRpbSApO1xuXHRcdFx0XHR0cmlhbmdsZXMucHVzaCggcC5pIC8gZGltICk7XG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBiLmkgLyBkaW0gKTtcblxuXHRcdFx0XHQvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG5cblx0XHRcdFx0cmVtb3ZlTm9kZSggcCApO1xuXHRcdFx0XHRyZW1vdmVOb2RlKCBwLm5leHQgKTtcblxuXHRcdFx0XHRwID0gc3RhcnQgPSBiO1xuXG5cdFx0XHR9XG5cblx0XHRcdHAgPSBwLm5leHQ7XG5cblx0XHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcblxuXHRcdHJldHVybiBwO1xuXG5cdH1cblxuXHQvLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuXG5cdGZ1bmN0aW9uIHNwbGl0RWFyY3V0KCBzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0XHQvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuXG5cdFx0dmFyIGEgPSBzdGFydDtcblxuXHRcdGRvIHtcblxuXHRcdFx0dmFyIGIgPSBhLm5leHQubmV4dDtcblxuXHRcdFx0d2hpbGUgKCBiICE9PSBhLnByZXYgKSB7XG5cblx0XHRcdFx0aWYgKCBhLmkgIT09IGIuaSAmJiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSApIHtcblxuXHRcdFx0XHRcdC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcblxuXHRcdFx0XHRcdHZhciBjID0gc3BsaXRQb2x5Z29uKCBhLCBiICk7XG5cblx0XHRcdFx0XHQvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuXG5cdFx0XHRcdFx0YSA9IGZpbHRlclBvaW50cyggYSwgYS5uZXh0ICk7XG5cdFx0XHRcdFx0YyA9IGZpbHRlclBvaW50cyggYywgYy5uZXh0ICk7XG5cblx0XHRcdFx0XHQvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuXG5cdFx0XHRcdFx0ZWFyY3V0TGlua2VkKCBhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXHRcdFx0XHRcdGVhcmN1dExpbmtlZCggYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGIgPSBiLm5leHQ7XG5cblx0XHRcdH1cblxuXHRcdFx0YSA9IGEubmV4dDtcblxuXHRcdH0gd2hpbGUgKCBhICE9PSBzdGFydCApO1xuXG5cdH1cblxuXHQvLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG5cblx0ZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApIHtcblxuXHRcdHZhciBxdWV1ZSA9IFtdLCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cblx0XHRmb3IgKCBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpICsrICkge1xuXG5cdFx0XHRzdGFydCA9IGhvbGVJbmRpY2VzWyBpIF0gKiBkaW07XG5cdFx0XHRlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzWyBpICsgMSBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cdFx0XHRsaXN0ID0gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSApO1xuXHRcdFx0aWYgKCBsaXN0ID09PSBsaXN0Lm5leHQgKSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuXHRcdFx0cXVldWUucHVzaCggZ2V0TGVmdG1vc3QoIGxpc3QgKSApO1xuXG5cdFx0fVxuXG5cdFx0cXVldWUuc29ydCggY29tcGFyZVggKTtcblxuXHRcdC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0ZWxpbWluYXRlSG9sZSggcXVldWVbIGkgXSwgb3V0ZXJOb2RlICk7XG5cdFx0XHRvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMoIG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRlck5vZGU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBhcmVYKCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIGEueCAtIGIueDtcblxuXHR9XG5cblx0Ly8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5cblx0ZnVuY3Rpb24gZWxpbWluYXRlSG9sZSggaG9sZSwgb3V0ZXJOb2RlICkge1xuXG5cdFx0b3V0ZXJOb2RlID0gZmluZEhvbGVCcmlkZ2UoIGhvbGUsIG91dGVyTm9kZSApO1xuXG5cdFx0aWYgKCBvdXRlck5vZGUgKSB7XG5cblx0XHRcdHZhciBiID0gc3BsaXRQb2x5Z29uKCBvdXRlck5vZGUsIGhvbGUgKTtcblxuXHRcdFx0ZmlsdGVyUG9pbnRzKCBiLCBiLm5leHQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuXG5cdGZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKSB7XG5cblx0XHR2YXIgcCA9IG91dGVyTm9kZSxcblx0XHRcdGh4ID0gaG9sZS54LFxuXHRcdFx0aHkgPSBob2xlLnksXG5cdFx0XHRxeCA9IC0gSW5maW5pdHksXG5cdFx0XHRtO1xuXG5cdFx0Ly8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuXHRcdC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcblxuXHRcdGRvIHtcblxuXHRcdFx0aWYgKCBoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSApIHtcblxuXHRcdFx0XHR2YXIgeCA9IHAueCArICggaHkgLSBwLnkgKSAqICggcC5uZXh0LnggLSBwLnggKSAvICggcC5uZXh0LnkgLSBwLnkgKTtcblxuXHRcdFx0XHRpZiAoIHggPD0gaHggJiYgeCA+IHF4ICkge1xuXG5cdFx0XHRcdFx0cXggPSB4O1xuXG5cdFx0XHRcdFx0aWYgKCB4ID09PSBoeCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBoeSA9PT0gcC55ICkgcmV0dXJuIHA7XG5cdFx0XHRcdFx0XHRpZiAoIGh5ID09PSBwLm5leHQueSApIHJldHVybiBwLm5leHQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0fSB3aGlsZSAoIHAgIT09IG91dGVyTm9kZSApO1xuXG5cdFx0aWYgKCAhIG0gKSByZXR1cm4gbnVsbDtcblxuXHRcdGlmICggaHggPT09IHF4ICkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcblxuXHRcdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcblx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcblx0XHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG5cdFx0dmFyIHN0b3AgPSBtLFxuXHRcdFx0bXggPSBtLngsXG5cdFx0XHRteSA9IG0ueSxcblx0XHRcdHRhbk1pbiA9IEluZmluaXR5LFxuXHRcdFx0dGFuO1xuXG5cdFx0cCA9IG0ubmV4dDtcblxuXHRcdHdoaWxlICggcCAhPT0gc3RvcCApIHtcblxuXHRcdFx0aWYgKCBoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcblx0XHRcdFx0XHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSApICkge1xuXG5cdFx0XHRcdHRhbiA9IE1hdGguYWJzKCBoeSAtIHAueSApIC8gKCBoeCAtIHAueCApOyAvLyB0YW5nZW50aWFsXG5cblx0XHRcdFx0aWYgKCAoIHRhbiA8IHRhbk1pbiB8fCAoIHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCApICkgJiYgbG9jYWxseUluc2lkZSggcCwgaG9sZSApICkge1xuXG5cdFx0XHRcdFx0bSA9IHA7XG5cdFx0XHRcdFx0dGFuTWluID0gdGFuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG07XG5cblx0fVxuXG5cdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcblxuXHRmdW5jdGlvbiBpbmRleEN1cnZlKCBzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcblxuXHRcdHZhciBwID0gc3RhcnQ7XG5cblx0XHRkbyB7XG5cblx0XHRcdGlmICggcC56ID09PSBudWxsICkgcC56ID0gek9yZGVyKCBwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xuXHRcdFx0cC5wcmV2WiA9IHAucHJldjtcblx0XHRcdHAubmV4dFogPSBwLm5leHQ7XG5cdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XG5cblx0XHRwLnByZXZaLm5leHRaID0gbnVsbDtcblx0XHRwLnByZXZaID0gbnVsbDtcblxuXHRcdHNvcnRMaW5rZWQoIHAgKTtcblxuXHR9XG5cblx0Ly8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cblx0Ly8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcblxuXHRmdW5jdGlvbiBzb3J0TGlua2VkKCBsaXN0ICkge1xuXG5cdFx0dmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLCBpblNpemUgPSAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHRwID0gbGlzdDtcblx0XHRcdGxpc3QgPSBudWxsO1xuXHRcdFx0dGFpbCA9IG51bGw7XG5cdFx0XHRudW1NZXJnZXMgPSAwO1xuXG5cdFx0XHR3aGlsZSAoIHAgKSB7XG5cblx0XHRcdFx0bnVtTWVyZ2VzICsrO1xuXHRcdFx0XHRxID0gcDtcblx0XHRcdFx0cFNpemUgPSAwO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaW5TaXplOyBpICsrICkge1xuXG5cdFx0XHRcdFx0cFNpemUgKys7XG5cdFx0XHRcdFx0cSA9IHEubmV4dFo7XG5cdFx0XHRcdFx0aWYgKCAhIHEgKSBicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cVNpemUgPSBpblNpemU7XG5cblx0XHRcdFx0d2hpbGUgKCBwU2l6ZSA+IDAgfHwgKCBxU2l6ZSA+IDAgJiYgcSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwU2l6ZSAhPT0gMCAmJiAoIHFTaXplID09PSAwIHx8ICEgcSB8fCBwLnogPD0gcS56ICkgKSB7XG5cblx0XHRcdFx0XHRcdGUgPSBwO1xuXHRcdFx0XHRcdFx0cCA9IHAubmV4dFo7XG5cdFx0XHRcdFx0XHRwU2l6ZSAtLTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGUgPSBxO1xuXHRcdFx0XHRcdFx0cSA9IHEubmV4dFo7XG5cdFx0XHRcdFx0XHRxU2l6ZSAtLTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGFpbCApIHRhaWwubmV4dFogPSBlO1xuXHRcdFx0XHRcdGVsc2UgbGlzdCA9IGU7XG5cblx0XHRcdFx0XHRlLnByZXZaID0gdGFpbDtcblx0XHRcdFx0XHR0YWlsID0gZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cCA9IHE7XG5cblx0XHRcdH1cblxuXHRcdFx0dGFpbC5uZXh0WiA9IG51bGw7XG5cdFx0XHRpblNpemUgKj0gMjtcblxuXHRcdH0gd2hpbGUgKCBudW1NZXJnZXMgPiAxICk7XG5cblx0XHRyZXR1cm4gbGlzdDtcblxuXHR9XG5cblx0Ly8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5cblx0ZnVuY3Rpb24gek9yZGVyKCB4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xuXG5cdFx0Ly8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuXG5cdFx0eCA9IDMyNzY3ICogKCB4IC0gbWluWCApICogaW52U2l6ZTtcblx0XHR5ID0gMzI3NjcgKiAoIHkgLSBtaW5ZICkgKiBpbnZTaXplO1xuXG5cdFx0eCA9ICggeCB8ICggeCA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XG5cdFx0eCA9ICggeCB8ICggeCA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XG5cdFx0eCA9ICggeCB8ICggeCA8PCAyICkgKSAmIDB4MzMzMzMzMzM7XG5cdFx0eCA9ICggeCB8ICggeCA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XG5cblx0XHR5ID0gKCB5IHwgKCB5IDw8IDggKSApICYgMHgwMEZGMDBGRjtcblx0XHR5ID0gKCB5IHwgKCB5IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcblx0XHR5ID0gKCB5IHwgKCB5IDw8IDIgKSApICYgMHgzMzMzMzMzMztcblx0XHR5ID0gKCB5IHwgKCB5IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcblxuXHRcdHJldHVybiB4IHwgKCB5IDw8IDEgKTtcblxuXHR9XG5cblx0Ly8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuXG5cdGZ1bmN0aW9uIGdldExlZnRtb3N0KCBzdGFydCApIHtcblxuXHRcdHZhciBwID0gc3RhcnQsIGxlZnRtb3N0ID0gc3RhcnQ7XG5cblx0XHRkbyB7XG5cblx0XHRcdGlmICggcC54IDwgbGVmdG1vc3QueCApIGxlZnRtb3N0ID0gcDtcblx0XHRcdHAgPSBwLm5leHQ7XG5cblx0XHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcblxuXHRcdHJldHVybiBsZWZ0bW9zdDtcblxuXHR9XG5cblx0Ly8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuXG5cdGZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5ICkge1xuXG5cdFx0cmV0dXJuICggY3ggLSBweCApICogKCBheSAtIHB5ICkgLSAoIGF4IC0gcHggKSAqICggY3kgLSBweSApID49IDAgJiZcblx0XHQgKCBheCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSAtICggYnggLSBweCApICogKCBheSAtIHB5ICkgPj0gMCAmJlxuXHRcdCAoIGJ4IC0gcHggKSAqICggY3kgLSBweSApIC0gKCBjeCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSA+PSAwO1xuXG5cdH1cblxuXHQvLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcblxuXHRmdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSB7XG5cblx0XHRyZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICEgaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSAmJlxuXHRcdFx0bG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSAmJiBtaWRkbGVJbnNpZGUoIGEsIGIgKTtcblxuXHR9XG5cblx0Ly8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuXG5cdGZ1bmN0aW9uIGFyZWEoIHAsIHEsIHIgKSB7XG5cblx0XHRyZXR1cm4gKCBxLnkgLSBwLnkgKSAqICggci54IC0gcS54ICkgLSAoIHEueCAtIHAueCApICogKCByLnkgLSBxLnkgKTtcblxuXHR9XG5cblx0Ly8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcblxuXHRmdW5jdGlvbiBlcXVhbHMoIHAxLCBwMiApIHtcblxuXHRcdHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG5cblx0fVxuXG5cdC8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RzKCBwMSwgcTEsIHAyLCBxMiApIHtcblxuXHRcdGlmICggKCBlcXVhbHMoIHAxLCBxMSApICYmIGVxdWFscyggcDIsIHEyICkgKSB8fFxuXHRcdFx0XHQoIGVxdWFscyggcDEsIHEyICkgJiYgZXF1YWxzKCBwMiwgcTEgKSApICkgcmV0dXJuIHRydWU7XG5cblx0XHRyZXR1cm4gYXJlYSggcDEsIHExLCBwMiApID4gMCAhPT0gYXJlYSggcDEsIHExLCBxMiApID4gMCAmJlxuXHRcdFx0XHRcdCBhcmVhKCBwMiwgcTIsIHAxICkgPiAwICE9PSBhcmVhKCBwMiwgcTIsIHExICkgPiAwO1xuXG5cdH1cblxuXHQvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkge1xuXG5cdFx0dmFyIHAgPSBhO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHRpZiAoIHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzKCBwLCBwLm5leHQsIGEsIGIgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0fSB3aGlsZSAoIHAgIT09IGEgKTtcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0Ly8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5cblx0ZnVuY3Rpb24gbG9jYWxseUluc2lkZSggYSwgYiApIHtcblxuXHRcdHJldHVybiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApIDwgMCA/XG5cdFx0XHRhcmVhKCBhLCBiLCBhLm5leHQgKSA+PSAwICYmIGFyZWEoIGEsIGEucHJldiwgYiApID49IDAgOlxuXHRcdFx0YXJlYSggYSwgYiwgYS5wcmV2ICkgPCAwIHx8IGFyZWEoIGEsIGEubmV4dCwgYiApIDwgMDtcblxuXHR9XG5cblx0Ly8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5cblx0ZnVuY3Rpb24gbWlkZGxlSW5zaWRlKCBhLCBiICkge1xuXG5cdFx0dmFyIHAgPSBhLFxuXHRcdFx0aW5zaWRlID0gZmFsc2UsXG5cdFx0XHRweCA9ICggYS54ICsgYi54ICkgLyAyLFxuXHRcdFx0cHkgPSAoIGEueSArIGIueSApIC8gMjtcblxuXHRcdGRvIHtcblxuXHRcdFx0aWYgKCAoICggcC55ID4gcHkgKSAhPT0gKCBwLm5leHQueSA+IHB5ICkgKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXG5cdFx0XHRcdFx0XHRcdCggcHggPCAoIHAubmV4dC54IC0gcC54ICkgKiAoIHB5IC0gcC55ICkgLyAoIHAubmV4dC55IC0gcC55ICkgKyBwLnggKSApIHtcblxuXHRcdFx0XHRpbnNpZGUgPSAhIGluc2lkZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwID0gcC5uZXh0O1xuXG5cdFx0fSB3aGlsZSAoIHAgIT09IGEgKTtcblxuXHRcdHJldHVybiBpbnNpZGU7XG5cblx0fVxuXG5cdC8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcblx0Ly8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5cblx0ZnVuY3Rpb24gc3BsaXRQb2x5Z29uKCBhLCBiICkge1xuXG5cdFx0dmFyIGEyID0gbmV3IE5vZGUoIGEuaSwgYS54LCBhLnkgKSxcblx0XHRcdGIyID0gbmV3IE5vZGUoIGIuaSwgYi54LCBiLnkgKSxcblx0XHRcdGFuID0gYS5uZXh0LFxuXHRcdFx0YnAgPSBiLnByZXY7XG5cblx0XHRhLm5leHQgPSBiO1xuXHRcdGIucHJldiA9IGE7XG5cblx0XHRhMi5uZXh0ID0gYW47XG5cdFx0YW4ucHJldiA9IGEyO1xuXG5cdFx0YjIubmV4dCA9IGEyO1xuXHRcdGEyLnByZXYgPSBiMjtcblxuXHRcdGJwLm5leHQgPSBiMjtcblx0XHRiMi5wcmV2ID0gYnA7XG5cblx0XHRyZXR1cm4gYjI7XG5cblx0fVxuXG5cdC8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZSggaSwgeCwgeSwgbGFzdCApIHtcblxuXHRcdHZhciBwID0gbmV3IE5vZGUoIGksIHgsIHkgKTtcblxuXHRcdGlmICggISBsYXN0ICkge1xuXG5cdFx0XHRwLnByZXYgPSBwO1xuXHRcdFx0cC5uZXh0ID0gcDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHAubmV4dCA9IGxhc3QubmV4dDtcblx0XHRcdHAucHJldiA9IGxhc3Q7XG5cdFx0XHRsYXN0Lm5leHQucHJldiA9IHA7XG5cdFx0XHRsYXN0Lm5leHQgPSBwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHA7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGUoIHAgKSB7XG5cblx0XHRwLm5leHQucHJldiA9IHAucHJldjtcblx0XHRwLnByZXYubmV4dCA9IHAubmV4dDtcblxuXHRcdGlmICggcC5wcmV2WiApIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuXHRcdGlmICggcC5uZXh0WiApIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBOb2RlKCBpLCB4LCB5ICkge1xuXG5cdFx0Ly8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuXHRcdHRoaXMuaSA9IGk7XG5cblx0XHQvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblx0XHQvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXG5cdFx0Ly8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuXHRcdHRoaXMueiA9IG51bGw7XG5cblx0XHQvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG5cdFx0dGhpcy5wcmV2WiA9IG51bGw7XG5cdFx0dGhpcy5uZXh0WiA9IG51bGw7XG5cblx0XHQvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuXHRcdHRoaXMuc3RlaW5lciA9IGZhbHNlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSB7XG5cblx0XHR2YXIgc3VtID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltICkge1xuXG5cdFx0XHRzdW0gKz0gKCBkYXRhWyBqIF0gLSBkYXRhWyBpIF0gKSAqICggZGF0YVsgaSArIDEgXSArIGRhdGFbIGogKyAxIF0gKTtcblx0XHRcdGogPSBpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1bTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICovXG5cblx0dmFyIFNoYXBlVXRpbHMgPSB7XG5cblx0XHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cblx0XHRhcmVhOiBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XG5cblx0XHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cdFx0XHR2YXIgYSA9IDAuMDtcblxuXHRcdFx0Zm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcblxuXHRcdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhICogMC41O1xuXG5cdFx0fSxcblxuXHRcdGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcblxuXHRcdFx0cmV0dXJuIFNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xuXG5cdFx0fSxcblxuXHRcdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxuXHRcdFx0dmFyIGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xuXHRcdFx0dmFyIGZhY2VzID0gW107IC8vIGZpbmFsIGFycmF5IG9mIHZlcnRleCBpbmRpY2VzIGxpa2UgWyBbIGEsYixkIF0sIFsgYixjLGQgXSBdXG5cblx0XHRcdHJlbW92ZUR1cEVuZFB0cyggY29udG91ciApO1xuXHRcdFx0YWRkQ29udG91ciggdmVydGljZXMsIGNvbnRvdXIgKTtcblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIGhvbGVJbmRleCA9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0XHRob2xlcy5mb3JFYWNoKCByZW1vdmVEdXBFbmRQdHMgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGhvbGVJbmRpY2VzLnB1c2goIGhvbGVJbmRleCApO1xuXHRcdFx0XHRob2xlSW5kZXggKz0gaG9sZXNbIGkgXS5sZW5ndGg7XG5cdFx0XHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBob2xlc1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIHRyaWFuZ2xlcyA9IEVhcmN1dC50cmlhbmd1bGF0ZSggdmVydGljZXMsIGhvbGVJbmRpY2VzICk7XG5cblx0XHRcdC8vXG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRmYWNlcy5wdXNoKCB0cmlhbmdsZXMuc2xpY2UoIGksIGkgKyAzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjZXM7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMoIHBvaW50cyApIHtcblxuXHRcdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICggbCA+IDIgJiYgcG9pbnRzWyBsIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcblxuXHRcdFx0cG9pbnRzLnBvcCgpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueCApO1xuXHRcdFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICpcblx0ICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICpcblx0ICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcblx0ICogIHN0ZXBzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBmb3Igei1zaWRlIGV4dHJ1c2lvbnMgLyB1c2VkIGZvciBzdWJkaXZpZGluZyBzZWdtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cblx0ICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG5cdCAqXG5cdCAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuXHQgKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcblx0ICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcblx0ICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXG5cdCAqXG5cdCAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXG5cdCAqICBmcmFtZXM6IDxPYmplY3Q+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcblx0ICpcblx0ICogIFVWR2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG5cdCAqXG5cdCAqIH1cblx0ICovXG5cblx0Ly8gRXh0cnVkZUdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gRXh0cnVkZUdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHNoYXBlczogc2hhcGVzLFxuXHRcdFx0b3B0aW9uczogb3B0aW9uc1xuXHRcdH07XG5cblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBvcHRpb25zICkgKTtcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9XG5cblx0RXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXh0cnVkZUdlb21ldHJ5O1xuXG5cdC8vIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XG5cblx0XHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cblx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHQvLyBjYW4ndCByZWFsbHkgdXNlIGF1dG9tYXRpYyB2ZXJ0ZXggbm9ybWFsc1xuXHRcdC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xuXHRcdC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcblxuXHRcdC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XG5cblx0fVxuXG5cdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTtcblxuXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmdldEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCBcInBvc2l0aW9uXCIgKTtcblx0XHR2YXIgdmVydGljZXNBcnJheSA9IHBvc2l0aW9uQXR0cmlidXRlID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHBvc2l0aW9uQXR0cmlidXRlLmFycmF5ICkgOiBbXTtcblxuXHRcdHZhciB1dkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCBcInV2XCIgKTtcblx0XHR2YXIgdXZBcnJheSA9IHV2QXR0cmlidXRlID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHV2QXR0cmlidXRlLmFycmF5ICkgOiBbXTtcblxuXHRcdHZhciBJbmRleEF0dHJpYnV0ZSA9IHRoaXMuaW5kZXg7XG5cdFx0dmFyIGluZGljZXNBcnJheSA9IEluZGV4QXR0cmlidXRlID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIEluZGV4QXR0cmlidXRlLmFycmF5ICkgOiBbXTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRwb3NpdGlvbjogdmVydGljZXNBcnJheSxcblx0XHRcdHV2OiB1dkFycmF5LFxuXHRcdFx0aW5kZXg6IGluZGljZXNBcnJheVxuXHRcdH07XG5cblx0fTtcblxuXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdFx0dmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcblx0XHRvcHRpb25zLmFycmF5cyA9IHRoaXMuZ2V0QXJyYXlzKCk7XG5cblx0XHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcblxuXHRcdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG5cdFx0XHR0aGlzLmFkZFNoYXBlKCBzaGFwZSwgb3B0aW9ucyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRJbmRleCggb3B0aW9ucy5hcnJheXMuaW5kZXggKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG9wdGlvbnMuYXJyYXlzLnBvc2l0aW9uLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG9wdGlvbnMuYXJyYXlzLnV2LCAyICkgKTtcblxuXHR9O1xuXG5cdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG5cdFx0dmFyIGFycmF5cyA9IG9wdGlvbnMuYXJyYXlzID8gb3B0aW9ucy5hcnJheXMgOiB0aGlzLmdldEFycmF5cygpO1xuXHRcdHZhciB2ZXJ0aWNlc0FycmF5ID0gYXJyYXlzLnBvc2l0aW9uO1xuXHRcdHZhciBpbmRpY2VzQXJyYXkgPSBhcnJheXMuaW5kZXg7XG5cdFx0dmFyIHV2QXJyYXkgPSBhcnJheXMudXY7XG5cblx0XHR2YXIgcGxhY2Vob2xkZXIgPSBbXTtcblxuXG5cdFx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcblxuXHRcdHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxuXHRcdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcblx0XHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblxuXHRcdHZhciBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlOyAvLyBmYWxzZVxuXG5cdFx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXG5cdFx0dmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XG5cblx0XHR2YXIgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXHRcdHZhciBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XG5cblx0XHQvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cblx0XHR2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XG5cblx0XHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuXHRcdGlmICggZXh0cnVkZVBhdGggKSB7XG5cblx0XHRcdGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XG5cblx0XHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuXHRcdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxuXG5cdFx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXG5cblx0XHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cblx0XHRcdHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBleHRydWRlUGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCBzdGVwcywgZmFsc2UgKTtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XG5cblx0XHRcdGJpbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRwb3NpdGlvbjIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0XHRpZiAoICEgYmV2ZWxFbmFibGVkICkge1xuXG5cdFx0XHRiZXZlbFNlZ21lbnRzID0gMDtcblx0XHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRcdGJldmVsU2l6ZSA9IDA7XG5cblx0XHR9XG5cblx0XHQvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cblxuXHRcdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdFx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cblx0XHR2YXIgcmV2ZXJzZSA9ICEgU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuXHRcdGlmICggcmV2ZXJzZSApIHtcblxuXHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XG5cblx0XHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cblx0XHR2YXIgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG5cdFx0LyogVmVydGljZXMgKi9cblxuXHRcdHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcblxuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gc2NhbGVQdDIoIHB0LCB2ZWMsIHNpemUgKSB7XG5cblx0XHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcblxuXHRcdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGIsIGJzLCB0LCB6LFxuXHRcdFx0dmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcblx0XHRcdGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XG5cblxuXHRcdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG5cdFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG5cdFx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXG5cdFx0XHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG5cdFx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcblx0XHRcdC8vXG5cdFx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuXHRcdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuXHRcdFx0dmFyIHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnk7IC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuXHRcdFx0Ly8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxuXHRcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuXHRcdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsXG5cdFx0XHRcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0XHR2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcblx0XHRcdFx0dl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcblxuXHRcdFx0dmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcblxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuXHRcdFx0dmFyIGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcblxuXHRcdFx0XHQvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcblxuXHRcdFx0XHR2YXIgdl9wcmV2X2xlbiA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cdFx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG5cdFx0XHRcdC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcblxuXHRcdFx0XHR2YXIgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcblx0XHRcdFx0dmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XG5cblx0XHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XG5cdFx0XHRcdHZhciBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xuXG5cdFx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdFx0dmFyIHNmID0gKCAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXG5cdFx0XHRcdFx0XHQoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCApIC9cblx0XHRcdFx0XHQoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XG5cblx0XHRcdFx0Ly8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG5cdFx0XHRcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuXHRcdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHRcdHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcblx0XHRcdFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcblxuXHRcdFx0XHR2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7IC8vIGFzc3VtZXM6IG9wcG9zaXRlXG5cdFx0XHRcdGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRpcmVjdGlvbl9lcSApIHtcblxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG5cdFx0XHRcdFx0dl90cmFuc194ID0gLSB2X3ByZXZfeTtcblx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeDtcblx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuXHRcdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xuXHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xuXHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XG5cblx0XHR9XG5cblxuXHRcdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG5cdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG5cdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG5cdFx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcblx0XHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xuXG5cdFx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXG5cdFx0XHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuXHRcdFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdFx0eiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xuXHRcdFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XG5cblx0XHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGJzID0gYmV2ZWxTaXplO1xuXG5cdFx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuXHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxuXHRcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuXHRcdHZhciBzO1xuXG5cdFx0Zm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XG5cblx0XHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG5cdFx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuXHRcdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXHRcdGZvciAoIGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xuXG5cdFx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XG5cdFx0XHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKTtcblxuXHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50ICsgeiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGV4cGFuZCBob2xlc1xuXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCArIHogKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8qIEZhY2VzICovXG5cblx0XHQvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xuXG5cdFx0YnVpbGRMaWRGYWNlcygpO1xuXG5cdFx0Ly8gU2lkZXMgZmFjZXNcblxuXHRcdGJ1aWxkU2lkZUZhY2VzKCk7XG5cblxuXHRcdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cblx0XHRcdHZhciBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblxuXHRcdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG5cdFx0XHRcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xuXHRcdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgb3B0aW9ucy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXRlcmlhbCA6IDAgKTtcblxuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcblx0XHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XG5cblx0XHRcdFx0Ly8sIHRydWVcblx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgb3B0aW9ucy5leHRydWRlTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cnVkZU1hdGVyaWFsIDogMSApO1xuXG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG5cdFx0XHR2YXIgaiwgaztcblx0XHRcdGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XG5cblx0XHRcdFx0aiA9IGk7XG5cdFx0XHRcdGsgPSBpIC0gMTtcblx0XHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XG5cblx0XHRcdFx0dmFyIHMgPSAwLFxuXHRcdFx0XHRcdHNsID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcblxuXHRcdFx0XHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHNsZW4xID0gdmxlbiAqIHM7XG5cdFx0XHRcdFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcblxuXHRcdFx0XHRcdHZhciBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXG5cdFx0XHRcdFx0XHRkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XG5cblx0XHRcdFx0XHRmNCggYSwgYiwgYywgZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcblxuXHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeCApO1xuXHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeSApO1xuXHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeiApO1xuXG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuXHRcdFx0YWRkVmVydGV4KCBhICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcblx0XHRcdGFkZFZlcnRleCggYyApO1xuXG5cdFx0XHR2YXIgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XG5cblx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xuXHRcdFx0YWRkVVYoIHV2c1sgMSBdICk7XG5cdFx0XHRhZGRVViggdXZzWyAyIF0gKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkICkge1xuXG5cdFx0XHRhZGRWZXJ0ZXgoIGEgKTtcblx0XHRcdGFkZFZlcnRleCggYiApO1xuXHRcdFx0YWRkVmVydGV4KCBkICk7XG5cblx0XHRcdGFkZFZlcnRleCggYiApO1xuXHRcdFx0YWRkVmVydGV4KCBjICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcblxuXG5cdFx0XHR2YXIgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDYsIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcblxuXHRcdFx0YWRkVVYoIHV2c1sgMCBdICk7XG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xuXG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xuXHRcdFx0YWRkVVYoIHV2c1sgMyBdICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoIGluZGV4ICkge1xuXG5cdFx0XHRpbmRpY2VzQXJyYXkucHVzaCggdmVydGljZXNBcnJheS5sZW5ndGggLyAzICk7XG5cdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAwIF0gKTtcblx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDEgXSApO1xuXHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMiBdICk7XG5cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIGFkZFVWKCB2ZWN0b3IyICkge1xuXG5cdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueCApO1xuXHRcdFx0dXZBcnJheS5wdXNoKCB2ZWN0b3IyLnkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggISBvcHRpb25zLmFycmF5cyApIHtcblxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlc0FycmF5ICk7XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzQXJyYXksIDMgKSApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkFycmF5LCAyICkgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xuXG5cdFx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cblx0XHRcdHZhciBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xuXHRcdFx0dmFyIGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xuXHRcdFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XG5cdFx0XHR2YXIgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XG5cdFx0XHR2YXIgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcblx0XHRcdHZhciBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgYV95ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIGJfeSApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggY194LCBjX3kgKVxuXHRcdFx0XTtcblxuXHRcdH0sXG5cblx0XHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XG5cblx0XHRcdHZhciBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xuXHRcdFx0dmFyIGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xuXHRcdFx0dmFyIGFfeiA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMiBdO1xuXHRcdFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XG5cdFx0XHR2YXIgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XG5cdFx0XHR2YXIgYl96ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAyIF07XG5cdFx0XHR2YXIgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcblx0XHRcdHZhciBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcblx0XHRcdHZhciBjX3ogPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDIgXTtcblx0XHRcdHZhciBkX3ggPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyBdO1xuXHRcdFx0dmFyIGRfeSA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMSBdO1xuXHRcdFx0dmFyIGRfeiA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMiBdO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBhX3kgLSBiX3kgKSA8IDAuMDEgKSB7XG5cblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRuZXcgVmVjdG9yMiggYV94LCAxIC0gYV96ICksXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoIGJfeCwgMSAtIGJfeiApLFxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIDEgLSBjX3ogKSxcblx0XHRcdFx0XHRuZXcgVmVjdG9yMiggZF94LCAxIC0gZF96IClcblx0XHRcdFx0XTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCBhX3ksIDEgLSBhX3ogKSxcblx0XHRcdFx0XHRuZXcgVmVjdG9yMiggYl95LCAxIC0gYl96ICksXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeSwgMSAtIGNfeiApLFxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCBkX3ksIDEgLSBkX3ogKVxuXHRcdFx0XHRdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogVGV4dCA9IDNEIFRleHRcblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGZvbnQ6IDxUSFJFRS5Gb250PiwgLy8gZm9udFxuXHQgKlxuXHQgKiAgc2l6ZTogPGZsb2F0PiwgLy8gc2l6ZSBvZiB0aGUgdGV4dFxuXHQgKiAgaGVpZ2h0OiA8ZmxvYXQ+LCAvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XG5cdCAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG5cdCAqXG5cdCAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuXHQgKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXG5cdCAqICBiZXZlbFNpemU6IDxmbG9hdD4gLy8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxuXHQgKiB9XG5cdCAqL1xuXG5cdC8vIFRleHRHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFRleHRHZW9tZXRyeSggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0dGV4dDogdGV4dCxcblx0XHRcdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnNcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUZXh0QnVmZmVyR2VvbWV0cnkoIHRleHQsIHBhcmFtZXRlcnMgKSApO1xuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG5cdH1cblxuXHRUZXh0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRleHRHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0R2VvbWV0cnk7XG5cblx0Ly8gVGV4dEJ1ZmZlckdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gVGV4dEJ1ZmZlckdlb21ldHJ5KCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cblx0XHR2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udDtcblxuXHRcdGlmICggISAoIGZvbnQgJiYgZm9udC5pc0ZvbnQgKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRleHRHZW9tZXRyeTogZm9udCBwYXJhbWV0ZXIgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkZvbnQuJyApO1xuXHRcdFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHNoYXBlcyA9IGZvbnQuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMuc2l6ZSwgcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICk7XG5cblx0XHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXG5cblx0XHRwYXJhbWV0ZXJzLmFtb3VudCA9IHBhcmFtZXRlcnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmhlaWdodCA6IDUwO1xuXG5cdFx0Ly8gZGVmYXVsdHNcblxuXHRcdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xuXHRcdGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcblx0XHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHNoYXBlcywgcGFyYW1ldGVycyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1RleHRCdWZmZXJHZW9tZXRyeSc7XG5cblx0fVxuXG5cdFRleHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFRleHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0QnVmZmVyR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKi9cblxuXHQvLyBTcGhlcmVHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBTcGhlcmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG5cdH1cblxuXHRTcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0U3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlR2VvbWV0cnk7XG5cblx0Ly8gU3BoZXJlQnVmZmVyR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBTcGhlcmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xuXG5cdFx0cGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xuXHRcdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cblx0XHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG5cdFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xuXG5cdFx0dmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xuXG5cdFx0dmFyIGl4LCBpeTtcblxuXHRcdHZhciBpbmRleCA9IDA7XG5cdFx0dmFyIGdyaWQgPSBbXTtcblxuXHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdHZhciB1dnMgPSBbXTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGljZXNSb3cgPSBbXTtcblxuXHRcdFx0dmFyIHYgPSBpeSAvIGhlaWdodFNlZ21lbnRzO1xuXG5cdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciB1ID0gaXggLyB3aWR0aFNlZ21lbnRzO1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRleC54ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFsLnNldCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2cy5wdXNoKCB1LCAxIC0gdiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JpZC5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggaXkgPSAwOyBpeSA8IGhlaWdodFNlZ21lbnRzOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciBhID0gZ3JpZFsgaXkgXVsgaXggKyAxIF07XG5cdFx0XHRcdHZhciBiID0gZ3JpZFsgaXkgXVsgaXggXTtcblx0XHRcdFx0dmFyIGMgPSBncmlkWyBpeSArIDEgXVsgaXggXTtcblx0XHRcdFx0dmFyIGQgPSBncmlkWyBpeSArIDEgXVsgaXggKyAxIF07XG5cblx0XHRcdFx0aWYgKCBpeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpZiAoIGl5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJICkgaW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRTcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0U3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlQnVmZmVyR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgS2FsZWIgTXVycGh5XG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqL1xuXG5cdC8vIFJpbmdHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFJpbmdHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcblx0XHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXG5cdFx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUmluZ0J1ZmZlckdlb21ldHJ5KCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0fVxuXG5cdFJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0UmluZ0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdHZW9tZXRyeTtcblxuXHQvLyBSaW5nQnVmZmVyR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBSaW5nQnVmZmVyR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1JpbmdCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuXHRcdFx0cGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IDAuNTtcblx0XHRvdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIHx8IDE7XG5cblx0XHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG5cdFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcblxuXHRcdHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcblx0XHRwaGlTZWdtZW50cyA9IHBoaVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKSA6IDE7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0dmFyIHV2cyA9IFtdO1xuXG5cdFx0Ly8gc29tZSBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHR2YXIgc2VnbWVudDtcblx0XHR2YXIgcmFkaXVzID0gaW5uZXJSYWRpdXM7XG5cdFx0dmFyIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcblx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdHZhciBqLCBpO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggaiA9IDA7IGogPD0gcGhpU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gdmFsdWVzIGFyZSBnZW5lcmF0ZSBmcm9tIHRoZSBpbnNpZGUgb2YgdGhlIHJpbmcgdG8gdGhlIG91dHNpZGVcblxuXHRcdFx0XHRzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXYueCA9ICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XG5cdFx0XHRcdHV2LnkgPSAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcblxuXHRcdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IHBoaVNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHR2YXIgdGhldGFTZWdtZW50TGV2ZWwgPSBqICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0c2VnbWVudCA9IGkgKyB0aGV0YVNlZ21lbnRMZXZlbDtcblxuXHRcdFx0XHR2YXIgYSA9IHNlZ21lbnQ7XG5cdFx0XHRcdHZhciBiID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuXHRcdFx0XHR2YXIgYyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblx0XHRcdFx0dmFyIGQgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdFJpbmdCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0UmluZ0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdCdWZmZXJHZW9tZXRyeTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKi9cblxuXHQvLyBMYXRoZUdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gTGF0aGVHZW9tZXRyeSggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHBvaW50czogcG9pbnRzLFxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcblx0XHR9O1xuXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBMYXRoZUJ1ZmZlckdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkgKTtcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9XG5cblx0TGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0TGF0aGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXRoZUdlb21ldHJ5O1xuXG5cdC8vIExhdGhlQnVmZmVyR2VvbWV0cnlcblxuXHRmdW5jdGlvbiBMYXRoZUJ1ZmZlckdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0xhdGhlQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cG9pbnRzOiBwb2ludHMsXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxuXHRcdH07XG5cblx0XHRzZWdtZW50cyA9IE1hdGguZmxvb3IoIHNlZ21lbnRzICkgfHwgMTI7XG5cdFx0cGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xuXHRcdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCBNYXRoLlBJICogMjtcblxuXHRcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cblxuXHRcdHBoaUxlbmd0aCA9IF9NYXRoLmNsYW1wKCBwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyICk7XG5cblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdHZhciBpbmRpY2VzID0gW107XG5cdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0dmFyIHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0dmFyIGJhc2U7XG5cdFx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0dmFyIGksIGo7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcyBhbmQgdXZzXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcblxuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKCBwaGkgKTtcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyggcGhpICk7XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHBvaW50c1sgaiBdLnggKiBzaW47XG5cdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcblx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2LnggPSBpIC8gc2VnbWVudHM7XG5cdFx0XHRcdHV2LnkgPSBqIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPCAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XG5cblx0XHRcdFx0YmFzZSA9IGogKyBpICogcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0XHR2YXIgYSA9IGJhc2U7XG5cdFx0XHRcdHZhciBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XG5cdFx0XHRcdHZhciBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xuXHRcdFx0XHR2YXIgZCA9IGJhc2UgKyAxO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdC8vIGdlbmVyYXRlIG5vcm1hbHNcblxuXHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIHdlIG5lZWQgdG8gYXZlcmFnZSB0aGUgbm9ybWFscyBhbG9uZyB0aGUgc2VhbS5cblx0XHQvLyBiZWNhdXNlIHRoZSBjb3JyZXNwb25kaW5nIHZlcnRpY2VzIGFyZSBpZGVudGljYWwgKGJ1dCBzdGlsbCBoYXZlIGRpZmZlcmVudCBVVnMpLlxuXG5cdFx0aWYgKCBwaGlMZW5ndGggPT09IE1hdGguUEkgKiAyICkge1xuXG5cdFx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cdFx0XHR2YXIgbjEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIG4yID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBuID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gdGhpcyBpcyB0aGUgYnVmZmVyIG9mZnNldCBmb3IgdGhlIGxhc3QgbGluZSBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRiYXNlID0gc2VnbWVudHMgKiBwb2ludHMubGVuZ3RoICogMztcblxuXHRcdFx0Zm9yICggaSA9IDAsIGogPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKywgaiArPSAzICkge1xuXG5cdFx0XHRcdC8vIHNlbGVjdCB0aGUgbm9ybWFsIG9mIHRoZSB2ZXJ0ZXggaW4gdGhlIGZpcnN0IGxpbmVcblxuXHRcdFx0XHRuMS54ID0gbm9ybWFsc1sgaiArIDAgXTtcblx0XHRcdFx0bjEueSA9IG5vcm1hbHNbIGogKyAxIF07XG5cdFx0XHRcdG4xLnogPSBub3JtYWxzWyBqICsgMiBdO1xuXG5cdFx0XHRcdC8vIHNlbGVjdCB0aGUgbm9ybWFsIG9mIHRoZSB2ZXJ0ZXggaW4gdGhlIGxhc3QgbGluZVxuXG5cdFx0XHRcdG4yLnggPSBub3JtYWxzWyBiYXNlICsgaiArIDAgXTtcblx0XHRcdFx0bjIueSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMSBdO1xuXHRcdFx0XHRuMi56ID0gbm9ybWFsc1sgYmFzZSArIGogKyAyIF07XG5cblx0XHRcdFx0Ly8gYXZlcmFnZSBub3JtYWxzXG5cblx0XHRcdFx0bi5hZGRWZWN0b3JzKCBuMSwgbjIgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHQvLyBhc3NpZ24gdGhlIG5ldyB2YWx1ZXMgdG8gYm90aCBub3JtYWxzXG5cblx0XHRcdFx0bm9ybWFsc1sgaiArIDAgXSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMCBdID0gbi54O1xuXHRcdFx0XHRub3JtYWxzWyBqICsgMSBdID0gbm9ybWFsc1sgYmFzZSArIGogKyAxIF0gPSBuLnk7XG5cdFx0XHRcdG5vcm1hbHNbIGogKyAyIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDIgXSA9IG4uejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRMYXRoZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRMYXRoZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhdGhlQnVmZmVyR2VvbWV0cnk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKi9cblxuXHQvLyBTaGFwZUdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gU2hhcGVHZW9tZXRyeSggc2hhcGVzLCBjdXJ2ZVNlZ21lbnRzICkge1xuXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG5cdFx0aWYgKCB0eXBlb2YgY3VydmVTZWdtZW50cyA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlR2VvbWV0cnk6IE9wdGlvbnMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0XHRjdXJ2ZVNlZ21lbnRzID0gY3VydmVTZWdtZW50cy5jdXJ2ZVNlZ21lbnRzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRjdXJ2ZVNlZ21lbnRzOiBjdXJ2ZVNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgU2hhcGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBjdXJ2ZVNlZ21lbnRzICkgKTtcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuXHR9XG5cblx0U2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0U2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFwZUdlb21ldHJ5O1xuXG5cdFNoYXBlR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkYXRhID0gR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XG5cblx0XHR2YXIgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcblxuXHRcdHJldHVybiB0b0pTT04oIHNoYXBlcywgZGF0YSApO1xuXG5cdH07XG5cblx0Ly8gU2hhcGVCdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIFNoYXBlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgY3VydmVTZWdtZW50cyApIHtcblxuXHRcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTaGFwZUJ1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHNoYXBlczogc2hhcGVzLFxuXHRcdFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xuXHRcdH07XG5cblx0XHRjdXJ2ZVNlZ21lbnRzID0gY3VydmVTZWdtZW50cyB8fCAxMjtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdHZhciBpbmRpY2VzID0gW107XG5cdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHR2YXIgdXZzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHR2YXIgZ3JvdXBTdGFydCA9IDA7XG5cdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0Ly8gYWxsb3cgc2luZ2xlIGFuZCBhcnJheSB2YWx1ZXMgZm9yIFwic2hhcGVzXCIgcGFyYW1ldGVyXG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0YWRkU2hhcGUoIHNoYXBlcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2hhcGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRhZGRTaGFwZSggc2hhcGVzWyBpIF0gKTtcblxuXHRcdFx0XHR0aGlzLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCBpICk7IC8vIGVuYWJsZXMgTXVsdGlNYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXHRcdFx0XHRncm91cENvdW50ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblxuXHRcdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGFkZFNoYXBlKCBzaGFwZSApIHtcblxuXHRcdFx0dmFyIGksIGwsIHNoYXBlSG9sZTtcblxuXHRcdFx0dmFyIGluZGV4T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdHZhciBwb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0XHRcdHZhciBzaGFwZVZlcnRpY2VzID0gcG9pbnRzLnNoYXBlO1xuXHRcdFx0dmFyIHNoYXBlSG9sZXMgPSBwb2ludHMuaG9sZXM7XG5cblx0XHRcdC8vIGNoZWNrIGRpcmVjdGlvbiBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlVmVydGljZXMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMucmV2ZXJzZSgpO1xuXG5cdFx0XHRcdC8vIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVIb2xlICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdHNoYXBlSG9sZXNbIGkgXSA9IHNoYXBlSG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggc2hhcGVWZXJ0aWNlcywgc2hhcGVIb2xlcyApO1xuXG5cdFx0XHQvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRzaGFwZUhvbGUgPSBzaGFwZUhvbGVzWyBpIF07XG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLmNvbmNhdCggc2hhcGVIb2xlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gdmVydGljZXMsIG5vcm1hbHMsIHV2c1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4ID0gc2hhcGVWZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgMCApO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblx0XHRcdFx0dXZzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSApOyAvLyB3b3JsZCB1dnNcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbmNpZGVzXG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0dmFyIGEgPSBmYWNlWyAwIF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0dmFyIGIgPSBmYWNlWyAxIF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0dmFyIGMgPSBmYWNlWyAyIF0gKyBpbmRleE9mZnNldDtcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGMgKTtcblx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdFNoYXBlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdFNoYXBlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVCdWZmZXJHZW9tZXRyeTtcblxuXHRTaGFwZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZGF0YSA9IEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xuXG5cdFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIGRhdGEgKTtcblxuXHR9O1xuXG5cdC8vXG5cblx0ZnVuY3Rpb24gdG9KU09OKCBzaGFwZXMsIGRhdGEgKSB7XG5cblx0XHRkYXRhLnNoYXBlcyA9IFtdO1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBpIF07XG5cblx0XHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICovXG5cblx0ZnVuY3Rpb24gRWRnZXNHZW9tZXRyeSggZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICkge1xuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0VkZ2VzR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0dGhyZXNob2xkQW5nbGU6IHRocmVzaG9sZEFuZ2xlXG5cdFx0fTtcblxuXHRcdHRocmVzaG9sZEFuZ2xlID0gKCB0aHJlc2hvbGRBbmdsZSAhPT0gdW5kZWZpbmVkICkgPyB0aHJlc2hvbGRBbmdsZSA6IDE7XG5cblx0XHQvLyBidWZmZXJcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0dmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKCBfTWF0aC5ERUcyUkFEICogdGhyZXNob2xkQW5nbGUgKTtcblx0XHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBlZGdlcyA9IHt9LCBlZGdlMSwgZWRnZTI7XG5cdFx0dmFyIGtleSwga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG5cdFx0Ly8gcHJlcGFyZSBzb3VyY2UgZ2VvbWV0cnlcblxuXHRcdHZhciBnZW9tZXRyeTI7XG5cblx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdGdlb21ldHJ5MiA9IG5ldyBHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkyLmZyb21CdWZmZXJHZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xuXHRcdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHRcdHZhciBzb3VyY2VWZXJ0aWNlcyA9IGdlb21ldHJ5Mi52ZXJ0aWNlcztcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XG5cblx0XHQvLyBub3cgY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgd2hlcmUgZWFjaCBlbnRyeSByZXByZXNlbnRzIGFuIGVkZ2Ugd2l0aCBpdHMgYWRqb2luaW5nIGZhY2VzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0ZWRnZTEgPSBmYWNlWyBrZXlzWyBqIF0gXTtcblx0XHRcdFx0ZWRnZTIgPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcblx0XHRcdFx0ZWRnZVsgMCBdID0gTWF0aC5taW4oIGVkZ2UxLCBlZGdlMiApO1xuXHRcdFx0XHRlZGdlWyAxIF0gPSBNYXRoLm1heCggZWRnZTEsIGVkZ2UyICk7XG5cblx0XHRcdFx0a2V5ID0gZWRnZVsgMCBdICsgJywnICsgZWRnZVsgMSBdO1xuXG5cdFx0XHRcdGlmICggZWRnZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRlZGdlc1sga2V5IF0gPSB7IGluZGV4MTogZWRnZVsgMCBdLCBpbmRleDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZWRnZXNbIGtleSBdLmZhY2UyID0gaTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXG5cblx0XHRmb3IgKCBrZXkgaW4gZWRnZXMgKSB7XG5cblx0XHRcdHZhciBlID0gZWRnZXNbIGtleSBdO1xuXG5cdFx0XHQvLyBhbiBlZGdlIGlzIG9ubHkgcmVuZGVyZWQgaWYgdGhlIGFuZ2xlIChpbiBkZWdyZWVzKSBiZXR3ZWVuIHRoZSBmYWNlIG5vcm1hbHMgb2YgdGhlIGFkam9pbmluZyBmYWNlcyBleGNlZWRzIHRoaXMgdmFsdWUuIGRlZmF1bHQgPSAxIGRlZ3JlZS5cblxuXHRcdFx0aWYgKCBlLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGUuZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgZS5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4ID0gc291cmNlVmVydGljZXNbIGUuaW5kZXgxIF07XG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHR2ZXJ0ZXggPSBzb3VyY2VWZXJ0aWNlc1sgZS5pbmRleDIgXTtcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cblx0fVxuXG5cdEVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdEVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWRnZXNHZW9tZXRyeTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICovXG5cblx0Ly8gQ3lsaW5kZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIEN5bGluZGVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuXHRcdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0fVxuXG5cdEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3lsaW5kZXJHZW9tZXRyeTtcblxuXHQvLyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N5bGluZGVyQnVmZmVyR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRyYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDE7XG5cdFx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAxO1xuXHRcdGhlaWdodCA9IGhlaWdodCB8fCAxO1xuXG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XG5cblx0XHRvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xuXHRcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMC4wO1xuXHRcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0dmFyIHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0dmFyIGluZGV4ID0gMDtcblx0XHR2YXIgaW5kZXhBcnJheSA9IFtdO1xuXHRcdHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblx0XHR2YXIgZ3JvdXBTdGFydCA9IDA7XG5cblx0XHQvLyBnZW5lcmF0ZSBnZW9tZXRyeVxuXG5cdFx0Z2VuZXJhdGVUb3JzbygpO1xuXG5cdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRpZiAoIHJhZGl1c1RvcCA+IDAgKSBnZW5lcmF0ZUNhcCggdHJ1ZSApO1xuXHRcdFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XG5cblx0XHRcdHZhciB4LCB5O1xuXHRcdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHQvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuXHRcdFx0dmFyIHNsb3BlID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0XHRmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXhSb3cgPSBbXTtcblxuXHRcdFx0XHR2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuXHRcdFx0XHQvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcblxuXHRcdFx0XHR2YXIgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XG5cblx0XHRcdFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0XHRcdHZhciB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XG5cblx0XHRcdFx0XHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblx0XHRcdFx0XHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XG5cdFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRcdG5vcm1hbC5zZXQoIHNpblRoZXRhLCBzbG9wZSwgY29zVGhldGEgKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0XHR1dnMucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdFx0XHRcdC8vIHNhdmUgaW5kZXggb2YgdmVydGV4IGluIHJlc3BlY3RpdmUgcm93XG5cblx0XHRcdFx0XHRpbmRleFJvdy5wdXNoKCBpbmRleCArKyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxuXG5cdFx0XHRcdGluZGV4QXJyYXkucHVzaCggaW5kZXhSb3cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdFx0XHRcdC8vIHdlIHVzZSB0aGUgaW5kZXggYXJyYXkgdG8gYWNjZXNzIHRoZSBjb3JyZWN0IGluZGljZXNcblxuXHRcdFx0XHRcdHZhciBhID0gaW5kZXhBcnJheVsgeSBdWyB4IF07XG5cdFx0XHRcdFx0dmFyIGIgPSBpbmRleEFycmF5WyB5ICsgMSBdWyB4IF07XG5cdFx0XHRcdFx0dmFyIGMgPSBpbmRleEFycmF5WyB5ICsgMSBdWyB4ICsgMSBdO1xuXHRcdFx0XHRcdHZhciBkID0gaW5kZXhBcnJheVsgeSBdWyB4ICsgMSBdO1xuXG5cdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGdyb3VwIGNvdW50ZXJcblxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDAgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKCB0b3AgKSB7XG5cblx0XHRcdHZhciB4LCBjZW50ZXJJbmRleFN0YXJ0LCBjZW50ZXJJbmRleEVuZDtcblxuXHRcdFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR2YXIgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdHZhciByYWRpdXMgPSAoIHRvcCA9PT0gdHJ1ZSApID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xuXHRcdFx0dmFyIHNpZ24gPSAoIHRvcCA9PT0gdHJ1ZSApID8gMSA6IC0gMTtcblxuXHRcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNlbnRlciB2ZXJ0ZXhcblx0XHRcdGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcblxuXHRcdFx0Ly8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG5cdFx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cblx0XHRcdGZvciAoIHggPSAxOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIGhhbGZIZWlnaHQgKiBzaWduLCAwICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCBzaWduLCAwICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1dnMucHVzaCggMC41LCAwLjUgKTtcblxuXHRcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuXG5cdFx0XHRcdGluZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcblxuXHRcdFx0Y2VudGVySW5kZXhFbmQgPSBpbmRleDtcblxuXHRcdFx0Ly8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXHRcdFx0XHR2YXIgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xuXG5cdFx0XHRcdHZhciBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdFx0XHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IGhhbGZIZWlnaHQgKiBzaWduO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCBzaWduLCAwICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1di54ID0gKCBjb3NUaGV0YSAqIDAuNSApICsgMC41O1xuXHRcdFx0XHR1di55ID0gKCBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKSArIDAuNTtcblx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuXG5cdFx0XHRcdGluZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHR2YXIgYyA9IGNlbnRlckluZGV4U3RhcnQgKyB4O1xuXHRcdFx0XHR2YXIgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcblxuXHRcdFx0XHRpZiAoIHRvcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIGZhY2UgdG9wXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCBjICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGZhY2UgYm90dG9tXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkgKyAxLCBpLCBjICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdyb3VwQ291bnQgKz0gMztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuXG5cdFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgdG9wID09PSB0cnVlID8gMSA6IDIgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcblxuXHRcdH1cblxuXHR9XG5cblx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXG5cdCAqL1xuXG5cdC8vIENvbmVHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIENvbmVHZW9tZXRyeSggcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRcdEN5bGluZGVyR2VvbWV0cnkuY2FsbCggdGhpcywgMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdFx0fTtcblxuXHR9XG5cblx0Q29uZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cdENvbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lR2VvbWV0cnk7XG5cblx0Ly8gQ29uZUJ1ZmZlckdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gQ29uZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCAwLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ29uZUJ1ZmZlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdH1cblxuXHRDb25lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0Q29uZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVCdWZmZXJHZW9tZXRyeTtcblxuXHQvKipcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqIEBhdXRob3IgaHVnaGVzXG5cdCAqL1xuXG5cdC8vIENpcmNsZUdlb21ldHJ5XG5cblx0ZnVuY3Rpb24gQ2lyY2xlR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IENpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0fVxuXG5cdENpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXHRDaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGVHZW9tZXRyeTtcblxuXHQvLyBDaXJjbGVCdWZmZXJHZW9tZXRyeVxuXG5cdGZ1bmN0aW9uIENpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cdFx0c2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICkgOiA4O1xuXG5cdFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuXHRcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cblx0XHQvLyBidWZmZXJzXG5cblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0dmFyIHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0dmFyIGksIHM7XG5cdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdC8vIGNlbnRlciBwb2ludFxuXG5cdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXHRcdHV2cy5wdXNoKCAwLjUsIDAuNSApO1xuXG5cdFx0Zm9yICggcyA9IDAsIGkgPSAzOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMgKSB7XG5cblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG5cdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuXHRcdFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblxuXHRcdFx0Ly8gdXZzXG5cblx0XHRcdHV2LnggPSAoIHZlcnRpY2VzWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXHRcdFx0dXYueSA9ICggdmVydGljZXNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdH1cblxuXHRDaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblx0Q2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG5cblxuXG5cdHZhciBHZW9tZXRyaWVzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdFx0V2lyZWZyYW1lR2VvbWV0cnk6IFdpcmVmcmFtZUdlb21ldHJ5LFxuXHRcdFBhcmFtZXRyaWNHZW9tZXRyeTogUGFyYW1ldHJpY0dlb21ldHJ5LFxuXHRcdFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeTogUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5LFxuXHRcdFRldHJhaGVkcm9uR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXG5cdFx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeTogVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSxcblx0XHRPY3RhaGVkcm9uR2VvbWV0cnk6IE9jdGFoZWRyb25HZW9tZXRyeSxcblx0XHRPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSxcblx0XHRJY29zYWhlZHJvbkdlb21ldHJ5OiBJY29zYWhlZHJvbkdlb21ldHJ5LFxuXHRcdEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnksXG5cdFx0RG9kZWNhaGVkcm9uR2VvbWV0cnk6IERvZGVjYWhlZHJvbkdlb21ldHJ5LFxuXHRcdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSxcblx0XHRQb2x5aGVkcm9uR2VvbWV0cnk6IFBvbHloZWRyb25HZW9tZXRyeSxcblx0XHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnk6IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSxcblx0XHRUdWJlR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcblx0XHRUdWJlQnVmZmVyR2VvbWV0cnk6IFR1YmVCdWZmZXJHZW9tZXRyeSxcblx0XHRUb3J1c0tub3RHZW9tZXRyeTogVG9ydXNLbm90R2VvbWV0cnksXG5cdFx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnk6IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LFxuXHRcdFRvcnVzR2VvbWV0cnk6IFRvcnVzR2VvbWV0cnksXG5cdFx0VG9ydXNCdWZmZXJHZW9tZXRyeTogVG9ydXNCdWZmZXJHZW9tZXRyeSxcblx0XHRUZXh0R2VvbWV0cnk6IFRleHRHZW9tZXRyeSxcblx0XHRUZXh0QnVmZmVyR2VvbWV0cnk6IFRleHRCdWZmZXJHZW9tZXRyeSxcblx0XHRTcGhlcmVHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXG5cdFx0U3BoZXJlQnVmZmVyR2VvbWV0cnk6IFNwaGVyZUJ1ZmZlckdlb21ldHJ5LFxuXHRcdFJpbmdHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxuXHRcdFJpbmdCdWZmZXJHZW9tZXRyeTogUmluZ0J1ZmZlckdlb21ldHJ5LFxuXHRcdFBsYW5lR2VvbWV0cnk6IFBsYW5lR2VvbWV0cnksXG5cdFx0UGxhbmVCdWZmZXJHZW9tZXRyeTogUGxhbmVCdWZmZXJHZW9tZXRyeSxcblx0XHRMYXRoZUdlb21ldHJ5OiBMYXRoZUdlb21ldHJ5LFxuXHRcdExhdGhlQnVmZmVyR2VvbWV0cnk6IExhdGhlQnVmZmVyR2VvbWV0cnksXG5cdFx0U2hhcGVHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcblx0XHRTaGFwZUJ1ZmZlckdlb21ldHJ5OiBTaGFwZUJ1ZmZlckdlb21ldHJ5LFxuXHRcdEV4dHJ1ZGVHZW9tZXRyeTogRXh0cnVkZUdlb21ldHJ5LFxuXHRcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTogRXh0cnVkZUJ1ZmZlckdlb21ldHJ5LFxuXHRcdEVkZ2VzR2VvbWV0cnk6IEVkZ2VzR2VvbWV0cnksXG5cdFx0Q29uZUdlb21ldHJ5OiBDb25lR2VvbWV0cnksXG5cdFx0Q29uZUJ1ZmZlckdlb21ldHJ5OiBDb25lQnVmZmVyR2VvbWV0cnksXG5cdFx0Q3lsaW5kZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcblx0XHRDeWxpbmRlckJ1ZmZlckdlb21ldHJ5OiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LFxuXHRcdENpcmNsZUdlb21ldHJ5OiBDaXJjbGVHZW9tZXRyeSxcblx0XHRDaXJjbGVCdWZmZXJHZW9tZXRyeTogQ2lyY2xlQnVmZmVyR2VvbWV0cnksXG5cdFx0Qm94R2VvbWV0cnk6IEJveEdlb21ldHJ5LFxuXHRcdEJveEJ1ZmZlckdlb21ldHJ5OiBCb3hCdWZmZXJHZW9tZXRyeVxuXHR9KTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8VEhSRUUuQ29sb3I+LFxuXHQgKiAgb3BhY2l0eTogPGZsb2F0PlxuXHQgKiB9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFNoYWRvd01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYWRvd01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5saWdodHMgPSB0cnVlO1xuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0U2hhZG93TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdFNoYWRvd01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRvd01hdGVyaWFsO1xuXG5cdFNoYWRvd01hdGVyaWFsLnByb3RvdHlwZS5pc1NoYWRvd01hdGVyaWFsID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gUmF3U2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRTaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xuXG5cdH1cblxuXHRSYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0UmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF3U2hhZGVyTWF0ZXJpYWw7XG5cblx0UmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8aGV4Pixcblx0ICogIHJvdWdobmVzczogPGZsb2F0Pixcblx0ICogIG1ldGFsbmVzczogPGZsb2F0Pixcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqICBlbWlzc2l2ZTogPGhleD4sXG5cdCAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxuXHQgKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcblx0ICpcblx0ICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0Pixcblx0ICpcblx0ICogIHJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIG1ldGFsbmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuXHQgKiAgZW52TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqXG5cdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG5cdCAqXG5cdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcblx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0Pixcblx0ICpcblx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXG5cdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcblx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0ZnVuY3Rpb24gTWVzaFN0YW5kYXJkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXHRcdHRoaXMucm91Z2huZXNzID0gMC41O1xuXHRcdHRoaXMubWV0YWxuZXNzID0gMC41O1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcblxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA9IHRydWU7XG5cblx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnU1RBTkRBUkQnOiAnJyB9O1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XG5cdFx0dGhpcy5tZXRhbG5lc3MgPSBzb3VyY2UubWV0YWxuZXNzO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xuXG5cdFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XG5cblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PlxuXHQgKiB9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIE1lc2hQaHlzaWNhbE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnUEhZU0lDQUwnOiAnJyB9O1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hQaHlzaWNhbE1hdGVyaWFsJztcblxuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMC41OyAvLyBtYXBzIHRvIEYwID0gMC4wNFxuXG5cdFx0dGhpcy5jbGVhckNvYXQgPSAwLjA7XG5cdFx0dGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSAwLjA7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0TWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0TWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ1BIWVNJQ0FMJzogJycgfTtcblxuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblxuXHRcdHRoaXMuY2xlYXJDb2F0ID0gc291cmNlLmNsZWFyQ29hdDtcblx0XHR0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyA9IHNvdXJjZS5jbGVhckNvYXRSb3VnaG5lc3M7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgY29sb3I6IDxoZXg+LFxuXHQgKiAgc3BlY3VsYXI6IDxoZXg+LFxuXHQgKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICpcblx0ICogIGVtaXNzaXZlOiA8aGV4Pixcblx0ICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG5cdCAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqICBidW1wU2NhbGU6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuXHQgKlxuXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcblx0ICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBza2lubmluZzogPGJvb2w+LFxuXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG5cdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIE1lc2hQaG9uZ01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2Vcblx0XHR0aGlzLnNwZWN1bGFyID0gbmV3IENvbG9yKCAweDExMTExMSApO1xuXHRcdHRoaXMuc2hpbmluZXNzID0gMzA7XG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoUGhvbmdNYXRlcmlhbDtcblxuXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGhvbmdNYXRlcmlhbCA9IHRydWU7XG5cblx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuXHRcdHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcblxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XG5cblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHRha2FoaXJveCAvIGh0dHA6Ly9naXRodWIuY29tL3Rha2FoaXJveFxuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgZ3JhZGllbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+IClcblx0ICogfVxuXHQgKi9cblxuXHRmdW5jdGlvbiBNZXNoVG9vbk1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0TWVzaFBob25nTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnVE9PTic6ICcnIH07XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaFRvb25NYXRlcmlhbCc7XG5cblx0XHR0aGlzLmdyYWRpZW50TWFwID0gbnVsbDtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFRvb25NYXRlcmlhbDtcblxuXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5ncmFkaWVudE1hcCA9IHNvdXJjZS5ncmFkaWVudE1hcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKlxuXHQgKiBwYXJhbWV0ZXJzID0ge1xuXHQgKiAgb3BhY2l0eTogPGZsb2F0Pixcblx0ICpcblx0ICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqICBidW1wU2NhbGU6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxuXHQgKlxuXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG5cdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cblx0ICpcblx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXG5cdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcblx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XG5cdCAqIH1cblx0ICovXG5cblx0ZnVuY3Rpb24gTWVzaE5vcm1hbE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcblxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0XHR0aGlzLmZvZyA9IGZhbHNlO1xuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cblx0XHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0TWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xuXG5cdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqXG5cdCAqIHBhcmFtZXRlcnMgPSB7XG5cdCAqICBjb2xvcjogPGhleD4sXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuXHQgKlxuXHQgKiAgZW1pc3NpdmU6IDxoZXg+LFxuXHQgKiAgZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cblx0ICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuXHQgKlxuXHQgKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG5cdCAqXG5cdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcblx0ICpcblx0ICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcblx0ICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuXHQgKlxuXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBza2lubmluZzogPGJvb2w+LFxuXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG5cdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuXHQgKiB9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIE1lc2hMYW1iZXJ0TWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG5cblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cblx0XHR0aGlzLm1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0XHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuXHR9XG5cblx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoTGFtYmVydE1hdGVyaWFsO1xuXG5cdE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaExhbWJlcnRNYXRlcmlhbCA9IHRydWU7XG5cblx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICpcblx0ICogcGFyYW1ldGVycyA9IHtcblx0ICogIGNvbG9yOiA8aGV4Pixcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG5cdCAqXG5cdCAqICBzY2FsZTogPGZsb2F0Pixcblx0ICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxuXHQgKiAgZ2FwU2l6ZTogPGZsb2F0PlxuXHQgKiB9XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIExpbmVEYXNoZWRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuXHRcdExpbmVCYXNpY01hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xuXG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cdFx0dGhpcy5kYXNoU2l6ZSA9IDM7XG5cdFx0dGhpcy5nYXBTaXplID0gMTtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgKTtcblx0TGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVEYXNoZWRNYXRlcmlhbDtcblxuXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcblx0XHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xuXHRcdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXG5cblx0dmFyIE1hdGVyaWFscyA9IE9iamVjdC5mcmVlemUoe1xuXHRcdFNoYWRvd01hdGVyaWFsOiBTaGFkb3dNYXRlcmlhbCxcblx0XHRTcHJpdGVNYXRlcmlhbDogU3ByaXRlTWF0ZXJpYWwsXG5cdFx0UmF3U2hhZGVyTWF0ZXJpYWw6IFJhd1NoYWRlck1hdGVyaWFsLFxuXHRcdFNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCxcblx0XHRQb2ludHNNYXRlcmlhbDogUG9pbnRzTWF0ZXJpYWwsXG5cdFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWw6IE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxuXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiBNZXNoU3RhbmRhcmRNYXRlcmlhbCxcblx0XHRNZXNoUGhvbmdNYXRlcmlhbDogTWVzaFBob25nTWF0ZXJpYWwsXG5cdFx0TWVzaFRvb25NYXRlcmlhbDogTWVzaFRvb25NYXRlcmlhbCxcblx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6IE1lc2hOb3JtYWxNYXRlcmlhbCxcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiBNZXNoTGFtYmVydE1hdGVyaWFsLFxuXHRcdE1lc2hEZXB0aE1hdGVyaWFsOiBNZXNoRGVwdGhNYXRlcmlhbCxcblx0XHRNZXNoRGlzdGFuY2VNYXRlcmlhbDogTWVzaERpc3RhbmNlTWF0ZXJpYWwsXG5cdFx0TWVzaEJhc2ljTWF0ZXJpYWw6IE1lc2hCYXNpY01hdGVyaWFsLFxuXHRcdExpbmVEYXNoZWRNYXRlcmlhbDogTGluZURhc2hlZE1hdGVyaWFsLFxuXHRcdExpbmVCYXNpY01hdGVyaWFsOiBMaW5lQmFzaWNNYXRlcmlhbCxcblx0XHRNYXRlcmlhbDogTWF0ZXJpYWxcblx0fSk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdHZhciBDYWNoZSA9IHtcblxuXHRcdGVuYWJsZWQ6IGZhbHNlLFxuXG5cdFx0ZmlsZXM6IHt9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbiAoIGtleSwgZmlsZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cblx0XHRcdHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcblxuXHRcdH0sXG5cblx0XHRnZXQ6IGZ1bmN0aW9uICgga2V5ICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5maWxlc1sga2V5IF07XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdFx0ZGVsZXRlIHRoaXMuZmlsZXNbIGtleSBdO1xuXG5cdFx0fSxcblxuXHRcdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuZmlsZXMgPSB7fTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBMb2FkaW5nTWFuYWdlciggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBpc0xvYWRpbmcgPSBmYWxzZTtcblx0XHR2YXIgaXRlbXNMb2FkZWQgPSAwO1xuXHRcdHZhciBpdGVtc1RvdGFsID0gMDtcblx0XHR2YXIgdXJsTW9kaWZpZXIgPSB1bmRlZmluZWQ7XG5cblx0XHR0aGlzLm9uU3RhcnQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5vbkxvYWQgPSBvbkxvYWQ7XG5cdFx0dGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcblx0XHR0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuXG5cdFx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdFx0aXRlbXNUb3RhbCArKztcblxuXHRcdFx0aWYgKCBpc0xvYWRpbmcgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGlmICggc2NvcGUub25TdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpc0xvYWRpbmcgPSB0cnVlO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuaXRlbUVuZCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHRpdGVtc0xvYWRlZCArKztcblxuXHRcdFx0aWYgKCBzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUub25Qcm9ncmVzcyggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXRlbXNMb2FkZWQgPT09IGl0ZW1zVG90YWwgKSB7XG5cblx0XHRcdFx0aXNMb2FkaW5nID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHNjb3BlLm9uTG9hZCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHRoaXMuaXRlbUVycm9yID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLm9uRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5yZXNvbHZlVVJMID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRcdGlmICggdXJsTW9kaWZpZXIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHVybE1vZGlmaWVyKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdXJsO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0VVJMTW9kaWZpZXIgPSBmdW5jdGlvbiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0dXJsTW9kaWZpZXIgPSB0cmFuc2Zvcm07XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fVxuXG5cdHZhciBEZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0dmFyIGxvYWRpbmcgPSB7fTtcblxuXHRmdW5jdGlvbiBGaWxlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIEZpbGVMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XG5cblx0XHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cblx0XHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XG5cblx0XHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0fSwgMCApO1xuXG5cdFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgcmVxdWVzdCBpcyBkdXBsaWNhdGVcblxuXHRcdFx0aWYgKCBsb2FkaW5nWyB1cmwgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGxvYWRpbmdbIHVybCBdLnB1c2goIHtcblxuXHRcdFx0XHRcdG9uTG9hZDogb25Mb2FkLFxuXHRcdFx0XHRcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXG5cdFx0XHRcdFx0b25FcnJvcjogb25FcnJvclxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGRhdGE6IFVSSVxuXHRcdFx0dmFyIGRhdGFVcmlSZWdleCA9IC9eZGF0YTooLio/KSg7YmFzZTY0KT8sKC4qKSQvO1xuXHRcdFx0dmFyIGRhdGFVcmlSZWdleFJlc3VsdCA9IHVybC5tYXRjaCggZGF0YVVyaVJlZ2V4ICk7XG5cblx0XHRcdC8vIFNhZmFyaSBjYW4gbm90IGhhbmRsZSBEYXRhIFVSSXMgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdCBzbyBwcm9jZXNzIG1hbnVhbGx5XG5cdFx0XHRpZiAoIGRhdGFVcmlSZWdleFJlc3VsdCApIHtcblxuXHRcdFx0XHR2YXIgbWltZVR5cGUgPSBkYXRhVXJpUmVnZXhSZXN1bHRbIDEgXTtcblx0XHRcdFx0dmFyIGlzQmFzZTY0ID0gISEgZGF0YVVyaVJlZ2V4UmVzdWx0WyAyIF07XG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVyaVJlZ2V4UmVzdWx0WyAzIF07XG5cblx0XHRcdFx0ZGF0YSA9IHdpbmRvdy5kZWNvZGVVUklDb21wb25lbnQoIGRhdGEgKTtcblxuXHRcdFx0XHRpZiAoIGlzQmFzZTY0ICkgZGF0YSA9IHdpbmRvdy5hdG9iKCBkYXRhICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdHZhciByZXNwb25zZTtcblx0XHRcdFx0XHR2YXIgcmVzcG9uc2VUeXBlID0gKCB0aGlzLnJlc3BvbnNlVHlwZSB8fCAnJyApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCByZXNwb25zZVR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2FycmF5YnVmZmVyJzpcblx0XHRcdFx0XHRcdGNhc2UgJ2Jsb2InOlxuXG5cdFx0XHRcdFx0XHRcdHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoIGRhdGEubGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2aWV3WyBpIF0gPSBkYXRhLmNoYXJDb2RlQXQoIGkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCByZXNwb25zZVR5cGUgPT09ICdibG9iJyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IEJsb2IoIFsgdmlldy5idWZmZXIgXSwgeyB0eXBlOiBtaW1lVHlwZSB9ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gdmlldy5idWZmZXI7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdkb2N1bWVudCc6XG5cblx0XHRcdFx0XHRcdFx0dmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBtaW1lVHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdqc29uJzpcblxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IEpTT04ucGFyc2UoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDogLy8gJ3RleHQnIG9yIG90aGVyXG5cblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBkYXRhO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV2FpdCBmb3IgbmV4dCBicm93c2VyIHRpY2sgbGlrZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBldmVudCBkaXNwYXRjaGluZyBkb2VzXG5cdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHJlc3BvbnNlICk7XG5cblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0XHR9LCAwICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdFx0Ly8gV2FpdCBmb3IgbmV4dCBicm93c2VyIHRpY2sgbGlrZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBldmVudCBkaXNwYXRjaGluZyBkb2VzXG5cdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXJyb3IgKTtcblxuXHRcdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0XHRcdH0sIDAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSW5pdGlhbGlzZSBhcnJheSBmb3IgZHVwbGljYXRlIHJlcXVlc3RzXG5cblx0XHRcdFx0bG9hZGluZ1sgdXJsIF0gPSBbXTtcblxuXHRcdFx0XHRsb2FkaW5nWyB1cmwgXS5wdXNoKCB7XG5cblx0XHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdFx0XHRvblByb2dyZXNzOiBvblByb2dyZXNzLFxuXHRcdFx0XHRcdG9uRXJyb3I6IG9uRXJyb3JcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdFx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcblxuXHRcdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRcdHZhciByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XG5cblx0XHRcdFx0XHRDYWNoZS5hZGQoIHVybCwgcmVzcG9uc2UgKTtcblxuXHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcblxuXHRcdFx0XHRcdGRlbGV0ZSBsb2FkaW5nWyB1cmwgXTtcblxuXHRcdFx0XHRcdGlmICggdGhpcy5zdGF0dXMgPT09IDIwMCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vbkxvYWQgKSBjYWxsYmFjay5vbkxvYWQoIHJlc3BvbnNlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuc3RhdHVzID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcblx0XHRcdFx0XHRcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZpbGVMb2FkZXI6IEhUVFAgU3RhdHVzIDAgcmVjZWl2ZWQuJyApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLm9uTG9hZCApIGNhbGxiYWNrLm9uTG9hZCggcmVzcG9uc2UgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vbkVycm9yICkgY2FsbGJhY2sub25FcnJvciggZXZlbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXHRcdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sIGZhbHNlICk7XG5cblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLm9uUHJvZ3Jlc3MgKSBjYWxsYmFjay5vblByb2dyZXNzKCBldmVudCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sIGZhbHNlICk7XG5cblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLm9uRXJyb3IgKSBjYWxsYmFjay5vbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMucmVzcG9uc2VUeXBlICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xuXHRcdFx0XHRpZiAoIHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG5cdFx0XHRcdGlmICggcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlICkgcmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlKCB0aGlzLm1pbWVUeXBlICE9PSB1bmRlZmluZWQgPyB0aGlzLm1pbWVUeXBlIDogJ3RleHQvcGxhaW4nICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGhlYWRlciBpbiB0aGlzLnJlcXVlc3RIZWFkZXIgKSB7XG5cblx0XHRcdFx0XHRyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoIGhlYWRlciwgdGhpcy5yZXF1ZXN0SGVhZGVyWyBoZWFkZXIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdHJldHVybiByZXF1ZXN0O1xuXG5cdFx0fSxcblxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0TWltZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMubWltZVR5cGUgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMucmVxdWVzdEhlYWRlciA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKlxuXHQgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcblx0ICovXG5cblx0ZnVuY3Rpb24gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHRcdC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG5cdFx0dGhpcy5fcGFyc2VyID0gbnVsbDtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IENvbXByZXNzZWRUZXh0dXJlKCk7XG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG5cdFx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcblxuXHRcdFx0XHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdFx0dmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XG5cblx0XHRcdFx0XHRpbWFnZXNbIGkgXSA9IHtcblx0XHRcdFx0XHRcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXG5cdFx0XHRcdFx0XHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGxvYWRlZCArPSAxO1xuXG5cdFx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKVxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuXHRcdFx0XHR2YXIgbG9hZGVkID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xuXG5cdFx0XHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuXHRcdFx0XHRcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwczogW10gfTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuXHRcdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIE5pa29zIE0uIC8gaHR0cHM6Ly9naXRodWIuY29tL2ZvbzEyMy9cblx0ICpcblx0ICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxuXHQgKi9cblxuXHRmdW5jdGlvbiBEYXRhVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcblxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG5cdFx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcblx0XHR0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBEYXRhVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XG5cblx0XHRcdFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XG5cblx0XHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuaW1hZ2UgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5tYWdGaWx0ZXIgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcblx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWluRmlsdGVyID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG5cdFx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS50eXBlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taXBtYXBzICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIDEgPT09IHRleERhdGEubWlwbWFwQ291bnQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggSW1hZ2VMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0XHRjcm9zc09yaWdpbjogJ0Fub255bW91cycsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XG5cblx0XHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cblx0XHRcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XG5cblx0XHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0fSwgMCApO1xuXG5cdFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdpbWcnICk7XG5cblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdENhY2hlLmFkZCggdXJsLCB0aGlzICk7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0XHQvKlxuXHRcdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIG9uUHJvZ3Jlc3MgKSBvblByb2dyZXNzKCBldmVudCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXHRcdFx0Ki9cblxuXHRcdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdFx0aWYgKCB1cmwuc3Vic3RyKCAwLCA1ICkgIT09ICdkYXRhOicgKSB7XG5cblx0XHRcdFx0aWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRpbWFnZS5zcmMgPSB1cmw7XG5cblx0XHRcdHJldHVybiBpbWFnZTtcblxuXHRcdH0sXG5cblx0XHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEN1YmVUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIEN1YmVUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xuXG5cdFx0Y3Jvc3NPcmlnaW46ICdBbm9ueW1vdXMnLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmxzLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cblx0XHRcdHZhciBsb2FkZWQgPSAwO1xuXG5cdFx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcblxuXHRcdFx0XHRsb2FkZXIubG9hZCggdXJsc1sgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xuXG5cdFx0XHRcdFx0bG9hZGVkICsrO1xuXG5cdFx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9LFxuXG5cdFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0XHRjcm9zc09yaWdpbjogJ0Fub255bW91cycsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuXG5cdFx0XHRcdC8vIEpQRUdzIGNhbid0IGhhdmUgYW4gYWxwaGEgY2hhbm5lbCwgc28gbWVtb3J5IGNhbiBiZSBzYXZlZCBieSBzdG9yaW5nIHRoZW0gYXMgUkdCLlxuXHRcdFx0XHR2YXIgaXNKUEVHID0gdXJsLnNlYXJjaCggL1xcLihqcGd8anBlZykkLyApID4gMCB8fCB1cmwuc2VhcmNoKCAvXmRhdGFcXDppbWFnZVxcL2pwZWcvICkgPT09IDA7XG5cblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSBpc0pQRUcgPyBSR0JGb3JtYXQgOiBSR0JBRm9ybWF0O1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0b25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxuXHQgKlxuXHQgKiBTb21lIGNvbW1vbiBvZiBjdXJ2ZSBtZXRob2RzOlxuXHQgKiAuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50KCB0IClcblx0ICogLmdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50QXQoIHUgKVxuXHQgKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuXHQgKiAuZ2V0TGVuZ3RoKClcblx0ICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxuXHQgKlxuXHQgKiBUaGlzIGZvbGxvd2luZyBjdXJ2ZXMgaW5oZXJpdCBmcm9tIFRIUkVFLkN1cnZlOlxuXHQgKlxuXHQgKiAtLSAyRCBjdXJ2ZXMgLS1cblx0ICogVEhSRUUuQXJjQ3VydmVcblx0ICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxuXHQgKiBUSFJFRS5FbGxpcHNlQ3VydmVcblx0ICogVEhSRUUuTGluZUN1cnZlXG5cdCAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXG5cdCAqIFRIUkVFLlNwbGluZUN1cnZlXG5cdCAqXG5cdCAqIC0tIDNEIGN1cnZlcyAtLVxuXHQgKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXG5cdCAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXG5cdCAqIFRIUkVFLkxpbmVDdXJ2ZTNcblx0ICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG5cdCAqXG5cdCAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGguXG5cdCAqXG5cdCAqKi9cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3Ncblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGZ1bmN0aW9uIEN1cnZlKCkge1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlJztcblxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gMjAwO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBDdXJ2ZS5wcm90b3R5cGUsIHtcblxuXHRcdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuXHRcdC8vXHQtIHQgWzAgLi4gMV1cblxuXHRcdGdldFBvaW50OiBmdW5jdGlvbiAoIC8qIHQsIG9wdGlvbmFsVGFyZ2V0ICovICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fSxcblxuXHRcdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuXHRcdC8vIC0gdSBbMCAuLiAxXVxuXG5cdFx0Z2V0UG9pbnRBdDogZnVuY3Rpb24gKCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuXHRcdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xuXG5cdFx0XHR2YXIgcG9pbnRzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludHM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcblxuXHRcdGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xuXG5cdFx0XHR2YXIgcG9pbnRzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvaW50cztcblxuXHRcdH0sXG5cblx0XHQvLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cdFx0XHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XG5cblx0XHR9LFxuXG5cdFx0Ly8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcblxuXHRcdGdldExlbmd0aHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0XHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRcdGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMgJiZcblx0XHRcdFx0KCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKSAmJlxuXHRcdFx0XHQhIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0dmFyIGNhY2hlID0gW107XG5cdFx0XHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcblx0XHRcdHZhciBwLCBzdW0gPSAwO1xuXG5cdFx0XHRjYWNoZS5wdXNoKCAwICk7XG5cblx0XHRcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xuXHRcdFx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XG5cdFx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xuXHRcdFx0XHRsYXN0ID0gY3VycmVudDtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG5cdFx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTogc3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmdldExlbmd0aHMoKTtcblxuXHRcdH0sXG5cblx0XHQvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XG5cblx0XHRnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcblxuXHRcdFx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcblxuXHRcdFx0dmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuXG5cdFx0XHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuXHRcdFx0aWYgKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0XHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuXHRcdFx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0XHRcdHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XG5cblx0XHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cblx0XHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xuXG5cdFx0XHRcdFx0bG93ID0gaSArIDE7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cblx0XHRcdFx0XHRoaWdoID0gaSAtIDE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGhpZ2ggPSBpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gRE9ORVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpID0gaGlnaDtcblxuXHRcdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuXHRcdFx0XHRyZXR1cm4gaSAvICggaWwgLSAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuXHRcdFx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcblx0XHRcdHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XG5cblx0XHRcdHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cblx0XHRcdC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cblx0XHRcdHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcblxuXHRcdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG5cdFx0XHR2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcblxuXHRcdFx0cmV0dXJuIHQ7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuXHRcdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcblx0XHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuXHRcdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuXHRcdGdldFRhbmdlbnQ6IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0dmFyIGRlbHRhID0gMC4wMDAxO1xuXHRcdFx0dmFyIHQxID0gdCAtIGRlbHRhO1xuXHRcdFx0dmFyIHQyID0gdCArIGRlbHRhO1xuXG5cdFx0XHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cblx0XHRcdGlmICggdDEgPCAwICkgdDEgPSAwO1xuXHRcdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cblx0XHRcdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuXHRcdFx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0XHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xuXHRcdFx0cmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcblxuXHRcdH0sXG5cblx0XHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcblxuXHRcdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XG5cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZUZyZW5ldEZyYW1lczogZnVuY3Rpb24gKCBzZWdtZW50cywgY2xvc2VkICkge1xuXG5cdFx0XHQvLyBzZWUgaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXG5cblx0XHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR2YXIgdGFuZ2VudHMgPSBbXTtcblx0XHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0XHR2YXIgYmlub3JtYWxzID0gW107XG5cblx0XHRcdHZhciB2ZWMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIG1hdCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdHZhciBpLCB1LCB0aGV0YTtcblxuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdHUgPSBpIC8gc2VnbWVudHM7XG5cblx0XHRcdFx0dGFuZ2VudHNbIGkgXSA9IHRoaXMuZ2V0VGFuZ2VudEF0KCB1ICk7XG5cdFx0XHRcdHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3Rvcixcblx0XHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtaW5pbXVtIHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG5cdFx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0XHR2YXIgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG5cdFx0XHR2YXIgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XG5cdFx0XHR2YXIgdHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XG5cblx0XHRcdGlmICggdHggPD0gbWluICkge1xuXG5cdFx0XHRcdG1pbiA9IHR4O1xuXHRcdFx0XHRub3JtYWwuc2V0KCAxLCAwLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eSA8PSBtaW4gKSB7XG5cblx0XHRcdFx0bWluID0gdHk7XG5cdFx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR6IDw9IG1pbiApIHtcblxuXHRcdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XG5cblx0XHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xuXHRcdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuXG5cdFx0XHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcblxuXHRcdFx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG5cdFx0XHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cblx0XHRcdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgLSAxIF0sIHRhbmdlbnRzWyBpIF0gKTtcblxuXHRcdFx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0dmVjLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRcdFx0aWYgKCBjbG9zZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XG5cdFx0XHRcdHRoZXRhIC89IHNlZ21lbnRzO1xuXG5cdFx0XHRcdGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgc2VnbWVudHMgXSApICkgPiAwICkge1xuXG5cdFx0XHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XG5cdFx0XHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dGFuZ2VudHM6IHRhbmdlbnRzLFxuXHRcdFx0XHRub3JtYWxzOiBub3JtYWxzLFxuXHRcdFx0XHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gc291cmNlLmFyY0xlbmd0aERpdmlzaW9ucztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHRcdHZlcnNpb246IDQuNSxcblx0XHRcdFx0XHR0eXBlOiAnQ3VydmUnLFxuXHRcdFx0XHRcdGdlbmVyYXRvcjogJ0N1cnZlLnRvSlNPTidcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0ZGF0YS5hcmNMZW5ndGhEaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcblx0XHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9LFxuXG5cdFx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBqc29uLmFyY0xlbmd0aERpdmlzaW9ucztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdGZ1bmN0aW9uIEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0XHRDdXJ2ZS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcblxuXHRcdHRoaXMuYVggPSBhWCB8fCAwO1xuXHRcdHRoaXMuYVkgPSBhWSB8fCAwO1xuXG5cdFx0dGhpcy54UmFkaXVzID0geFJhZGl1cyB8fCAxO1xuXHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXMgfHwgMTtcblxuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZSB8fCAwO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlIHx8IDIgKiBNYXRoLlBJO1xuXG5cdFx0dGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZSB8fCBmYWxzZTtcblxuXHRcdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XG5cblx0fVxuXG5cdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcblx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsbGlwc2VDdXJ2ZTtcblxuXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcblxuXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG5cblx0XHR2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0XHR2YXIgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcblx0XHR2YXIgc2FtZVBvaW50cyA9IE1hdGguYWJzKCBkZWx0YUFuZ2xlICkgPCBOdW1iZXIuRVBTSUxPTjtcblxuXHRcdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuXHRcdHdoaWxlICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xuXHRcdHdoaWxlICggZGVsdGFBbmdsZSA+IHR3b1BpICkgZGVsdGFBbmdsZSAtPSB0d29QaTtcblxuXHRcdGlmICggZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRpZiAoIHNhbWVQb2ludHMgKSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMgKSB7XG5cblx0XHRcdGlmICggZGVsdGFBbmdsZSA9PT0gdHdvUGkgKSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IC0gdHdvUGk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSB0d29QaTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXHRcdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHRcdHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG5cdFx0aWYgKCB0aGlzLmFSb3RhdGlvbiAhPT0gMCApIHtcblxuXHRcdFx0dmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xuXG5cdFx0XHR2YXIgdHggPSB4IC0gdGhpcy5hWDtcblx0XHRcdHZhciB0eSA9IHkgLSB0aGlzLmFZO1xuXG5cdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdFx0XHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XG5cdFx0XHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0fTtcblxuXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5hWCA9IHNvdXJjZS5hWDtcblx0XHR0aGlzLmFZID0gc291cmNlLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0gc291cmNlLnhSYWRpdXM7XG5cdFx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gc291cmNlLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcblxuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXG5cdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcblxuXHRcdGRhdGEuYVggPSB0aGlzLmFYO1xuXHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xuXG5cdFx0ZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xuXHRcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcblxuXHRcdGRhdGEuYVN0YXJ0QW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlO1xuXHRcdGRhdGEuYUVuZEFuZ2xlID0gdGhpcy5hRW5kQW5nbGU7XG5cblx0XHRkYXRhLmFDbG9ja3dpc2UgPSB0aGlzLmFDbG9ja3dpc2U7XG5cblx0XHRkYXRhLmFSb3RhdGlvbiA9IHRoaXMuYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fTtcblxuXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcblxuXHRcdHRoaXMuYVggPSBqc29uLmFYO1xuXHRcdHRoaXMuYVkgPSBqc29uLmFZO1xuXG5cdFx0dGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcblxuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBqc29uLmFTdGFydEFuZ2xlO1xuXHRcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBqc29uLmFDbG9ja3dpc2U7XG5cblx0XHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBBcmNDdXJ2ZSggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0RWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0FyY0N1cnZlJztcblxuXHR9XG5cblx0QXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xuXHRBcmNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcmNDdXJ2ZTtcblxuXHRBcmNDdXJ2ZS5wcm90b3R5cGUuaXNBcmNDdXJ2ZSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxuXHQgKlxuXHQgKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuXHQgKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cblx0ICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcblx0ICpcblx0ICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXG5cdCAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcblx0ICovXG5cblxuXHQvKlxuXHRCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG5cdCAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXG5cdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG5cdFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcblx0YnV0IGZvciB0aHJlZS5qcyBjdXJ2ZSB1c2UsIGl0IGNvdWxkIGJlIHBvc3NpYmxlIGlubGluZWQgYW5kIGZsYXR0ZW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsXG5cdHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cblx0Ki9cblxuXHRmdW5jdGlvbiBDdWJpY1BvbHkoKSB7XG5cblx0XHR2YXIgYzAgPSAwLCBjMSA9IDAsIGMyID0gMCwgYzMgPSAwO1xuXG5cdFx0Lypcblx0XHQgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG5cdFx0ICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG5cdFx0ICogc3VjaCB0aGF0XG5cdFx0ICogICBwKDApID0geDAsIHAoMSkgPSB4MVxuXHRcdCAqICBhbmRcblx0XHQgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaW5pdCggeDAsIHgxLCB0MCwgdDEgKSB7XG5cblx0XHRcdGMwID0geDA7XG5cdFx0XHRjMSA9IHQwO1xuXHRcdFx0YzIgPSAtIDMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xuXHRcdFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cblx0XHRcdFx0aW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XG5cblx0XHRcdFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuXHRcdFx0XHR2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuXHRcdFx0XHR2YXIgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xuXG5cdFx0XHRcdC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxuXHRcdFx0XHR0MSAqPSBkdDE7XG5cdFx0XHRcdHQyICo9IGR0MTtcblxuXHRcdFx0XHRpbml0KCB4MSwgeDIsIHQxLCB0MiApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRjYWxjOiBmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHRcdFx0dmFyIHQyID0gdCAqIHQ7XG5cdFx0XHRcdHZhciB0MyA9IHQyICogdDtcblx0XHRcdFx0cmV0dXJuIGMwICsgYzEgKiB0ICsgYzIgKiB0MiArIGMzICogdDM7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdC8vXG5cblx0dmFyIHRtcCA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciBweCA9IG5ldyBDdWJpY1BvbHkoKTtcblx0dmFyIHB5ID0gbmV3IEN1YmljUG9seSgpO1xuXHR2YXIgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XG5cblx0ZnVuY3Rpb24gQ2F0bXVsbFJvbUN1cnZlMyggcG9pbnRzLCBjbG9zZWQsIGN1cnZlVHlwZSwgdGVuc2lvbiApIHtcblxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcblxuXHRcdHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xuXHRcdHRoaXMuY2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xuXHRcdHRoaXMuY3VydmVUeXBlID0gY3VydmVUeXBlIHx8ICdjZW50cmlwZXRhbCc7XG5cdFx0dGhpcy50ZW5zaW9uID0gdGVuc2lvbiB8fCAwLjU7XG5cblx0fVxuXG5cdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5cdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2F0bXVsbFJvbUN1cnZlMztcblxuXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xuXG5cdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0dmFyIGwgPSBwb2ludHMubGVuZ3RoO1xuXG5cdFx0dmFyIHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcblx0XHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0dmFyIHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgKSB7XG5cblx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcblxuXHRcdH0gZWxzZSBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cblx0XHRcdGludFBvaW50ID0gbCAtIDI7XG5cdFx0XHR3ZWlnaHQgPSAxO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHAwLCBwMSwgcDIsIHAzOyAvLyA0IHBvaW50c1xuXG5cdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDAgKSB7XG5cblx0XHRcdHAwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgbCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcblx0XHRcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0gKS5hZGQoIHBvaW50c1sgMCBdICk7XG5cdFx0XHRwMCA9IHRtcDtcblxuXHRcdH1cblxuXHRcdHAxID0gcG9pbnRzWyBpbnRQb2ludCAlIGwgXTtcblx0XHRwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgKyAyIDwgbCApIHtcblxuXHRcdFx0cDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBsIF07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDEgXSApO1xuXHRcdFx0cDMgPSB0bXA7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgKSB7XG5cblx0XHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXG5cdFx0XHR2YXIgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG5cdFx0XHR2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcblx0XHRcdHZhciBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xuXHRcdFx0dmFyIGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cblx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG5cdFx0XHRpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XG5cdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG5cdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xuXHRcdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0aGlzLnRlbnNpb24gKTtcblxuXHRcdH1cblxuXHRcdHBvaW50LnNldChcblx0XHRcdHB4LmNhbGMoIHdlaWdodCApLFxuXHRcdFx0cHkuY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fTtcblxuXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBwb2ludCA9IHNvdXJjZS5wb2ludHNbIGkgXTtcblxuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggcG9pbnQuY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zZWQgPSBzb3VyY2UuY2xvc2VkO1xuXHRcdHRoaXMuY3VydmVUeXBlID0gc291cmNlLmN1cnZlVHlwZTtcblx0XHR0aGlzLnRlbnNpb24gPSBzb3VyY2UudGVuc2lvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcblxuXHRcdGRhdGEucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XG5cblx0XHR9XG5cblx0XHRkYXRhLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xuXHRcdGRhdGEuY3VydmVUeXBlID0gdGhpcy5jdXJ2ZVR5cGU7XG5cdFx0ZGF0YS50ZW5zaW9uID0gdGhpcy50ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fTtcblxuXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBwb2ludCApICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNsb3NlZCA9IGpzb24uY2xvc2VkO1xuXHRcdHRoaXMuY3VydmVUeXBlID0ganNvbi5jdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0ganNvbi50ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKlxuXHQgKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cblx0ICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIENhdG11bGxSb20oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XG5cdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cdFx0dmFyIHQyID0gdCAqIHQ7XG5cdFx0dmFyIHQzID0gdCAqIHQyO1xuXHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKCB0LCBwICkge1xuXG5cdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRyZXR1cm4gayAqIGsgKiBwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSggdCwgcCApIHtcblxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKCB0LCBwICkge1xuXG5cdFx0cmV0dXJuIHQgKiB0ICogcDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdFx0cmV0dXJuIFF1YWRyYXRpY0JlemllclAwKCB0LCBwMCApICsgUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAxICkgK1xuXHRcdFx0UXVhZHJhdGljQmV6aWVyUDIoIHQsIHAyICk7XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMCggdCwgcCApIHtcblxuXHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0cmV0dXJuIGsgKiBrICogayAqIHA7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIEN1YmljQmV6aWVyUDEoIHQsIHAgKSB7XG5cblx0XHR2YXIgayA9IDEgLSB0O1xuXHRcdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMiggdCwgcCApIHtcblxuXHRcdHJldHVybiAzICogKCAxIC0gdCApICogdCAqIHQgKiBwO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAzKCB0LCBwICkge1xuXG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIEN1YmljQmV6aWVyKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRcdHJldHVybiBDdWJpY0JlemllclAwKCB0LCBwMCApICsgQ3ViaWNCZXppZXJQMSggdCwgcDEgKSArIEN1YmljQmV6aWVyUDIoIHQsIHAyICkgK1xuXHRcdFx0Q3ViaWNCZXppZXJQMyggdCwgcDMgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiwgdjMgKSB7XG5cblx0XHRDdXJ2ZS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZSc7XG5cblx0XHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHR0aGlzLnYzID0gdjMgfHwgbmV3IFZlY3RvcjIoKTtcblxuXHR9XG5cblx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcblx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJpY0JlemllckN1cnZlO1xuXG5cdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmlzQ3ViaWNCZXppZXJDdXJ2ZSA9IHRydWU7XG5cblx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblxuXHRcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fTtcblxuXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xuXHRcdHRoaXMudjMuY29weSggc291cmNlLnYzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9O1xuXG5cdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcblxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXHRcdHRoaXMudjMuZnJvbUFycmF5KCBqc29uLnYzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEN1YmljQmV6aWVyQ3VydmUzKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlMyc7XG5cblx0XHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcblx0XHR0aGlzLnYzID0gdjMgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHR9XG5cblx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5cdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmUzO1xuXG5cdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5pc0N1YmljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcblxuXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKSxcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56LCB2My56IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH07XG5cblx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9O1xuXG5cdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XG5cblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblx0XHR0aGlzLnYzLmZyb21BcnJheSgganNvbi52MyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBMaW5lQ3VydmUoIHYxLCB2MiApIHtcblxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUnO1xuXG5cdFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XG5cdFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XG5cblx0fVxuXG5cdExpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcblx0TGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVDdXJ2ZTtcblxuXHRMaW5lQ3VydmUucHJvdG90eXBlLmlzTGluZUN1cnZlID0gdHJ1ZTtcblxuXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcblx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fTtcblxuXHQvLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcblxuXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fTtcblxuXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiAoIC8qIHQgKi8gKSB7XG5cblx0XHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcblxuXHRcdHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xuXG5cdH07XG5cblx0TGluZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0TGluZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xuXG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0TGluZUN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XG5cblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIExpbmVDdXJ2ZTMoIHYxLCB2MiApIHtcblxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcblxuXHRcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdH1cblxuXHRMaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVDdXJ2ZTM7XG5cblx0TGluZUN1cnZlMy5wcm90b3R5cGUuaXNMaW5lQ3VydmUzID0gdHJ1ZTtcblxuXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0aWYgKCB0ID09PSAxICkge1xuXG5cdFx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICkuc3ViKCB0aGlzLnYxICk7XG5cdFx0XHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH07XG5cblx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblx0TGluZUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9O1xuXG5cdExpbmVDdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRMaW5lQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xuXG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0TGluZUN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xuXG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiApIHtcblxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZSc7XG5cblx0XHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcblxuXHR9XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5cdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1YWRyYXRpY0JlemllckN1cnZlO1xuXG5cdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlID0gdHJ1ZTtcblxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblxuXHRcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fTtcblxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcblxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMoIHYwLCB2MSwgdjIgKSB7XG5cblx0XHRDdXJ2ZS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcblxuXHRcdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdH1cblxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG5cdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM7XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApLFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH07XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XG5cblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gU3BsaW5lQ3VydmUoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xuXG5cdFx0Q3VydmUuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcblxuXHRcdHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xuXG5cdH1cblxuXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcblx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BsaW5lQ3VydmU7XG5cblx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXG5cdFNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdHZhciBwID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuXHRcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcblx0XHR2YXIgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xuXG5cdFx0dmFyIHAwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG5cdFx0dmFyIHAxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuXHRcdHZhciBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdFx0dmFyIHAzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuXHRcdHBvaW50LnNldChcblx0XHRcdENhdG11bGxSb20oIHdlaWdodCwgcDAueCwgcDEueCwgcDIueCwgcDMueCApLFxuXHRcdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC55LCBwMS55LCBwMi55LCBwMy55IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH07XG5cblx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHBvaW50ID0gc291cmNlLnBvaW50c1sgaSBdO1xuXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBwb2ludC5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdFNwbGluZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xuXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBwb2ludCA9IHRoaXMucG9pbnRzWyBpIF07XG5cdFx0XHRkYXRhLnBvaW50cy5wdXNoKCBwb2ludC50b0FycmF5KCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH07XG5cblx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcblxuXHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIHBvaW50ICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblxuXG5cdHZhciBDdXJ2ZXMgPSBPYmplY3QuZnJlZXplKHtcblx0XHRBcmNDdXJ2ZTogQXJjQ3VydmUsXG5cdFx0Q2F0bXVsbFJvbUN1cnZlMzogQ2F0bXVsbFJvbUN1cnZlMyxcblx0XHRDdWJpY0JlemllckN1cnZlOiBDdWJpY0JlemllckN1cnZlLFxuXHRcdEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcblx0XHRFbGxpcHNlQ3VydmU6IEVsbGlwc2VDdXJ2ZSxcblx0XHRMaW5lQ3VydmU6IExpbmVDdXJ2ZSxcblx0XHRMaW5lQ3VydmUzOiBMaW5lQ3VydmUzLFxuXHRcdFF1YWRyYXRpY0JlemllckN1cnZlOiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSxcblx0XHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTM6IFF1YWRyYXRpY0JlemllckN1cnZlMyxcblx0XHRTcGxpbmVDdXJ2ZTogU3BsaW5lQ3VydmVcblx0fSk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICpcblx0ICoqL1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXG5cdCAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0ZnVuY3Rpb24gQ3VydmVQYXRoKCkge1xuXG5cdFx0Q3VydmUuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlUGF0aCc7XG5cblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXHRcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cblx0fVxuXG5cdEN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IEN1cnZlUGF0aCxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCBjdXJ2ZSApIHtcblxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdH0sXG5cblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXG5cdFx0XHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcblx0XHRcdHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcblxuXHRcdFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xuXG5cdFx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBMaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuXHRcdC8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcblx0XHQvLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cblx0XHQvLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG5cdFx0Ly8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG5cdFx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuXHRcdC8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5cdFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0dmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRcdFx0dmFyIGkgPSAwO1xuXG5cdFx0XHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHRcdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcblx0XHRcdFx0XHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXG5cdFx0XHRcdFx0dmFyIHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdFx0XHR2YXIgdSA9IHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogMSAtIGRpZmYgLyBzZWdtZW50TGVuZ3RoO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG5cblx0XHR9LFxuXG5cdFx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuXHRcdC8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxuXHRcdC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcblxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdFx0XHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cblx0XHR9LFxuXG5cdFx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxuXHRcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmNhY2hlTGVuZ3RocyA9IG51bGw7XG5cdFx0XHR0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXG5cdFx0fSxcblxuXHRcdC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuXHRcdC8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXG5cblx0XHRnZXRDdXJ2ZUxlbmd0aHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxuXG5cdFx0XHRpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgbGVuZ3RoIG9mIHN1Yi1jdXJ2ZVxuXHRcdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0XHRcdHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcblx0XHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG5cdFx0XHRyZXR1cm4gbGVuZ3RocztcblxuXHRcdH0sXG5cblx0XHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0XHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNDA7XG5cblx0XHRcdHZhciBwb2ludHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcblxuXHRcdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblxuXHRcdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdFx0fSxcblxuXHRcdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcblxuXHRcdFx0dmFyIHBvaW50cyA9IFtdLCBsYXN0O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbIGkgXTtcblx0XHRcdFx0dmFyIHJlc29sdXRpb24gPSAoIGN1cnZlICYmIGN1cnZlLmlzRWxsaXBzZUN1cnZlICkgPyBkaXZpc2lvbnMgKiAyXG5cdFx0XHRcdFx0OiAoIGN1cnZlICYmIGN1cnZlLmlzTGluZUN1cnZlICkgPyAxXG5cdFx0XHRcdFx0XHQ6ICggY3VydmUgJiYgY3VydmUuaXNTcGxpbmVDdXJ2ZSApID8gZGl2aXNpb25zICogY3VydmUucG9pbnRzLmxlbmd0aFxuXHRcdFx0XHRcdFx0XHQ6IGRpdmlzaW9ucztcblxuXHRcdFx0XHR2YXIgcHRzID0gY3VydmUuZ2V0UG9pbnRzKCByZXNvbHV0aW9uICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBwb2ludCA9IHB0c1sgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBsYXN0ICYmIGxhc3QuZXF1YWxzKCBwb2ludCApICkgY29udGludWU7IC8vIGVuc3VyZXMgbm8gY29uc2VjdXRpdmUgcG9pbnRzIGFyZSBkdXBsaWNhdGVzXG5cblx0XHRcdFx0XHRwb2ludHMucHVzaCggcG9pbnQgKTtcblx0XHRcdFx0XHRsYXN0ID0gcG9pbnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgJiYgcG9pbnRzLmxlbmd0aCA+IDEgJiYgISBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb2ludHM7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGN1cnZlID0gc291cmNlLmN1cnZlc1sgaSBdO1xuXG5cdFx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmF1dG9DbG9zZSA9IHNvdXJjZS5hdXRvQ2xvc2U7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xuXG5cdFx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuXHRcdFx0ZGF0YS5jdXJ2ZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXHRcdFx0XHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fSxcblxuXHRcdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XG5cblx0XHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG5cdFx0XHR0aGlzLmN1cnZlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjdXJ2ZSA9IGpzb24uY3VydmVzWyBpIF07XG5cdFx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG5cdCAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxuXHQgKiovXG5cblx0ZnVuY3Rpb24gUGF0aCggcG9pbnRzICkge1xuXG5cdFx0Q3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQYXRoJztcblxuXHRcdHRoaXMuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdGlmICggcG9pbnRzICkge1xuXG5cdFx0XHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEN1cnZlUGF0aC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IFBhdGgsXG5cblx0XHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdFx0dGhpcy5tb3ZlVG8oIHBvaW50c1sgMCBdLngsIHBvaW50c1sgMCBdLnkgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5saW5lVG8oIHBvaW50c1sgaSBdLngsIHBvaW50c1sgaSBdLnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTsgLy8gVE9ETyBjb25zaWRlciByZWZlcmVuY2luZyB2ZWN0b3JzIGluc3RlYWQgb2YgY29weWluZz9cblxuXHRcdH0sXG5cblx0XHRsaW5lVG86IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IExpbmVDdXJ2ZSggdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoIHgsIHkgKSApO1xuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7XG5cblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XG5cblx0XHRcdHZhciBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcblx0XHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFDUHgsIGFDUHkgKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdFx0fSxcblxuXHRcdGJlemllckN1cnZlVG86IGZ1bmN0aW9uICggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcblxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUoXG5cdFx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYVgsIGFZIClcblx0XHRcdCk7XG5cblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XG5cblx0XHR9LFxuXG5cdFx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuXHRcdFx0dmFyIG5wdHMgPSBbIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCkgXS5jb25jYXQoIHB0cyApO1xuXG5cdFx0XHR2YXIgY3VydmUgPSBuZXcgU3BsaW5lQ3VydmUoIG5wdHMgKTtcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHB0c1sgcHRzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0fSxcblxuXHRcdGFyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRcdHZhciB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0XHR2YXIgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXG5cdFx0XHR0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcblx0XHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0fSxcblxuXHRcdGFic2FyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRcdHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cblx0XHR9LFxuXG5cdFx0ZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuXHRcdFx0dmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcblx0XHRcdHZhciB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG5cblx0XHRcdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cblx0XHR9LFxuXG5cdFx0YWJzZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuXHRcdFx0aWYgKCB0aGlzLmN1cnZlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXG5cdFx0XHRcdHZhciBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcblxuXHRcdFx0XHRpZiAoICEgZmlyc3RQb2ludC5lcXVhbHMoIHRoaXMuY3VycmVudFBvaW50ICkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmxpbmVUbyggZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdFx0dmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0Q3VydmVQYXRoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBzb3VyY2UuY3VycmVudFBvaW50ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IEN1cnZlUGF0aC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcblxuXHRcdFx0ZGF0YS5jdXJyZW50UG9pbnQgPSB0aGlzLmN1cnJlbnRQb2ludC50b0FycmF5KCk7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fSxcblxuXHRcdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHRcdEN1cnZlUGF0aC5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5mcm9tQXJyYXkoIGpzb24uY3VycmVudFBvaW50ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG5cdCAqKi9cblxuXHQvLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cblx0Ly8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuXHQvLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xuXHQvLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXG5cdC8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblx0ZnVuY3Rpb24gU2hhcGUoIHBvaW50cyApIHtcblxuXHRcdFBhdGguY2FsbCggdGhpcywgcG9pbnRzICk7XG5cblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTaGFwZSc7XG5cblx0XHR0aGlzLmhvbGVzID0gW107XG5cblx0fVxuXG5cdFNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFBhdGgucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBTaGFwZSxcblxuXHRcdGdldFBvaW50c0hvbGVzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRcdFx0dmFyIGhvbGVzUHRzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhvbGVzUHRzO1xuXG5cdFx0fSxcblxuXHRcdC8vIGdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG5cdFx0ZXh0cmFjdFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRcdHJldHVybiB7XG5cblx0XHRcdFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcblx0XHRcdFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdFBhdGgucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGhvbGUgPSBzb3VyY2UuaG9sZXNbIGkgXTtcblxuXHRcdFx0XHR0aGlzLmhvbGVzLnB1c2goIGhvbGUuY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IFBhdGgucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XG5cblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRcdGRhdGEuaG9sZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBob2xlID0gdGhpcy5ob2xlc1sgaSBdO1xuXHRcdFx0XHRkYXRhLmhvbGVzLnB1c2goIGhvbGUudG9KU09OKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH0sXG5cblx0XHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0XHRQYXRoLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XG5cblx0XHRcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcblx0XHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBob2xlID0ganNvbi5ob2xlc1sgaSBdO1xuXHRcdFx0XHR0aGlzLmhvbGVzLnB1c2goIG5ldyBQYXRoKCkuZnJvbUpTT04oIGhvbGUgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGlnaHQnO1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcblx0XHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gaW50ZW5zaXR5IDogMTtcblxuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHVuZGVmaW5lZDtcblxuXHR9XG5cblx0TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBMaWdodCxcblxuXHRcdGlzTGlnaHQ6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdFx0XHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0XHRkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuXHRcdFx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cblx0XHRcdGlmICggdGhpcy5kaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuXHRcdFx0aWYgKCB0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XG5cdFx0XHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblx0XHRcdGlmICggdGhpcy5wZW51bWJyYSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QucGVudW1icmEgPSB0aGlzLnBlbnVtYnJhO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2hhZG93ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKTtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBIZW1pc3BoZXJlTGlnaHQoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFx0TGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XG5cblx0XHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xuXHRcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IENvbG9yKCBncm91bmRDb2xvciApO1xuXG5cdH1cblxuXHRIZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBIZW1pc3BoZXJlTGlnaHQsXG5cblx0XHRpc0hlbWlzcGhlcmVMaWdodDogdHJ1ZSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdFx0dGhpcy5ncm91bmRDb2xvci5jb3B5KCBzb3VyY2UuZ3JvdW5kQ29sb3IgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBMaWdodFNoYWRvdyggY2FtZXJhICkge1xuXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cblx0XHR0aGlzLmJpYXMgPSAwO1xuXHRcdHRoaXMucmFkaXVzID0gMTtcblxuXHRcdHRoaXMubWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCA1MTIsIDUxMiApO1xuXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggTGlnaHRTaGFkb3cucHJvdG90eXBlLCB7XG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XG5cblx0XHRcdHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xuXHRcdFx0dGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xuXG5cdFx0XHR0aGlzLm1hcFNpemUuY29weSggc291cmNlLm1hcFNpemUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cblx0XHRcdGlmICggdGhpcy5iaWFzICE9PSAwICkgb2JqZWN0LmJpYXMgPSB0aGlzLmJpYXM7XG5cdFx0XHRpZiAoIHRoaXMucmFkaXVzICE9PSAxICkgb2JqZWN0LnJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXHRcdFx0aWYgKCB0aGlzLm1hcFNpemUueCAhPT0gNTEyIHx8IHRoaXMubWFwU2l6ZS55ICE9PSA1MTIgKSBvYmplY3QubWFwU2l6ZSA9IHRoaXMubWFwU2l6ZS50b0FycmF5KCk7XG5cblx0XHRcdG9iamVjdC5jYW1lcmEgPSB0aGlzLmNhbWVyYS50b0pTT04oIGZhbHNlICkub2JqZWN0O1xuXHRcdFx0ZGVsZXRlIG9iamVjdC5jYW1lcmEubWF0cml4O1xuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gU3BvdExpZ2h0U2hhZG93KCkge1xuXG5cdFx0TGlnaHRTaGFkb3cuY2FsbCggdGhpcywgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA1MCwgMSwgMC41LCA1MDAgKSApO1xuXG5cdH1cblxuXHRTcG90TGlnaHRTaGFkb3cucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHRTaGFkb3cucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBTcG90TGlnaHRTaGFkb3csXG5cblx0XHRpc1Nwb3RMaWdodFNoYWRvdzogdHJ1ZSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCBsaWdodCApIHtcblxuXHRcdFx0dmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXG5cdFx0XHR2YXIgZm92ID0gX01hdGguUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZTtcblx0XHRcdHZhciBhc3BlY3QgPSB0aGlzLm1hcFNpemUud2lkdGggLyB0aGlzLm1hcFNpemUuaGVpZ2h0O1xuXHRcdFx0dmFyIGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XG5cblx0XHRcdGlmICggZm92ICE9PSBjYW1lcmEuZm92IHx8IGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCB8fCBmYXIgIT09IGNhbWVyYS5mYXIgKSB7XG5cblx0XHRcdFx0Y2FtZXJhLmZvdiA9IGZvdjtcblx0XHRcdFx0Y2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcblx0XHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcblx0XHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gU3BvdExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIHBlbnVtYnJhLCBkZWNheSApIHtcblxuXHRcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Bvd2VyJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuXHRcdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNykgZnJvbSBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXG5cdFx0XHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIE1hdGguUEk7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggcG93ZXIgKSB7XG5cblx0XHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuXHRcdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNykgZnJvbSBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXG5cdFx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyBNYXRoLlBJO1xuXG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuXHRcdHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XG5cdFx0dGhpcy5wZW51bWJyYSA9ICggcGVudW1icmEgIT09IHVuZGVmaW5lZCApID8gcGVudW1icmEgOiAwO1xuXHRcdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xuXG5cdH1cblxuXHRTcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBTcG90TGlnaHQsXG5cblx0XHRpc1Nwb3RMaWdodDogdHJ1ZSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcblx0XHRcdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG5cdFx0XHR0aGlzLnBlbnVtYnJhID0gc291cmNlLnBlbnVtYnJhO1xuXHRcdFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuXHRcdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cblx0XHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlY2F5ICkge1xuXG5cdFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncG93ZXInLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXG5cdFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE1KSBmcm9tIGh0dHBzOi8vc2VibGFnYXJkZS5maWxlcy53b3JkcHJlc3MuY29tLzIwMTUvMDcvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyX3YzMi5wZGZcblx0XHRcdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogNCAqIE1hdGguUEk7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggcG93ZXIgKSB7XG5cblx0XHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuXHRcdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNSkgZnJvbSBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXG5cdFx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIDQgKiBNYXRoLlBJICk7XG5cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cdFx0dGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1x0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG5cdFx0dGhpcy5zaGFkb3cgPSBuZXcgTGlnaHRTaGFkb3coIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggOTAsIDEsIDAuNSwgNTAwICkgKTtcblxuXHR9XG5cblx0UG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IFBvaW50TGlnaHQsXG5cblx0XHRpc1BvaW50TGlnaHQ6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG5cdFx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCApIHtcblxuXHRcdExpZ2h0U2hhZG93LmNhbGwoIHRoaXMsIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gNSwgNSwgNSwgLSA1LCAwLjUsIDUwMCApICk7XG5cblx0fVxuXG5cdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHRTaGFkb3cucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcblxuXHR9XG5cblx0RGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IERpcmVjdGlvbmFsTGlnaHQsXG5cblx0XHRpc0RpcmVjdGlvbmFsTGlnaHQ6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHRcdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xuXG5cdFx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBBbWJpZW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0XHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IHVuZGVmaW5lZDtcblxuXHR9XG5cblx0QW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQW1iaWVudExpZ2h0LFxuXG5cdFx0aXNBbWJpZW50TGlnaHQ6IHRydWVcblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWJlbG5hdGlvbiAvIGh0dHA6Ly9naXRodWIuY29tL2FiZWxuYXRpb25cblx0ICovXG5cblx0ZnVuY3Rpb24gUmVjdEFyZWFMaWdodCggY29sb3IsIGludGVuc2l0eSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHRcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdSZWN0QXJlYUxpZ2h0JztcblxuXHRcdHRoaXMud2lkdGggPSAoIHdpZHRoICE9PSB1bmRlZmluZWQgKSA/IHdpZHRoIDogMTA7XG5cdFx0dGhpcy5oZWlnaHQgPSAoIGhlaWdodCAhPT0gdW5kZWZpbmVkICkgPyBoZWlnaHQgOiAxMDtcblxuXHR9XG5cblx0UmVjdEFyZWFMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IFJlY3RBcmVhTGlnaHQsXG5cblx0XHRpc1JlY3RBcmVhTGlnaHQ6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0XHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IExpZ2h0LnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdFx0XHRkYXRhLm9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XG5cdFx0XHRkYXRhLm9iamVjdC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFN0cmluZ3Ncblx0ICpcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0ZnVuY3Rpb24gU3RyaW5nS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG5cdH1cblxuXHRTdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBTdHJpbmdLZXlmcmFtZVRyYWNrLFxuXG5cdFx0VmFsdWVUeXBlTmFtZTogJ3N0cmluZycsXG5cdFx0VmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcblxuXHRcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxuXG5cdFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiB1bmRlZmluZWQsXG5cblx0XHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxuXG5cdH0gKTtcblxuXHQvKipcblx0ICpcblx0ICogQSBUcmFjayBvZiBCb29sZWFuIGtleWZyYW1lIHZhbHVlcy5cblx0ICpcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0ZnVuY3Rpb24gQm9vbGVhbktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKSB7XG5cblx0XHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcblxuXHR9XG5cblx0Qm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IEJvb2xlYW5LZXlmcmFtZVRyYWNrLFxuXG5cdFx0VmFsdWVUeXBlTmFtZTogJ2Jvb2wnLFxuXHRcdFZhbHVlQnVmZmVyVHlwZTogQXJyYXksXG5cblx0XHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVEaXNjcmV0ZSxcblxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkXG5cblx0XHQvLyBOb3RlOiBBY3R1YWxseSB0aGlzIHRyYWNrIGNvdWxkIGhhdmUgYSBvcHRpbWl6ZWQgLyBjb21wcmVzc2VkXG5cdFx0Ly8gcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgdmFsdWUgYW5kIGEgY3VzdG9tIGludGVycG9sYW50IHRoYXRcblx0XHQvLyBjb21wdXRlcyBcImZpcnN0VmFsdWUgXiBpc09kZCggaW5kZXggKVwiLlxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXG5cdCAqXG5cdCAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxuXHQgKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXG5cdCAqXG5cdCAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxuXHQgKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cblx0ICpcblx0ICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXG5cdCAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXG5cdCAqXG5cdCAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xuXHQgKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXG5cdCAqXG5cdCAqIFJlZmVyZW5jZXM6XG5cdCAqXG5cdCAqIFx0XHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXG5cdCAqXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0ZnVuY3Rpb24gSW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcblx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cblx0XHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHJlc3VsdEJ1ZmZlciA6IG5ldyBzYW1wbGVWYWx1ZXMuY29uc3RydWN0b3IoIHNhbXBsZVNpemUgKTtcblx0XHR0aGlzLnNhbXBsZVZhbHVlcyA9IHNhbXBsZVZhbHVlcztcblx0XHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIEludGVycG9sYW50LnByb3RvdHlwZSwge1xuXG5cdFx0ZXZhbHVhdGU6IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHRcdGkxID0gdGhpcy5fY2FjaGVkSW5kZXgsXG5cblx0XHRcdFx0dDEgPSBwcFsgaTEgXSxcblx0XHRcdFx0dDAgPSBwcFsgaTEgLSAxIF07XG5cblx0XHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XG5cblx0XHRcdFx0c2Vlazoge1xuXG5cdFx0XHRcdFx0dmFyIHJpZ2h0O1xuXG5cdFx0XHRcdFx0bGluZWFyX3NjYW46IHtcblxuXHRcdFx0XHRcdFx0Ly8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXG5cdFx0XHRcdFx0XHQvLy0gc2xvd2VyIGNvZGU6XG5cdFx0XHRcdFx0XHQvLy1cblx0XHRcdFx0XHRcdC8vLSBcdFx0XHRcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Zm9yd2FyZF9zY2FuOiBpZiAoICEgKCB0IDwgdDEgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSArIDI7IDsgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdCA8IHQwICkgYnJlYWsgZm9yd2FyZF9zY2FuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhZnRlciBlbmRcblxuXHRcdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQsIHQwICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuXHRcdFx0XHRcdFx0XHRcdHQwID0gdDE7XG5cdFx0XHRcdFx0XHRcdFx0dDEgPSBwcFsgKysgaTEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggdCA8IHQxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBpbmRleFxuXHRcdFx0XHRcdFx0XHRyaWdodCA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8tIHNsb3dlciBjb2RlOlxuXHRcdFx0XHRcdFx0Ly8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICEgKCB0ID49IHQwICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gbG9vcGluZz9cblxuXHRcdFx0XHRcdFx0XHR2YXIgdDFnbG9iYWwgPSBwcFsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdCA8IHQxZ2xvYmFsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aTEgPSAyOyAvLyArIDEsIHVzaW5nIHRoZSBzY2FuIGZvciB0aGUgZGV0YWlsc1xuXHRcdFx0XHRcdFx0XHRcdHQwID0gdDFnbG9iYWw7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIGxpbmVhciByZXZlcnNlIHNjYW5cblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSAtIDI7IDsgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIGJlZm9yZSBzdGFydFxuXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oIDAsIHQsIHQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuXHRcdFx0XHRcdFx0XHRcdHQxID0gdDA7XG5cdFx0XHRcdFx0XHRcdFx0dDAgPSBwcFsgLS0gaTEgLSAxIF07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQgPj0gdDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhayBzZWVrO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdFx0cmlnaHQgPSBpMTtcblx0XHRcdFx0XHRcdFx0aTEgPSAwO1xuXHRcdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2NhbjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcblxuXHRcdFx0XHRcdFx0YnJlYWsgdmFsaWRhdGVfaW50ZXJ2YWw7XG5cblx0XHRcdFx0XHR9IC8vIGxpbmVhciBzY2FuXG5cblx0XHRcdFx0XHQvLyBiaW5hcnkgc2VhcmNoXG5cblx0XHRcdFx0XHR3aGlsZSAoIGkxIDwgcmlnaHQgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBtaWQgPSAoIGkxICsgcmlnaHQgKSA+Pj4gMTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0IDwgcHBbIG1pZCBdICkge1xuXG5cdFx0XHRcdFx0XHRcdHJpZ2h0ID0gbWlkO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGkxID0gbWlkICsgMTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dDEgPSBwcFsgaTEgXTtcblx0XHRcdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxuXG5cdFx0XHRcdFx0aWYgKCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oIDAsIHQsIHQxICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyRW5kXyggaTEgLSAxLCB0MCwgdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gLy8gc2Vla1xuXG5cdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cblx0XHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XG5cblx0XHRcdH0gLy8gdmFsaWRhdGVfaW50ZXJ2YWxcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0dGluZ3M6IG51bGwsIC8vIG9wdGlvbmFsLCBzdWJjbGFzcy1zcGVjaWZpYyBzZXR0aW5ncyBzdHJ1Y3R1cmVcblx0XHQvLyBOb3RlOiBUaGUgaW5kaXJlY3Rpb24gYWxsb3dzIGNlbnRyYWwgY29udHJvbCBvZiBtYW55IGludGVycG9sYW50cy5cblxuXHRcdC8vIC0tLSBQcm90ZWN0ZWQgaW50ZXJmYWNlXG5cblx0XHREZWZhdWx0U2V0dGluZ3NfOiB7fSxcblxuXHRcdGdldFNldHRpbmdzXzogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XG5cblx0XHR9LFxuXG5cdFx0Y29weVNhbXBsZVZhbHVlXzogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0Ly8gY29waWVzIGEgc2FtcGxlIHZhbHVlIHRvIHRoZSByZXN1bHQgYnVmZmVyXG5cblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRvZmZzZXQgPSBpbmRleCAqIHN0cmlkZTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0cmVzdWx0WyBpIF0gPSB2YWx1ZXNbIG9mZnNldCArIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fSxcblxuXHRcdC8vIFRlbXBsYXRlIG1ldGhvZHMgZm9yIGRlcml2ZWQgY2xhc3NlczpcblxuXHRcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCAvKiBpMSwgdDAsIHQsIHQxICovICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdjYWxsIHRvIGFic3RyYWN0IG1ldGhvZCcgKTtcblx0XHRcdC8vIGltcGxlbWVudGF0aW9ucyBzaGFsbCByZXR1cm4gdGhpcy5yZXN1bHRCdWZmZXJcblxuXHRcdH0sXG5cblx0XHRpbnRlcnZhbENoYW5nZWRfOiBmdW5jdGlvbiAoIC8qIGkxLCB0MCwgdDEgKi8gKSB7XG5cblx0XHRcdC8vIGVtcHR5XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8vIVxcIERFQ0xBUkUgQUxJQVMgQUZURVIgYXNzaWduIHByb3RvdHlwZSAhXG5cdE9iamVjdC5hc3NpZ24oIEludGVycG9sYW50LnByb3RvdHlwZSwge1xuXG5cdFx0Ly8oIDAsIHQsIHQwICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcblx0XHRiZWZvcmVTdGFydF86IEludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfLFxuXG5cdFx0Ly8oIE4tMSwgdE4tMSwgdCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXG5cdFx0YWZ0ZXJFbmRfOiBJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxcblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIFNwaGVyaWNhbCBsaW5lYXIgdW5pdCBxdWF0ZXJuaW9uIGludGVycG9sYW50LlxuXHQgKlxuXHQgKiBAYXV0aG9yIHRzY2h3XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0UXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LFxuXG5cdFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRcdG9mZnNldCA9IGkxICogc3RyaWRlLFxuXG5cdFx0XHRcdGFscGhhID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQgKSB7XG5cblx0XHRcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIHJlc3VsdCwgMCwgdmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxuXHQgKlxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG5cdH1cblxuXHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbktleWZyYW1lVHJhY2ssXG5cblx0XHRWYWx1ZVR5cGVOYW1lOiAncXVhdGVybmlvbicsXG5cblx0XHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0XHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVMaW5lYXIsXG5cblx0XHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IGZ1bmN0aW9uICggcmVzdWx0ICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdFx0fSxcblxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkIC8vIG5vdCB5ZXQgaW1wbGVtZW50ZWRcblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqXG5cdCAqIEEgVHJhY2sgb2Yga2V5ZnJhbWUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IGNvbG9yLlxuXHQgKlxuXHQgKlxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBDb2xvcktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuXHR9XG5cblx0Q29sb3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBDb2xvcktleWZyYW1lVHJhY2ssXG5cblx0XHRWYWx1ZVR5cGVOYW1lOiAnY29sb3InXG5cblx0XHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0XHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcblxuXHRcdC8vIE5vdGU6IFZlcnkgYmFzaWMgaW1wbGVtZW50YXRpb24gYW5kIG5vdGhpbmcgc3BlY2lhbCB5ZXQuXG5cdFx0Ly8gSG93ZXZlciwgdGhpcyBpcyB0aGUgcGxhY2UgZm9yIGNvbG9yIHNwYWNlIHBhcmFtZXRlcml6YXRpb24uXG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIFRyYWNrIG9mIG51bWVyaWMga2V5ZnJhbWUgdmFsdWVzLlxuXHQgKlxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBOdW1iZXJLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XG5cblx0fVxuXG5cdE51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IE51bWJlcktleWZyYW1lVHJhY2ssXG5cblx0XHRWYWx1ZVR5cGVOYW1lOiAnbnVtYmVyJ1xuXG5cdFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuXG5cdFx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxuXHQgKlxuXHQgKiBJdCB3YXMgZGVyaXZlZCBmcm9tIGEgSGVybWl0aWFuIGNvbnN0cnVjdGlvbiBzZXR0aW5nIHRoZSBmaXJzdCBkZXJpdmF0aXZlXG5cdCAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcblx0ICogb3ZlciB0aGVpciBwYXJhbWV0ZXIgaW50ZXJ2YWwuXG5cdCAqXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0ZnVuY3Rpb24gQ3ViaWNJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHRcdHRoaXMuX3dlaWdodFByZXYgPSAtIDA7XG5cdFx0dGhpcy5fb2Zmc2V0UHJldiA9IC0gMDtcblx0XHR0aGlzLl93ZWlnaHROZXh0ID0gLSAwO1xuXHRcdHRoaXMuX29mZnNldE5leHQgPSAtIDA7XG5cblx0fVxuXG5cdEN1YmljSW50ZXJwb2xhbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBDdWJpY0ludGVycG9sYW50LFxuXG5cdFx0RGVmYXVsdFNldHRpbmdzXzoge1xuXG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG5cdFx0fSxcblxuXHRcdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uICggaTEsIHQwLCB0MSApIHtcblxuXHRcdFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHRcdGlQcmV2ID0gaTEgLSAyLFxuXHRcdFx0XHRpTmV4dCA9IGkxICsgMSxcblxuXHRcdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxuXHRcdFx0XHR0TmV4dCA9IHBwWyBpTmV4dCBdO1xuXG5cdFx0XHRpZiAoIHRQcmV2ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCApIHtcblxuXHRcdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxuXG5cdFx0XHRcdFx0XHQvLyBmJyh0MCkgPSAwXG5cdFx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdFx0dFByZXYgPSAyICogdDAgLSB0MTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG5cblx0XHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdFx0aVByZXYgPSBwcC5sZW5ndGggLSAyO1xuXHRcdFx0XHRcdFx0dFByZXYgPSB0MCArIHBwWyBpUHJldiBdIC0gcHBbIGlQcmV2ICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcblxuXHRcdFx0XHRcdFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdFx0dFByZXYgPSB0MTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0TmV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cblx0XHRcdFx0XHRcdC8vIGYnKHROKSA9IDBcblx0XHRcdFx0XHRcdGlOZXh0ID0gaTE7XG5cdFx0XHRcdFx0XHR0TmV4dCA9IDIgKiB0MSAtIHQwO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcblxuXHRcdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG5cdFx0XHRcdFx0XHRpTmV4dCA9IDE7XG5cdFx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbIDEgXSAtIHBwWyAwIF07XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG5cdFx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0XHRpTmV4dCA9IGkxIC0gMTtcblx0XHRcdFx0XHRcdHROZXh0ID0gdDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBoYWxmRHQgPSAoIHQxIC0gdDAgKSAqIDAuNSxcblx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG5cblx0XHRcdHRoaXMuX3dlaWdodFByZXYgPSBoYWxmRHQgLyAoIHQwIC0gdFByZXYgKTtcblx0XHRcdHRoaXMuX3dlaWdodE5leHQgPSBoYWxmRHQgLyAoIHROZXh0IC0gdDEgKTtcblx0XHRcdHRoaXMuX29mZnNldFByZXYgPSBpUHJldiAqIHN0cmlkZTtcblx0XHRcdHRoaXMuX29mZnNldE5leHQgPSBpTmV4dCAqIHN0cmlkZTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uICggaTEsIHQwLCB0LCB0MSApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdFx0bzEgPSBpMSAqIHN0cmlkZSxcdFx0bzAgPSBvMSAtIHN0cmlkZSxcblx0XHRcdFx0b1AgPSB0aGlzLl9vZmZzZXRQcmV2LCBcdG9OID0gdGhpcy5fb2Zmc2V0TmV4dCxcblx0XHRcdFx0d1AgPSB0aGlzLl93ZWlnaHRQcmV2LFx0d04gPSB0aGlzLl93ZWlnaHROZXh0LFxuXG5cdFx0XHRcdHAgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXG5cdFx0XHRcdHBwID0gcCAqIHAsXG5cdFx0XHRcdHBwcCA9IHBwICogcDtcblxuXHRcdFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcblxuXHRcdFx0dmFyIHNQID0gLSB3UCAqIHBwcCArIDIgKiB3UCAqIHBwIC0gd1AgKiBwO1xuXHRcdFx0dmFyIHMwID0gKCAxICsgd1AgKSAqIHBwcCArICggLSAxLjUgLSAyICogd1AgKSAqIHBwICsgKCAtIDAuNSArIHdQICkgKiBwICsgMTtcblx0XHRcdHZhciBzMSA9ICggLSAxIC0gd04gKSAqIHBwcCArICggMS41ICsgd04gKSAqIHBwICsgMC41ICogcDtcblx0XHRcdHZhciBzTiA9IHdOICogcHBwIC0gd04gKiBwcDtcblxuXHRcdFx0Ly8gY29tYmluZSBkYXRhIGxpbmVhcmx5XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRcdHJlc3VsdFsgaSBdID1cblx0XHRcdFx0XHRcdHNQICogdmFsdWVzWyBvUCArIGkgXSArXG5cdFx0XHRcdFx0XHRzMCAqIHZhbHVlc1sgbzAgKyBpIF0gK1xuXHRcdFx0XHRcdFx0czEgKiB2YWx1ZXNbIG8xICsgaSBdICtcblx0XHRcdFx0XHRcdHNOICogdmFsdWVzWyBvTiArIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBMaW5lYXJJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0TGluZWFySW50ZXJwb2xhbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBMaW5lYXJJbnRlcnBvbGFudCxcblxuXHRcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblxuXHRcdFx0XHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXG5cdFx0XHRcdG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlLFxuXG5cdFx0XHRcdHdlaWdodDEgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXG5cdFx0XHRcdHdlaWdodDAgPSAxIC0gd2VpZ2h0MTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0cmVzdWx0WyBpIF0gPVxuXHRcdFx0XHRcdFx0dmFsdWVzWyBvZmZzZXQwICsgaSBdICogd2VpZ2h0MCArXG5cdFx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB3ZWlnaHQxO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBJbnRlcnBvbGFudCB0aGF0IGV2YWx1YXRlcyB0byB0aGUgc2FtcGxlIHZhbHVlIGF0IHRoZSBwb3NpdGlvbiBwcmVjZWVkaW5nXG5cdCAqIHRoZSBwYXJhbWV0ZXIuXG5cdCAqXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0ZnVuY3Rpb24gRGlzY3JldGVJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxuXHR9XG5cblx0RGlzY3JldGVJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IERpc2NyZXRlSW50ZXJwb2xhbnQsXG5cblx0XHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uICggaTEgLyosIHQwLCB0LCB0MSAqLyApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIHRzY2h3XG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuXHQgKi9cblxuXHR2YXIgQW5pbWF0aW9uVXRpbHMgPSB7XG5cblx0XHQvLyBzYW1lIGFzIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IGFsc28gd29ya3Mgb24gdHlwZWQgYXJyYXlzXG5cdFx0YXJyYXlTbGljZTogZnVuY3Rpb24gKCBhcnJheSwgZnJvbSwgdG8gKSB7XG5cblx0XHRcdGlmICggQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCBhcnJheSApICkge1xuXG5cdFx0XHRcdC8vIGluIGlvczkgYXJyYXkuc3ViYXJyYXkoZnJvbSwgdW5kZWZpbmVkKSB3aWxsIHJldHVybiBlbXB0eSBhcnJheVxuXHRcdFx0XHQvLyBidXQgYXJyYXkuc3ViYXJyYXkoZnJvbSkgb3IgYXJyYXkuc3ViYXJyYXkoZnJvbSwgbGVuKSBpcyBjb3JyZWN0XG5cdFx0XHRcdHJldHVybiBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGFycmF5LnN1YmFycmF5KCBmcm9tLCB0byAhPT0gdW5kZWZpbmVkID8gdG8gOiBhcnJheS5sZW5ndGggKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheS5zbGljZSggZnJvbSwgdG8gKTtcblxuXHRcdH0sXG5cblx0XHQvLyBjb252ZXJ0cyBhbiBhcnJheSB0byBhIHNwZWNpZmljIHR5cGVcblx0XHRjb252ZXJ0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIHR5cGUsIGZvcmNlQ2xvbmUgKSB7XG5cblx0XHRcdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXG5cdFx0XHRcdFx0ISBmb3JjZUNsb25lICYmIGFycmF5LmNvbnN0cnVjdG9yID09PSB0eXBlICkgcmV0dXJuIGFycmF5O1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB0eXBlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAnbnVtYmVyJyApIHtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IHR5cGUoIGFycmF5ICk7IC8vIGNyZWF0ZSB0eXBlZCBhcnJheVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXkgKTsgLy8gY3JlYXRlIEFycmF5XG5cblx0XHR9LFxuXG5cdFx0aXNUeXBlZEFycmF5OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggb2JqZWN0ICkgJiZcblx0XHRcdFx0XHQhICggb2JqZWN0IGluc3RhbmNlb2YgRGF0YVZpZXcgKTtcblxuXHRcdH0sXG5cblx0XHQvLyByZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZFxuXHRcdGdldEtleWZyYW1lT3JkZXI6IGZ1bmN0aW9uICggdGltZXMgKSB7XG5cblx0XHRcdGZ1bmN0aW9uIGNvbXBhcmVUaW1lKCBpLCBqICkge1xuXG5cdFx0XHRcdHJldHVybiB0aW1lc1sgaSBdIC0gdGltZXNbIGogXTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbiA9IHRpbWVzLmxlbmd0aDtcblx0XHRcdHZhciByZXN1bHQgPSBuZXcgQXJyYXkoIG4gKTtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcblxuXHRcdFx0cmVzdWx0LnNvcnQoIGNvbXBhcmVUaW1lICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9LFxuXG5cdFx0Ly8gdXNlcyB0aGUgYXJyYXkgcHJldmlvdXNseSByZXR1cm5lZCBieSAnZ2V0S2V5ZnJhbWVPcmRlcicgdG8gc29ydCBkYXRhXG5cdFx0c29ydGVkQXJyYXk6IGZ1bmN0aW9uICggdmFsdWVzLCBzdHJpZGUsIG9yZGVyICkge1xuXG5cdFx0XHR2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0XHR2YXIgcmVzdWx0ID0gbmV3IHZhbHVlcy5jb25zdHJ1Y3RvciggblZhbHVlcyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKysgaSApIHtcblxuXHRcdFx0XHR2YXIgc3JjT2Zmc2V0ID0gb3JkZXJbIGkgXSAqIHN0cmlkZTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0XHRcdHJlc3VsdFsgZHN0T2Zmc2V0ICsrIF0gPSB2YWx1ZXNbIHNyY09mZnNldCArIGogXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH0sXG5cblx0XHQvLyBmdW5jdGlvbiBmb3IgcGFyc2luZyBBT1Mga2V5ZnJhbWUgZm9ybWF0c1xuXHRcdGZsYXR0ZW5KU09OOiBmdW5jdGlvbiAoIGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSApIHtcblxuXHRcdFx0dmFyIGkgPSAxLCBrZXkgPSBqc29uS2V5c1sgMCBdO1xuXG5cdFx0XHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxuXG5cdFx0XHR2YXIgdmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47IC8vIG5vIGRhdGFcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0XHRcdGRvIHtcblxuXHRcdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2guYXBwbHkoIHZhbHVlcywgdmFsdWUgKTsgLy8gcHVzaCBhbGwgZWxlbWVudHNcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlLnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyAuLi5hc3N1bWUgVEhSRUUuTWF0aC1pc2hcblxuXHRcdFx0XHRkbyB7XG5cblx0XHRcdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcblx0XHRcdFx0XHRcdHZhbHVlLnRvQXJyYXkoIHZhbHVlcywgdmFsdWVzLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHRcdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBvdGhlcndpc2UgcHVzaCBhcy1pc1xuXG5cdFx0XHRcdGRvIHtcblxuXHRcdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdFx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICpcblx0ICogQSB0aW1lZCBzZXF1ZW5jZSBvZiBrZXlmcmFtZXMgZm9yIGEgc3BlY2lmaWMgcHJvcGVydHkuXG5cdCAqXG5cdCAqXG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuXHQgKiBAYXV0aG9yIHRzY2h3XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEtleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIG5hbWUgaXMgdW5kZWZpbmVkJyApO1xuXHRcdGlmICggdGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDAgKSB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBubyBrZXlmcmFtZXMgaW4gdHJhY2sgbmFtZWQgJyArIG5hbWUgKTtcblxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cblx0XHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSApO1xuXHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XG5cblx0XHR0aGlzLnNldEludGVycG9sYXRpb24oIGludGVycG9sYXRpb24gfHwgdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApO1xuXG5cdFx0dGhpcy52YWxpZGF0ZSgpO1xuXHRcdHRoaXMub3B0aW1pemUoKTtcblxuXHR9XG5cblx0Ly8gU3RhdGljIG1ldGhvZHM6XG5cblx0T2JqZWN0LmFzc2lnbiggS2V5ZnJhbWVUcmFjaywge1xuXG5cdFx0Ly8gU2VyaWFsaXphdGlvbiAoaW4gc3RhdGljIGNvbnRleHQsIGJlY2F1c2Ugb2YgY29uc3RydWN0b3IgaW52b2NhdGlvblxuXHRcdC8vIGFuZCBhdXRvbWF0aWMgaW52b2NhdGlvbiBvZiAudG9KU09OKTpcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHRcdGlmICgganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2UnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHRyYWNrVHlwZSA9IEtleWZyYW1lVHJhY2suX2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xuXG5cdFx0XHRpZiAoIGpzb24udGltZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgdGltZXMgPSBbXSwgdmFsdWVzID0gW107XG5cblx0XHRcdFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oIGpzb24ua2V5cywgdGltZXMsIHZhbHVlcywgJ3ZhbHVlJyApO1xuXG5cdFx0XHRcdGpzb24udGltZXMgPSB0aW1lcztcblx0XHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgcGFyc2UgbWV0aG9kXG5cdFx0XHRpZiAoIHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiB0cmFja1R5cGUucGFyc2UoIGpzb24gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgYSBjb25zdHJ1Y3RvciBjb21wYXRpYmxlIHdpdGggdGhlIGJhc2Vcblx0XHRcdFx0cmV0dXJuIG5ldyB0cmFja1R5cGUoIGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIHRyYWNrICkge1xuXG5cdFx0XHR2YXIgdHJhY2tUeXBlID0gdHJhY2suY29uc3RydWN0b3I7XG5cblx0XHRcdHZhciBqc29uO1xuXG5cdFx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXG5cdFx0XHRpZiAoIHRyYWNrVHlwZS50b0pTT04gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRqc29uID0gdHJhY2tUeXBlLnRvSlNPTiggdHJhY2sgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgdGhlIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgYXMtaXNcblx0XHRcdFx0anNvbiA9IHtcblxuXHRcdFx0XHRcdCduYW1lJzogdHJhY2submFtZSxcblx0XHRcdFx0XHQndGltZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnRpbWVzLCBBcnJheSApLFxuXHRcdFx0XHRcdCd2YWx1ZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnZhbHVlcywgQXJyYXkgKVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIGludGVycG9sYXRpb24gPSB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKCk7XG5cblx0XHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxuXG5cdFx0XHRyZXR1cm4ganNvbjtcblxuXHRcdH0sXG5cblx0XHRfZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZTogZnVuY3Rpb24gKCB0eXBlTmFtZSApIHtcblxuXHRcdFx0c3dpdGNoICggdHlwZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblxuXHRcdFx0XHRjYXNlICdzY2FsYXInOlxuXHRcdFx0XHRjYXNlICdkb3VibGUnOlxuXHRcdFx0XHRjYXNlICdmbG9hdCc6XG5cdFx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdGNhc2UgJ2ludGVnZXInOlxuXG5cdFx0XHRcdFx0cmV0dXJuIE51bWJlcktleWZyYW1lVHJhY2s7XG5cblx0XHRcdFx0Y2FzZSAndmVjdG9yJzpcblx0XHRcdFx0Y2FzZSAndmVjdG9yMic6XG5cdFx0XHRcdGNhc2UgJ3ZlY3RvcjMnOlxuXHRcdFx0XHRjYXNlICd2ZWN0b3I0JzpcblxuXHRcdFx0XHRcdHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXG5cdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblxuXHRcdFx0XHRcdHJldHVybiBDb2xvcktleWZyYW1lVHJhY2s7XG5cblx0XHRcdFx0Y2FzZSAncXVhdGVybmlvbic6XG5cblx0XHRcdFx0XHRyZXR1cm4gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cblx0XHRcdFx0Y2FzZSAnYm9vbCc6XG5cdFx0XHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXG5cdFx0XHRcdFx0cmV0dXJuIEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xuXG5cdFx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cblx0XHRcdFx0XHRyZXR1cm4gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBVbnN1cHBvcnRlZCB0eXBlTmFtZTogJyArIHR5cGVOYW1lICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIEtleWZyYW1lVHJhY2sucHJvdG90eXBlLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogS2V5ZnJhbWVUcmFjayxcblxuXHRcdFRpbWVCdWZmZXJUeXBlOiBGbG9hdDMyQXJyYXksXG5cblx0XHRWYWx1ZUJ1ZmZlclR5cGU6IEZsb2F0MzJBcnJheSxcblxuXHRcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZUxpbmVhcixcblxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOiBmdW5jdGlvbiAoIHJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBEaXNjcmV0ZUludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cblx0XHR9LFxuXG5cdFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiBmdW5jdGlvbiAoIHJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBMaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdFx0fSxcblxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogZnVuY3Rpb24gKCByZXN1bHQgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgQ3ViaWNJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdFx0fSxcblxuXHRcdHNldEludGVycG9sYXRpb246IGZ1bmN0aW9uICggaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0dmFyIGZhY3RvcnlNZXRob2Q7XG5cblx0XHRcdHN3aXRjaCAoIGludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZURpc2NyZXRlOlxuXG5cdFx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIEludGVycG9sYXRlTGluZWFyOlxuXG5cdFx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZVNtb290aDpcblxuXHRcdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZmFjdG9yeU1ldGhvZCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBtZXNzYWdlID0gXCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcIiArXG5cdFx0XHRcdFx0dGhpcy5WYWx1ZVR5cGVOYW1lICsgXCIga2V5ZnJhbWUgdHJhY2sgbmFtZWQgXCIgKyB0aGlzLm5hbWU7XG5cblx0XHRcdFx0aWYgKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcblx0XHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazonLCBtZXNzYWdlICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNyZWF0ZUludGVycG9sYW50ID0gZmFjdG9yeU1ldGhvZDtcblxuXHRcdH0sXG5cblx0XHRnZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XG5cblx0XHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOlxuXG5cdFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlRGlzY3JldGU7XG5cblx0XHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcblxuXHRcdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZUxpbmVhcjtcblxuXHRcdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxuXG5cdFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlU21vb3RoO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Z2V0VmFsdWVTaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggLyB0aGlzLnRpbWVzLmxlbmd0aDtcblxuXHRcdH0sXG5cblx0XHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXG5cdFx0c2hpZnQ6IGZ1bmN0aW9uICggdGltZU9mZnNldCApIHtcblxuXHRcdFx0aWYgKCB0aW1lT2Zmc2V0ICE9PSAwLjAgKSB7XG5cblx0XHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHR0aW1lc1sgaSBdICs9IHRpbWVPZmZzZXQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdC8vIHNjYWxlIGFsbCBrZXlmcmFtZSB0aW1lcyBieSBhIGZhY3RvciAodXNlZnVsIGZvciBmcmFtZSA8LT4gc2Vjb25kcyBjb252ZXJzaW9ucylcblx0XHRzY2FsZTogZnVuY3Rpb24gKCB0aW1lU2NhbGUgKSB7XG5cblx0XHRcdGlmICggdGltZVNjYWxlICE9PSAxLjAgKSB7XG5cblx0XHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXG5cdFx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xuXHRcdHRyaW06IGZ1bmN0aW9uICggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xuXG5cdFx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxuXHRcdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aCxcblx0XHRcdFx0ZnJvbSA9IDAsXG5cdFx0XHRcdHRvID0gbktleXMgLSAxO1xuXG5cdFx0XHR3aGlsZSAoIGZyb20gIT09IG5LZXlzICYmIHRpbWVzWyBmcm9tIF0gPCBzdGFydFRpbWUgKSB7XG5cblx0XHRcdFx0KysgZnJvbTtcblxuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAoIHRvICE9PSAtIDEgJiYgdGltZXNbIHRvIF0gPiBlbmRUaW1lICkge1xuXG5cdFx0XHRcdC0tIHRvO1xuXG5cdFx0XHR9XG5cblx0XHRcdCsrIHRvOyAvLyBpbmNsdXNpdmUgLT4gZXhjbHVzaXZlIGJvdW5kXG5cblx0XHRcdGlmICggZnJvbSAhPT0gMCB8fCB0byAhPT0gbktleXMgKSB7XG5cblx0XHRcdFx0Ly8gZW1wdHkgdHJhY2tzIGFyZSBmb3JiaWRkZW4sIHNvIGtlZXAgYXQgbGVhc3Qgb25lIGtleWZyYW1lXG5cdFx0XHRcdGlmICggZnJvbSA+PSB0byApIHRvID0gTWF0aC5tYXgoIHRvLCAxICksIGZyb20gPSB0byAtIDE7XG5cblx0XHRcdFx0dmFyIHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cdFx0XHRcdHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aW1lcywgZnJvbSwgdG8gKTtcblx0XHRcdFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aGlzLnZhbHVlcywgZnJvbSAqIHN0cmlkZSwgdG8gKiBzdHJpZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyBlbnN1cmUgd2UgZG8gbm90IGdldCBhIEdhcmJhZ2VJbkdhcmJhZ2VPdXQgc2l0dWF0aW9uLCBtYWtlIHN1cmUgdHJhY2tzIGFyZSBhdCBsZWFzdCBtaW5pbWFsbHkgdmlhYmxlXG5cdFx0dmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbGlkID0gdHJ1ZTtcblxuXHRcdFx0dmFyIHZhbHVlU2l6ZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cdFx0XHRpZiAoIHZhbHVlU2l6ZSAtIE1hdGguZmxvb3IoIHZhbHVlU2l6ZSApICE9PSAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBJbnZhbGlkIHZhbHVlIHNpemUgaW4gdHJhY2suJywgdGhpcyApO1xuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXG5cdFx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxuXG5cdFx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG5LZXlzID09PSAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUcmFjayBpcyBlbXB0eS4nLCB0aGlzICk7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHByZXZUaW1lID0gbnVsbDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuS2V5czsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY3VyclRpbWUgPSB0aW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUaW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCBjdXJyVGltZSApO1xuXHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBPdXQgb2Ygb3JkZXIga2V5cy4nLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUgKTtcblx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwcmV2VGltZSA9IGN1cnJUaW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBBbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIHZhbHVlcyApICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsaWQ7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcmVtb3ZlcyBlcXVpdmFsZW50IHNlcXVlbnRpYWwga2V5cyBhcyBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlc1xuXHRcdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXG5cdFx0b3B0aW1pemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcblx0XHRcdFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCksXG5cblx0XHRcdFx0c21vb3RoSW50ZXJwb2xhdGlvbiA9IHRoaXMuZ2V0SW50ZXJwb2xhdGlvbigpID09PSBJbnRlcnBvbGF0ZVNtb290aCxcblxuXHRcdFx0XHR3cml0ZUluZGV4ID0gMSxcblx0XHRcdFx0bGFzdEluZGV4ID0gdGltZXMubGVuZ3RoIC0gMTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgbGFzdEluZGV4OyArKyBpICkge1xuXG5cdFx0XHRcdHZhciBrZWVwID0gZmFsc2U7XG5cblx0XHRcdFx0dmFyIHRpbWUgPSB0aW1lc1sgaSBdO1xuXHRcdFx0XHR2YXIgdGltZU5leHQgPSB0aW1lc1sgaSArIDEgXTtcblxuXHRcdFx0XHQvLyByZW1vdmUgYWRqYWNlbnQga2V5ZnJhbWVzIHNjaGVkdWxlZCBhdCB0aGUgc2FtZSB0aW1lXG5cblx0XHRcdFx0aWYgKCB0aW1lICE9PSB0aW1lTmV4dCAmJiAoIGkgIT09IDEgfHwgdGltZSAhPT0gdGltZVsgMCBdICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoICEgc21vb3RoSW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGtleWZyYW1lcyBzYW1lIGFzIHRoZWlyIG5laWdoYm9yc1xuXG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gaSAqIHN0cmlkZSxcblx0XHRcdFx0XHRcdFx0b2Zmc2V0UCA9IG9mZnNldCAtIHN0cmlkZSxcblx0XHRcdFx0XHRcdFx0b2Zmc2V0TiA9IG9mZnNldCArIHN0cmlkZTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBvZmZzZXQgKyBqIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXRQICsgaiBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0a2VlcCA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGluLXBsYWNlIGNvbXBhY3Rpb25cblxuXHRcdFx0XHRpZiAoIGtlZXAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGkgIT09IHdyaXRlSW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHR2YXIgcmVhZE9mZnNldCA9IGkgKiBzdHJpZGUsXG5cdFx0XHRcdFx0XHRcdHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Kysgd3JpdGVJbmRleDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZmx1c2ggbGFzdCBrZXlmcmFtZSAoY29tcGFjdGlvbiBsb29rcyBhaGVhZClcblxuXHRcdFx0aWYgKCBsYXN0SW5kZXggPiAwICkge1xuXG5cdFx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgbGFzdEluZGV4IF07XG5cblx0XHRcdFx0Zm9yICggdmFyIHJlYWRPZmZzZXQgPSBsYXN0SW5kZXggKiBzdHJpZGUsIHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZSwgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0XHRcdHZhbHVlc1sgd3JpdGVPZmZzZXQgKyBqIF0gPSB2YWx1ZXNbIHJlYWRPZmZzZXQgKyBqIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3cml0ZUluZGV4ICE9PSB0aW1lcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCAwLCB3cml0ZUluZGV4ICk7XG5cdFx0XHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBBIFRyYWNrIG9mIHZlY3RvcmVkIGtleWZyYW1lIHZhbHVlcy5cblx0ICpcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0ZnVuY3Rpb24gVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xuXG5cdH1cblxuXHRWZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBWZWN0b3JLZXlmcmFtZVRyYWNrLFxuXG5cdFx0VmFsdWVUeXBlTmFtZTogJ3ZlY3RvcidcblxuXHRcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuXHRcdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxuXG5cdH0gKTtcblxuXHQvKipcblx0ICpcblx0ICogUmV1c2FibGUgc2V0IG9mIFRyYWNrcyB0aGF0IHJlcHJlc2VudCBhbiBhbmltYXRpb24uXG5cdCAqXG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBBbmltYXRpb25DbGlwKCBuYW1lLCBkdXJhdGlvbiwgdHJhY2tzICkge1xuXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLnRyYWNrcyA9IHRyYWNrcztcblx0XHR0aGlzLmR1cmF0aW9uID0gKCBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkdXJhdGlvbiA6IC0gMTtcblxuXHRcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0Ly8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xuXHRcdGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XG5cblx0XHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpbWl6ZSgpO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25DbGlwLCB7XG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0XHR2YXIgdHJhY2tzID0gW10sXG5cdFx0XHRcdGpzb25UcmFja3MgPSBqc29uLnRyYWNrcyxcblx0XHRcdFx0ZnJhbWVUaW1lID0gMS4wIC8gKCBqc29uLmZwcyB8fCAxLjAgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0ganNvblRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dHJhY2tzLnB1c2goIEtleWZyYW1lVHJhY2sucGFyc2UoIGpzb25UcmFja3NbIGkgXSApLnNjYWxlKCBmcmFtZVRpbWUgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCgganNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MgKTtcblxuXHRcdH0sXG5cblx0XHR0b0pTT046IGZ1bmN0aW9uICggY2xpcCApIHtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IFtdLFxuXHRcdFx0XHRjbGlwVHJhY2tzID0gY2xpcC50cmFja3M7XG5cblx0XHRcdHZhciBqc29uID0ge1xuXG5cdFx0XHRcdCduYW1lJzogY2xpcC5uYW1lLFxuXHRcdFx0XHQnZHVyYXRpb24nOiBjbGlwLmR1cmF0aW9uLFxuXHRcdFx0XHQndHJhY2tzJzogdHJhY2tzXG5cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGNsaXBUcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnRvSlNPTiggY2xpcFRyYWNrc1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ganNvbjtcblxuXHRcdH0sXG5cblx0XHRDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZTogZnVuY3Rpb24gKCBuYW1lLCBtb3JwaFRhcmdldFNlcXVlbmNlLCBmcHMsIG5vTG9vcCApIHtcblxuXHRcdFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoVGFyZ2V0U2VxdWVuY2UubGVuZ3RoO1xuXHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHRpbWVzID0gW107XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHR0aW1lcy5wdXNoKFxuXHRcdFx0XHRcdCggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdCggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyApO1xuXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XG5cblx0XHRcdFx0dmFyIG9yZGVyID0gQW5pbWF0aW9uVXRpbHMuZ2V0S2V5ZnJhbWVPcmRlciggdGltZXMgKTtcblx0XHRcdFx0dGltZXMgPSBBbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSggdGltZXMsIDEsIG9yZGVyICk7XG5cdFx0XHRcdHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSBrZXkgYXQgdGhlIGZpcnN0IGZyYW1lLCBkdXBsaWNhdGUgaXQgYXMgdGhlXG5cdFx0XHRcdC8vIGxhc3QgZnJhbWUgYXMgd2VsbCBmb3IgcGVyZmVjdCBsb29wLlxuXHRcdFx0XHRpZiAoICEgbm9Mb29wICYmIHRpbWVzWyAwIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBudW1Nb3JwaFRhcmdldHMgKTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJhY2tzLnB1c2goXG5cdFx0XHRcdFx0bmV3IE51bWJlcktleWZyYW1lVHJhY2soXG5cdFx0XHRcdFx0XHQnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVsgaSBdLm5hbWUgKyAnXScsXG5cdFx0XHRcdFx0XHR0aW1lcywgdmFsdWVzXG5cdFx0XHRcdFx0KS5zY2FsZSggMS4wIC8gZnBzICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIG5hbWUsIC0gMSwgdHJhY2tzICk7XG5cblx0XHR9LFxuXG5cdFx0ZmluZEJ5TmFtZTogZnVuY3Rpb24gKCBvYmplY3RPckNsaXBBcnJheSwgbmFtZSApIHtcblxuXHRcdFx0dmFyIGNsaXBBcnJheSA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXG5cdFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggb2JqZWN0T3JDbGlwQXJyYXkgKSApIHtcblxuXHRcdFx0XHR2YXIgbyA9IG9iamVjdE9yQ2xpcEFycmF5O1xuXHRcdFx0XHRjbGlwQXJyYXkgPSBvLmdlb21ldHJ5ICYmIG8uZ2VvbWV0cnkuYW5pbWF0aW9ucyB8fCBvLmFuaW1hdGlvbnM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2xpcEFycmF5Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGNsaXBBcnJheVsgaSBdLm5hbWUgPT09IG5hbWUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fSxcblxuXHRcdENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzOiBmdW5jdGlvbiAoIG1vcnBoVGFyZ2V0cywgZnBzLCBub0xvb3AgKSB7XG5cblx0XHRcdHZhciBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0XHQvLyB0ZXN0ZWQgd2l0aCBodHRwczovL3JlZ2V4MTAxLmNvbS8gb24gdHJpY2sgc2VxdWVuY2VzXG5cdFx0XHQvLyBzdWNoIGZsYW1pbmdvX2ZseUFfMDAzLCBmbGFtaW5nb19ydW4xXzAwMywgY3JkZWF0aDAwNTlcblx0XHRcdHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcblxuXHRcdFx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXG5cdFx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblx0XHRcdFx0dmFyIHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaCggcGF0dGVybiApO1xuXG5cdFx0XHRcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFydHNbIDEgXTtcblxuXHRcdFx0XHRcdHZhciBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdO1xuXHRcdFx0XHRcdGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRcdGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0gPSBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBbXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2xpcHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0Y2xpcHMucHVzaCggQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzLCBub0xvb3AgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjbGlwcztcblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcblx0XHRwYXJzZUFuaW1hdGlvbjogZnVuY3Rpb24gKCBhbmltYXRpb24sIGJvbmVzICkge1xuXG5cdFx0XHRpZiAoICEgYW5pbWF0aW9uICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5BbmltYXRpb25DbGlwOiBObyBhbmltYXRpb24gaW4gSlNPTkxvYWRlciBkYXRhLicgKTtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGFkZE5vbmVtcHR5VHJhY2sgPSBmdW5jdGlvbiAoIHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MgKSB7XG5cblx0XHRcdFx0Ly8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5cy5sZW5ndGggIT09IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgdGltZXMgPSBbXTtcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cblx0XHRcdFx0XHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTiggYW5pbWF0aW9uS2V5cywgdGltZXMsIHZhbHVlcywgcHJvcGVydHlOYW1lICk7XG5cblx0XHRcdFx0XHQvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXG5cdFx0XHRcdFx0aWYgKCB0aW1lcy5sZW5ndGggIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdGRlc3RUcmFja3MucHVzaCggbmV3IHRyYWNrVHlwZSggdHJhY2tOYW1lLCB0aW1lcywgdmFsdWVzICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdFx0dmFyIGNsaXBOYW1lID0gYW5pbWF0aW9uLm5hbWUgfHwgJ2RlZmF1bHQnO1xuXHRcdFx0Ly8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXG5cdFx0XHR2YXIgZHVyYXRpb24gPSBhbmltYXRpb24ubGVuZ3RoIHx8IC0gMTtcblx0XHRcdHZhciBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xuXG5cdFx0XHR2YXIgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCArKyApIHtcblxuXHRcdFx0XHR2YXIgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XG5cblx0XHRcdFx0Ly8gc2tpcCBlbXB0eSB0cmFja3Ncblx0XHRcdFx0aWYgKCAhIGFuaW1hdGlvbktleXMgfHwgYW5pbWF0aW9uS2V5cy5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHQvLyBwcm9jZXNzIG1vcnBoIHRhcmdldHNcblx0XHRcdFx0aWYgKCBhbmltYXRpb25LZXlzWyAwIF0ubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcblx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0TmFtZXNbIGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXSBdID0gLSAxO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cblx0XHRcdFx0XHQvLyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaFxuXHRcdFx0XHRcdC8vIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cblx0XHRcdFx0XHRmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIG1vcnBoVGFyZ2V0TmFtZXMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB0aW1lcyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7IG0gIT09IGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArKyBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzWyBrIF07XG5cblx0XHRcdFx0XHRcdFx0dGltZXMucHVzaCggYW5pbWF0aW9uS2V5LnRpbWUgKTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goICggYW5pbWF0aW9uS2V5Lm1vcnBoVGFyZ2V0ID09PSBtb3JwaFRhcmdldE5hbWUgKSA/IDEgOiAwICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dHJhY2tzLnB1c2goIG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKCAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlWycgKyBtb3JwaFRhcmdldE5hbWUgKyAnXScsIHRpbWVzLCB2YWx1ZXMgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqICggZnBzIHx8IDEuMCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyAuLi5hc3N1bWUgc2tlbGV0YWwgYW5pbWF0aW9uXG5cblx0XHRcdFx0XHR2YXIgYm9uZU5hbWUgPSAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XG5cblx0XHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuXHRcdFx0XHRcdFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnBvc2l0aW9uJyxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdwb3MnLCB0cmFja3MgKTtcblxuXHRcdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXG5cdFx0XHRcdFx0XHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnF1YXRlcm5pb24nLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyApO1xuXG5cdFx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcblx0XHRcdFx0XHRcdFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5zY2FsZScsXG5cdFx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2xpcCA9IG5ldyBBbmltYXRpb25DbGlwKCBjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xuXG5cdFx0XHRyZXR1cm4gY2xpcDtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUsIHtcblxuXHRcdHJlc2V0RHVyYXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzLCBkdXJhdGlvbiA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIHRyYWNrID0gdGhpcy50cmFja3NbIGkgXTtcblxuXHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KCBkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblxuXHRcdH0sXG5cblx0XHR0cmltOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLnRyYWNrc1sgaSBdLnRyaW0oIDAsIHRoaXMuZHVyYXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRvcHRpbWl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy50cmFja3NbIGkgXS5vcHRpbWl6ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gTWF0ZXJpYWxMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblx0XHR0aGlzLnRleHR1cmVzID0ge307XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIE1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSwge1xuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fSxcblxuXHRcdHNldFRleHR1cmVzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdFx0dmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZSggbmFtZSApIHtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IE1hdGVyaWFsc1sganNvbi50eXBlIF0oKTtcblxuXHRcdFx0aWYgKCBqc29uLnV1aWQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0XHRpZiAoIGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcblx0XHRcdGlmICgganNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XG5cdFx0XHRpZiAoIGpzb24ucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcblx0XHRcdGlmICgganNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzcyA9IGpzb24ubWV0YWxuZXNzO1xuXHRcdFx0aWYgKCBqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcblx0XHRcdGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KCBqc29uLnNwZWN1bGFyICk7XG5cdFx0XHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcblx0XHRcdGlmICgganNvbi5jbGVhckNvYXQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyQ29hdCA9IGpzb24uY2xlYXJDb2F0O1xuXHRcdFx0aWYgKCBqc29uLmNsZWFyQ29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0ganNvbi5jbGVhckNvYXRSb3VnaG5lc3M7XG5cdFx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3Jtcztcblx0XHRcdGlmICgganNvbi52ZXJ0ZXhTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IGpzb24udmVydGV4U2hhZGVyO1xuXHRcdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG5cdFx0XHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcblx0XHRcdGlmICgganNvbi5mb2cgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZvZyA9IGpzb24uZm9nO1xuXHRcdFx0aWYgKCBqc29uLmZsYXRTaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uZmxhdFNoYWRpbmc7XG5cdFx0XHRpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcblx0XHRcdGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xuXHRcdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG5cdFx0XHRpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcblx0XHRcdGlmICgganNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFscGhhVGVzdCA9IGpzb24uYWxwaGFUZXN0O1xuXHRcdFx0aWYgKCBqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XG5cdFx0XHRpZiAoIGpzb24uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGpzb24uZGVwdGhXcml0ZTtcblx0XHRcdGlmICgganNvbi5jb2xvcldyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvcldyaXRlID0ganNvbi5jb2xvcldyaXRlO1xuXHRcdFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG5cdFx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBqc29uLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0XHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0ganNvbi53aXJlZnJhbWVMaW5lY2FwO1xuXHRcdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVqb2luICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XG5cblx0XHRcdGlmICgganNvbi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm90YXRpb24gPSBqc29uLnJvdGF0aW9uO1xuXG5cdFx0XHRpZiAoIGpzb24ubGluZXdpZHRoICE9PSAxICkgbWF0ZXJpYWwubGluZXdpZHRoID0ganNvbi5saW5ld2lkdGg7XG5cdFx0XHRpZiAoIGpzb24uZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRhc2hTaXplID0ganNvbi5kYXNoU2l6ZTtcblx0XHRcdGlmICgganNvbi5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5nYXBTaXplID0ganNvbi5nYXBTaXplO1xuXHRcdFx0aWYgKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zY2FsZSA9IGpzb24uc2NhbGU7XG5cblx0XHRcdGlmICgganNvbi5za2lubmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2tpbm5pbmcgPSBqc29uLnNraW5uaW5nO1xuXHRcdFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0ganNvbi5tb3JwaFRhcmdldHM7XG5cdFx0XHRpZiAoIGpzb24uZGl0aGVyaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXRoZXJpbmcgPSBqc29uLmRpdGhlcmluZztcblxuXHRcdFx0aWYgKCBqc29uLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZpc2libGUgPSBqc29uLnZpc2libGU7XG5cdFx0XHRpZiAoIGpzb24udXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVzZXJEYXRhID0ganNvbi51c2VyRGF0YTtcblxuXHRcdFx0Ly8gRGVwcmVjYXRlZFxuXG5cdFx0XHRpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLnNoYWRpbmcgPT09IDE7IC8vIFRIUkVFLkZsYXRTaGFkaW5nXG5cblx0XHRcdC8vIGZvciBQb2ludHNNYXRlcmlhbFxuXG5cdFx0XHRpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcblx0XHRcdGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0XHQvLyBtYXBzXG5cblx0XHRcdGlmICgganNvbi5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIGpzb24ubWFwICk7XG5cblx0XHRcdGlmICgganNvbi5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLmFscGhhTWFwID0gZ2V0VGV4dHVyZSgganNvbi5hbHBoYU1hcCApO1xuXHRcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcblx0XHRcdGlmICgganNvbi5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xuXG5cdFx0XHRpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm5vcm1hbE1hcCApO1xuXHRcdFx0aWYgKCBqc29uLm5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIG5vcm1hbFNjYWxlID0ganNvbi5ub3JtYWxTY2FsZTtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5vcm1hbFNjYWxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Ly8gQmxlbmRlciBleHBvcnRlciB1c2VkIHRvIGV4cG9ydCBhIHNjYWxhci4gU2VlICM3NDU5XG5cblx0XHRcdFx0XHRub3JtYWxTY2FsZSA9IFsgbm9ybWFsU2NhbGUsIG5vcm1hbFNjYWxlIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIG5vcm1hbFNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcblx0XHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xuXHRcdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ucm91Z2huZXNzTWFwICk7XG5cdFx0XHRpZiAoIGpzb24ubWV0YWxuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1ldGFsbmVzc01hcCApO1xuXG5cdFx0XHRpZiAoIGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbWlzc2l2ZU1hcCApO1xuXHRcdFx0aWYgKCBqc29uLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSA9IGpzb24uZW1pc3NpdmVJbnRlbnNpdHk7XG5cblx0XHRcdGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XG5cblx0XHRcdGlmICgganNvbi5lbnZNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoIGpzb24uZW52TWFwICk7XG5cblx0XHRcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuXG5cdFx0XHRpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xuXHRcdFx0aWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHRcdGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XG5cdFx0XHRpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcblxuXHRcdFx0aWYgKCBqc29uLmdyYWRpZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ncmFkaWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZ3JhZGllbnRNYXAgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnlMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlLCB7XG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IFRZUEVEX0FSUkFZU1sgaW5kZXgudHlwZSBdKCBpbmRleC5hcnJheSApO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblx0XHRcdFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgVFlQRURfQVJSQVlTWyBhdHRyaWJ1dGUudHlwZSBdKCBhdHRyaWJ1dGUuYXJyYXkgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGtleSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGdyb3VwcyA9IGpzb24uZGF0YS5ncm91cHMgfHwganNvbi5kYXRhLmRyYXdjYWxscyB8fCBqc29uLmRhdGEub2Zmc2V0cztcblxuXHRcdFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0dmFyIFRZUEVEX0FSUkFZUyA9IHtcblx0XHRJbnQ4QXJyYXk6IEludDhBcnJheSxcblx0XHRVaW50OEFycmF5OiBVaW50OEFycmF5LFxuXHRcdC8vIFdvcmthcm91bmQgZm9yIElFMTEgcHJlIEtCMjkyOTQzNy4gU2VlICMxMTQ0MFxuXHRcdFVpbnQ4Q2xhbXBlZEFycmF5OiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhDbGFtcGVkQXJyYXkgOiBVaW50OEFycmF5LFxuXHRcdEludDE2QXJyYXk6IEludDE2QXJyYXksXG5cdFx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxuXHRcdEludDMyQXJyYXk6IEludDMyQXJyYXksXG5cdFx0VWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxuXHRcdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuXHRcdEZsb2F0NjRBcnJheTogRmxvYXQ2NEFycmF5XG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIExvYWRlcigpIHtcblxuXHRcdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG5cdFx0dGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdH1cblxuXHRMb2FkZXIuSGFuZGxlcnMgPSB7XG5cblx0XHRoYW5kbGVyczogW10sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcblxuXHRcdFx0dGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cblx0XHRcdHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuXHRcdFx0XHR2YXIgcmVnZXggPSBoYW5kbGVyc1sgaSBdO1xuXHRcdFx0XHR2YXIgbG9hZGVyID0gaGFuZGxlcnNbIGkgKyAxIF07XG5cblx0XHRcdFx0aWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdE9iamVjdC5hc3NpZ24oIExvYWRlci5wcm90b3R5cGUsIHtcblxuXHRcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cblx0XHRpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRhcnJheVsgaSBdID0gdGhpcy5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH0sXG5cblx0XHRjcmVhdGVNYXRlcmlhbDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBCbGVuZGluZ01vZGUgPSB7XG5cdFx0XHRcdE5vQmxlbmRpbmc6IE5vQmxlbmRpbmcsXG5cdFx0XHRcdE5vcm1hbEJsZW5kaW5nOiBOb3JtYWxCbGVuZGluZyxcblx0XHRcdFx0QWRkaXRpdmVCbGVuZGluZzogQWRkaXRpdmVCbGVuZGluZyxcblx0XHRcdFx0U3VidHJhY3RpdmVCbGVuZGluZzogU3VidHJhY3RpdmVCbGVuZGluZyxcblx0XHRcdFx0TXVsdGlwbHlCbGVuZGluZzogTXVsdGlwbHlCbGVuZGluZyxcblx0XHRcdFx0Q3VzdG9tQmxlbmRpbmc6IEN1c3RvbUJsZW5kaW5nXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcblx0XHRcdHZhciB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcblx0XHRcdHZhciBtYXRlcmlhbExvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWF0ZXJpYWwoIG0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuXHRcdFx0XHQvLyBjb252ZXJ0IGZyb20gb2xkIG1hdGVyaWFsIGZvcm1hdFxuXG5cdFx0XHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG5cdFx0XHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBwYXRoLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcblxuXHRcdFx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgcGF0aDtcblx0XHRcdFx0XHR2YXIgbG9hZGVyID0gTG9hZGVyLkhhbmRsZXJzLmdldCggZnVsbFBhdGggKTtcblxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlO1xuXG5cdFx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggZnVsbFBhdGggKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCByZXBlYXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCByZXBlYXRbIDAgXSAhPT0gMSApIHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIG9mZnNldCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB3cmFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFMgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBUID0gTWlycm9yZWRSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdFx0XHRcdHRleHR1cmVzWyB1dWlkIF0gPSB0ZXh0dXJlO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHV1aWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0dmFyIGpzb24gPSB7XG5cdFx0XHRcdFx0dXVpZDogX01hdGguZ2VuZXJhdGVVVUlEKCksXG5cdFx0XHRcdFx0dHlwZTogJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbSApIHtcblxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IG1bIG5hbWUgXTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0RiZ0NvbG9yJzpcblx0XHRcdFx0XHRcdGNhc2UgJ0RiZ0luZGV4Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ29wdGljYWxEZW5zaXR5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ2lsbHVtaW5hdGlvbic6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnRGJnTmFtZSc6XG5cdFx0XHRcdFx0XHRcdGpzb24ubmFtZSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2JsZW5kaW5nJzpcblx0XHRcdFx0XHRcdFx0anNvbi5ibGVuZGluZyA9IEJsZW5kaW5nTW9kZVsgdmFsdWUgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvckFtYmllbnQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQW1iaWVudCc6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDonLCBuYW1lLCAnaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JEaWZmdXNlJzpcblx0XHRcdFx0XHRcdFx0anNvbi5jb2xvciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvclNwZWN1bGFyJzpcblx0XHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvckVtaXNzaXZlJzpcblx0XHRcdFx0XHRcdFx0anNvbi5lbWlzc2l2ZSA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdzcGVjdWxhckNvZWYnOlxuXHRcdFx0XHRcdFx0XHRqc29uLnNoaW5pbmVzcyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3NoYWRpbmcnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNpYycgKSBqc29uLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdwaG9uZycgKSBqc29uLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdzdGFuZGFyZCcgKSBqc29uLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2UnOlxuXHRcdFx0XHRcdFx0XHRqc29uLm1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlUmVwZWF0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZVdyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZUFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlJzpcblx0XHRcdFx0XHRcdFx0anNvbi5lbWlzc2l2ZU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBFbWlzc2l2ZVJlcGVhdCwgbS5tYXBFbWlzc2l2ZU9mZnNldCwgbS5tYXBFbWlzc2l2ZVdyYXAsIG0ubWFwRW1pc3NpdmVBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRW1pc3NpdmVSZXBlYXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRW1pc3NpdmVPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRW1pc3NpdmVXcmFwJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHQnOlxuXHRcdFx0XHRcdFx0XHRqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFJlcGVhdCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodE9mZnNldCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFdyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBTyc6XG5cdFx0XHRcdFx0XHRcdGpzb24uYW9NYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFPUmVwZWF0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFPT2Zmc2V0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFPV3JhcCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXAnOlxuXHRcdFx0XHRcdFx0XHRqc29uLmJ1bXBNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFNjYWxlJzpcblx0XHRcdFx0XHRcdFx0anNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBCdW1wUmVwZWF0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFdyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbCc6XG5cdFx0XHRcdFx0XHRcdGpzb24ubm9ybWFsTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsRmFjdG9yJzpcblx0XHRcdFx0XHRcdFx0anNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsUmVwZWF0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbE9mZnNldCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxXcmFwJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyJzpcblx0XHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhck1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJPZmZzZXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJXcmFwJzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzJzpcblx0XHRcdFx0XHRcdFx0anNvbi5tZXRhbG5lc3NNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTWV0YWxuZXNzUmVwZWF0LCBtLm1hcE1ldGFsbmVzc09mZnNldCwgbS5tYXBNZXRhbG5lc3NXcmFwLCBtLm1hcE1ldGFsbmVzc0FuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NSZXBlYXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzT2Zmc2V0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE1ldGFsbmVzc1dyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzJzpcblx0XHRcdFx0XHRcdFx0anNvbi5yb3VnaG5lc3NNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwUm91Z2huZXNzUmVwZWF0LCBtLm1hcFJvdWdobmVzc09mZnNldCwgbS5tYXBSb3VnaG5lc3NXcmFwLCBtLm1hcFJvdWdobmVzc0FuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBSb3VnaG5lc3NSZXBlYXQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzT2Zmc2V0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzc1dyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGEnOlxuXHRcdFx0XHRcdFx0XHRqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVJlcGVhdCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYU9mZnNldCc6XG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVdyYXAnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdmbGlwU2lkZWQnOlxuXHRcdFx0XHRcdFx0XHRqc29uLnNpZGUgPSBCYWNrU2lkZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdkb3VibGVTaWRlZCc6XG5cdFx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IERvdWJsZVNpZGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5Jzpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xuXHRcdFx0XHRcdFx0XHRqc29uLm9wYWNpdHkgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdkZXB0aFRlc3QnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnZGVwdGhXcml0ZSc6XG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvcldyaXRlJzpcblx0XHRcdFx0XHRcdGNhc2UgJ29wYWNpdHknOlxuXHRcdFx0XHRcdFx0Y2FzZSAncmVmbGVjdGl2aXR5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ3Zpc2libGUnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnd2lyZWZyYW1lJzpcblx0XHRcdFx0XHRcdFx0anNvblsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAndmVydGV4Q29sb3JzJzpcblx0XHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSAnZmFjZScgKSBqc29uLnZlcnRleENvbG9ycyA9IEZhY2VDb2xvcnM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDogVW5zdXBwb3J0ZWQnLCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBqc29uLnR5cGUgPT09ICdNZXNoQmFzaWNNYXRlcmlhbCcgKSBkZWxldGUganNvbi5lbWlzc2l2ZTtcblx0XHRcdFx0aWYgKCBqc29uLnR5cGUgIT09ICdNZXNoUGhvbmdNYXRlcmlhbCcgKSBkZWxldGUganNvbi5zcGVjdWxhcjtcblxuXHRcdFx0XHRpZiAoIGpzb24ub3BhY2l0eSA8IDEgKSBqc29uLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHRtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxMb2FkZXIucGFyc2UoIGpzb24gKTtcblxuXHRcdFx0fTtcblxuXHRcdH0gKSgpXG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIERvbiBNY0N1cmR5IC8gaHR0cHM6Ly93d3cuZG9ubWNjdXJkeS5jb21cblx0ICovXG5cblx0dmFyIExvYWRlclV0aWxzID0ge1xuXG5cdFx0ZGVjb2RlVGV4dDogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnICkge1xuXG5cdFx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoIGFycmF5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXZvaWQgdGhlIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIHNob3J0Y3V0LCB3aGljaFxuXHRcdFx0Ly8gdGhyb3dzIGEgXCJtYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiIGVycm9yIGZvciBsYXJnZSBhcnJheXMuXG5cblx0XHRcdHZhciBzID0gJyc7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHQvLyBJbXBsaWNpdGx5IGFzc3VtZXMgbGl0dGxlLWVuZGlhbi5cblx0XHRcdFx0cyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBhcnJheVsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTWVyZ2VzIG11bHRpLWJ5dGUgdXRmLTggY2hhcmFjdGVycy5cblx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoIGVzY2FwZSggcyApICk7XG5cblx0XHR9LFxuXG5cdFx0ZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHR2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xuXG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xuXG5cdFx0XHRwYXJ0cy5wb3AoKTtcblxuXHRcdFx0cmV0dXJuIHBhcnRzLmpvaW4oICcvJyApICsgJy8nO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEpTT05Mb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBtYW5hZ2VyID09PSAnYm9vbGVhbicgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IHNob3dTdGF0dXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBjb25zdHJ1Y3Rvci4nICk7XG5cdFx0XHRtYW5hZ2VyID0gdW5kZWZpbmVkO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBKU09OTG9hZGVyLnByb3RvdHlwZSwge1xuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIHRleHR1cmVQYXRoID0gdGhpcy50ZXh0dXJlUGF0aCAmJiAoIHR5cGVvZiB0aGlzLnRleHR1cmVQYXRoID09PSAnc3RyaW5nJyApID8gdGhpcy50ZXh0dXJlUGF0aCA6IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cdFx0XHRcdHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdFx0aWYgKCBtZXRhZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmFyIHR5cGUgPSBtZXRhZGF0YS50eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdHlwZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggdHlwZS50b0xvd2VyQ2FzZSgpID09PSAnc2NlbmUnICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XG5cdFx0XHRcdG9uTG9hZCggb2JqZWN0Lmdlb21ldHJ5LCBvYmplY3QubWF0ZXJpYWxzICk7XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VNb2RlbCgganNvbiwgZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0ZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcblxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaSwgaiwgZmksXG5cblx0XHRcdFx0XHRvZmZzZXQsIHpMZW5ndGgsXG5cblx0XHRcdFx0XHRjb2xvckluZGV4LCBub3JtYWxJbmRleCwgdXZJbmRleCwgbWF0ZXJpYWxJbmRleCxcblxuXHRcdFx0XHRcdHR5cGUsXG5cdFx0XHRcdFx0aXNRdWFkLFxuXHRcdFx0XHRcdGhhc01hdGVyaWFsLFxuXHRcdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdixcblx0XHRcdFx0XHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxuXHRcdFx0XHRcdGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yLFxuXG5cdFx0XHRcdFx0dmVydGV4LCBmYWNlLCBmYWNlQSwgZmFjZUIsIGhleCwgbm9ybWFsLFxuXG5cdFx0XHRcdFx0dXZMYXllciwgdXYsIHUsIHYsXG5cblx0XHRcdFx0XHRmYWNlcyA9IGpzb24uZmFjZXMsXG5cdFx0XHRcdFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxuXHRcdFx0XHRcdG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXG5cdFx0XHRcdFx0Y29sb3JzID0ganNvbi5jb2xvcnMsXG5cblx0XHRcdFx0XHRzY2FsZSA9IGpzb24uc2NhbGUsXG5cblx0XHRcdFx0XHRuVXZMYXllcnMgPSAwO1xuXG5cblx0XHRcdFx0aWYgKCBqc29uLnV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gZGlzcmVnYXJkIGVtcHR5IGFycmF5c1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHRcdHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0dmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG5cdFx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHRcdHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdGlzUXVhZCA9IGlzQml0U2V0KCB0eXBlLCAwICk7XG5cdFx0XHRcdFx0aGFzTWF0ZXJpYWwgPSBpc0JpdFNldCggdHlwZSwgMSApO1xuXHRcdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdiA9IGlzQml0U2V0KCB0eXBlLCAzICk7XG5cdFx0XHRcdFx0aGFzRmFjZU5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XG5cdFx0XHRcdFx0aGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XG5cdFx0XHRcdFx0aGFzRmFjZUNvbG9yID0gaXNCaXRTZXQoIHR5cGUsIDYgKTtcblx0XHRcdFx0XHRoYXNGYWNlVmVydGV4Q29sb3IgPSBpc0JpdFNldCggdHlwZSwgNyApO1xuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJ0eXBlXCIsIHR5cGUsIFwiYml0c1wiLCBpc1F1YWQsIGhhc01hdGVyaWFsLCBoYXNGYWNlVmVydGV4VXYsIGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yKTtcblxuXHRcdFx0XHRcdGlmICggaXNRdWFkICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlQSA9IG5ldyBGYWNlMygpO1xuXHRcdFx0XHRcdFx0ZmFjZUEuYSA9IGZhY2VzWyBvZmZzZXQgXTtcblx0XHRcdFx0XHRcdGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0XHRcdFx0ZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cblx0XHRcdFx0XHRcdGZhY2VCID0gbmV3IEZhY2UzKCk7XG5cdFx0XHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcblx0XHRcdFx0XHRcdGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xuXHRcdFx0XHRcdFx0ZmFjZUIuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cblx0XHRcdFx0XHRcdG9mZnNldCArPSA0O1xuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdFx0XHRmYWNlQi5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuXHRcdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR1diA9IG5ldyBWZWN0b3IyKCB1LCB2ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG5cdFx0XHRcdFx0XHRcdGZhY2VBLm5vcm1hbC5zZXQoXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XG5cdFx0XHRcdFx0XHRcdGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggaGV4ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IENvbG9yKCBoZXggKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGZhY2UgPSBuZXcgRmFjZTMoKTtcblx0XHRcdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG5cdFx0XHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcblx0XHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVmVjdG9yMiggdSwgdiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0XHRmYWNlLm5vcm1hbC5zZXQoXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoXG5cdFx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRcdGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBwYXJzZVNraW4oIGpzb24sIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcblxuXHRcdFx0XHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHggPSBqc29uLnNraW5XZWlnaHRzWyBpIF07XG5cdFx0XHRcdFx0XHR2YXIgeSA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF0gOiAwO1xuXHRcdFx0XHRcdFx0dmFyIHogPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMiBdIDogMDtcblx0XHRcdFx0XHRcdHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBWZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhID0ganNvbi5za2luSW5kaWNlc1sgaSBdO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcblx0XHRcdFx0XHRcdHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XG5cdFx0XHRcdFx0XHR2YXIgZCA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAzIF0gOiAwO1xuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVmVjdG9yNCggYSwgYiwgYywgZCApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgJiYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggIT09IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCB8fCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggIT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCArICcpLCBhbmQgc2tpbldlaWdodHMgKCcgKyBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKyAnKSBzaG91bGQgbWF0Y2guJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBwYXJzZU1vcnBoaW5nKCBqc29uLCBnZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgc2NhbGUgPSBqc29uLnNjYWxlO1xuXG5cdFx0XHRcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcblxuXHRcdFx0XHRcdFx0dmFyIGRzdFZlcnRpY2VzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG5cdFx0XHRcdFx0XHR2YXIgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0XHRcdFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XG5cdFx0XHRcdFx0XHRcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcblx0XHRcdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xuXG5cdFx0XHRcdFx0XHRcdGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICgganNvbi5tb3JwaENvbG9ycyAhPT0gdW5kZWZpbmVkICYmIGpzb24ubW9ycGhDb2xvcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFwibW9ycGhDb2xvcnNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2luZyB0aGVtIGFzIGZhY2UgY29sb3JzLicgKTtcblxuXHRcdFx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXHRcdFx0XHRcdHZhciBtb3JwaENvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnNbIDAgXS5jb2xvcnM7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlc1sgaSBdLmNvbG9yLmZyb21BcnJheSggbW9ycGhDb2xvcnMsIGkgKiAzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9ucygganNvbiwgZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0dmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcblxuXHRcdFx0XHQvLyBwYXJzZSBvbGQgc3R5bGUgQm9uZS9IaWVyYXJjaHkgYW5pbWF0aW9uc1xuXHRcdFx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRcdGlmICgganNvbi5hbmltYXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0YW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMuY29uY2F0KCBqc29uLmFuaW1hdGlvbnMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlQW5pbWF0aW9uKCBhbmltYXRpb25zWyBpIF0sIGdlb21ldHJ5LmJvbmVzICk7XG5cdFx0XHRcdFx0aWYgKCBjbGlwICkgb3V0cHV0QW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIGltcGxpY2l0IG1vcnBoIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgYW4gYXBwcm9wcmFpdGUgRlBTIGlzIGZvciBtb3JwaCB0YXJnZXQgYW5pbWF0aW9ucyAtLSBkZWZhdWx0aW5nIHRvIDEwLCBidXQgcmVhbGx5IGl0IGlzIGNvbXBsZXRlbHkgYXJiaXRyYXJ5LlxuXHRcdFx0XHRcdHZhciBtb3JwaEFuaW1hdGlvbkNsaXBzID0gQW5pbWF0aW9uQ2xpcC5DcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggZ2VvbWV0cnkubW9ycGhUYXJnZXRzLCAxMCApO1xuXHRcdFx0XHRcdG91dHB1dEFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zLmNvbmNhdCggbW9ycGhBbmltYXRpb25DbGlwcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG91dHB1dEFuaW1hdGlvbnMubGVuZ3RoID4gMCApIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBvdXRwdXRBbmltYXRpb25zO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYXJzZSgganNvbiwgdGV4dHVyZVBhdGggKSB7XG5cblx0XHRcdFx0aWYgKCBqc29uLmRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIEdlb21ldHJ5IDQuMCBzcGVjXG5cdFx0XHRcdFx0anNvbiA9IGpzb24uZGF0YTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRqc29uLnNjYWxlID0gMS4wIC8ganNvbi5zY2FsZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0anNvbi5zY2FsZSA9IDEuMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG5cblx0XHRcdFx0cGFyc2VNb2RlbCgganNvbiwgZ2VvbWV0cnkgKTtcblx0XHRcdFx0cGFyc2VTa2luKCBqc29uLCBnZW9tZXRyeSApO1xuXHRcdFx0XHRwYXJzZU1vcnBoaW5nKCBqc29uLCBnZW9tZXRyeSApO1xuXHRcdFx0XHRwYXJzZUFuaW1hdGlvbnMoIGpzb24sIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0XHRcdGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IExvYWRlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoLCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHRcdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fSApKClcblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIE9iamVjdExvYWRlciggbWFuYWdlciApIHtcblxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXHRcdHRoaXMudGV4dHVyZVBhdGggPSAnJztcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggT2JqZWN0TG9hZGVyLnByb3RvdHlwZSwge1xuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnRleHR1cmVQYXRoID09PSAnJyApIHtcblxuXHRcdFx0XHR0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0XHR2YXIganNvbiA9IG51bGw7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICE9PSB1bmRlZmluZWQgKSBvbkVycm9yKCBlcnJvciApO1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFOk9iamVjdExvYWRlcjogQ2FuXFwndCBwYXJzZSAnICsgdXJsICsgJy4nLCBlcnJvci5tZXNzYWdlICk7XG5cblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdFx0aWYgKCBtZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdnZW9tZXRyeScgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCArICcuIFVzZSBUSFJFRS5KU09OTG9hZGVyIGluc3RlYWQuJyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUucGFyc2UoIGpzb24sIG9uTG9hZCApO1xuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyc2VTaGFwZSgganNvbi5zaGFwZXMgKTtcblx0XHRcdHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcywgc2hhcGVzICk7XG5cblx0XHRcdHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMucGFyc2VUZXh0dXJlcygganNvbi50ZXh0dXJlcywgaW1hZ2VzICk7XG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XG5cblx0XHRcdHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XG5cblx0XHRcdGlmICgganNvbi5hbmltYXRpb25zICkge1xuXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoIGpzb24uYW5pbWF0aW9ucyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdH0sXG5cblx0XHRwYXJzZVNoYXBlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHRcdHZhciBzaGFwZXMgPSB7fTtcblxuXHRcdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHNoYXBlID0gbmV3IFNoYXBlKCkuZnJvbUpTT04oIGpzb25bIGkgXSApO1xuXG5cdFx0XHRcdFx0c2hhcGVzWyBzaGFwZS51dWlkIF0gPSBzaGFwZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNoYXBlcztcblxuXHRcdH0sXG5cblx0XHRwYXJzZUdlb21ldHJpZXM6IGZ1bmN0aW9uICgganNvbiwgc2hhcGVzICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnlMb2FkZXIgPSBuZXcgSlNPTkxvYWRlcigpO1xuXHRcdFx0XHR2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZ2VvbWV0cnk7XG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50c1xuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdCb3hHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRjYXNlICdCb3hCdWZmZXJHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEud2lkdGgsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoU2VnbWVudHNcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c1RvcCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c0JvdHRvbSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5vcGVuRW5kZWQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ29uZUdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ0NvbmVCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1NwaGVyZUdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0RvZGVjYWhlZHJvbkdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ0RvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ1RldHJhaGVkcm9uR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnUmluZ0dlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ1JpbmdCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5pbm5lclJhZGl1cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLm91dGVyUmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnBoaVNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnVG9ydXNCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5hcmNcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVG9ydXNLbm90R2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnVG9ydXNLbm90QnVmZmVyR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnFcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnTGF0aGVHZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRjYXNlICdMYXRoZUJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnBvaW50cyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucGhpU3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlMZW5ndGhcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnUG9seWhlZHJvbkdlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ1BvbHloZWRyb25CdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS52ZXJ0aWNlcyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmluZGljZXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxzXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1NoYXBlR2VvbWV0cnknOlxuXHRcdFx0XHRcdFx0Y2FzZSAnU2hhcGVCdWZmZXJHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdFx0dmFyIGdlb21ldHJ5U2hhcGVzID0gW107XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgZGF0YS5zaGFwZXNbIGkgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnlTaGFwZXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5jdXJ2ZVNlZ21lbnRzXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcblxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0XHRcdGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyaWVzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVzICkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0ge307XG5cblx0XHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcblx0XHRcdFx0bG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhID0ganNvblsgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdNdWx0aU1hdGVyaWFsJyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gRGVwcmVjYXRlZFxuXG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgZGF0YS5tYXRlcmlhbHMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goIGxvYWRlci5wYXJzZSggZGF0YS5tYXRlcmlhbHNbIGogXSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IGFycmF5O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlQW5pbWF0aW9uczogZnVuY3Rpb24gKCBqc29uICkge1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25bIGkgXSApO1xuXG5cdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhbmltYXRpb25zO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlSW1hZ2VzOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHRcdHZhciBpbWFnZXMgPSB7fTtcblxuXHRcdFx0ZnVuY3Rpb24gbG9hZEltYWdlKCB1cmwgKSB7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRcdHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRcdH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XG5cblx0XHRcdFx0dmFyIGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggbWFuYWdlciApO1xuXHRcdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW1hZ2UgPSBqc29uWyBpIF07XG5cdFx0XHRcdFx0dmFyIHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QoIGltYWdlLnVybCApID8gaW1hZ2UudXJsIDogc2NvcGUudGV4dHVyZVBhdGggKyBpbWFnZS51cmw7XG5cblx0XHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uICgganNvbiwgaW1hZ2VzICkge1xuXG5cdFx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSwgdHlwZSApIHtcblxuXHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlWyB2YWx1ZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG5cdFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFwiaW1hZ2VcIiBzcGVjaWZpZWQgZm9yJywgZGF0YS51dWlkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nLCBURVhUVVJFX01BUFBJTkcgKTtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggZGF0YS5vZmZzZXQgKTtcblx0XHRcdFx0XHRpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIGRhdGEucmVwZWF0ICk7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmNlbnRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5jZW50ZXIuZnJvbUFycmF5KCBkYXRhLmNlbnRlciApO1xuXHRcdFx0XHRcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEud3JhcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0sIFRFWFRVUkVfV1JBUFBJTkcgKTtcblx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSwgVEVYVFVSRV9XUkFQUElORyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciwgVEVYVFVSRV9GSUxURVIgKTtcblx0XHRcdFx0XHRpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyLCBURVhUVVJFX0ZJTFRFUiApO1xuXHRcdFx0XHRcdGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZmxpcFkgPSBkYXRhLmZsaXBZO1xuXG5cdFx0XHRcdFx0dGV4dHVyZXNbIGRhdGEudXVpZCBdID0gdGV4dHVyZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmVzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAoIGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApIHtcblxuXHRcdFx0dmFyIG9iamVjdDtcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIG5hbWUgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgbmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKCBuYW1lICkge1xuXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdXVpZCA9IG5hbWVbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbHNbIHV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgdXVpZCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsc1sgdXVpZCBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XG5cblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ1NjZW5lJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTY2VuZSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBOdW1iZXIuaXNJbnRlZ2VyKCBkYXRhLmJhY2tncm91bmQgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IG5ldyBDb2xvciggZGF0YS5iYWNrZ3JvdW5kICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZGF0YS5mb2cgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nJyApIHtcblxuXHRcdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZyggZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLm5lYXIsIGRhdGEuZm9nLmZhciApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nRXhwMicgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0LmZvZyA9IG5ldyBGb2dFeHAyKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cuZGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmZvY3VzICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZm9jdXMgPSBkYXRhLmZvY3VzO1xuXHRcdFx0XHRcdGlmICggZGF0YS56b29tICE9PSB1bmRlZmluZWQgKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbUdhdWdlID0gZGF0YS5maWxtR2F1Z2U7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmZpbG1PZmZzZXQgIT09IHVuZGVmaW5lZCApIG9iamVjdC5maWxtT2Zmc2V0ID0gZGF0YS5maWxtT2Zmc2V0O1xuXHRcdFx0XHRcdGlmICggZGF0YS52aWV3ICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkYXRhLnZpZXcgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1NraW5uZWRNZXNoJzpcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZU9iamVjdCgpIGRvZXMgbm90IHN1cHBvcnQgU2tpbm5lZE1lc2ggeWV0LicgKTtcblxuXHRcdFx0XHRjYXNlICdNZXNoJzpcblxuXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xPRCc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTE9EKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdMaW5lJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApLCBkYXRhLm1vZGUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xpbmVMb29wJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lTG9vcCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTGluZVNlZ21lbnRzJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1BvaW50Q2xvdWQnOlxuXHRcdFx0XHRjYXNlICdQb2ludHMnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFBvaW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3ByaXRlJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0dyb3VwJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXG5cdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XG5cdFx0XHRcdG9iamVjdC5tYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcblx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG5cdFx0XHRcdGlmICggZGF0YS5xdWF0ZXJuaW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoIGRhdGEucXVhdGVybmlvbiApO1xuXHRcdFx0XHRpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmNhc3RTaGFkb3cgPSBkYXRhLmNhc3RTaGFkb3c7XG5cdFx0XHRpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cblx0XHRcdGlmICggZGF0YS5zaGFkb3cgKSB7XG5cblx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5iaWFzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xuXHRcdFx0XHRpZiAoIGRhdGEuc2hhZG93LnJhZGl1cyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5yYWRpdXMgPSBkYXRhLnNoYWRvdy5yYWRpdXM7XG5cdFx0XHRcdGlmICggZGF0YS5zaGFkb3cubWFwU2l6ZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5tYXBTaXplLmZyb21BcnJheSggZGF0YS5zaGFkb3cubWFwU2l6ZSApO1xuXHRcdFx0XHRpZiAoIGRhdGEuc2hhZG93LmNhbWVyYSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5jYW1lcmEgPSB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLnNoYWRvdy5jYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XG5cdFx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG5cblx0XHRcdGlmICggZGF0YS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IGRhdGEuY2hpbGRyZW47XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggY2hpbGRyZW5bIGkgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xuXG5cdFx0XHRcdHZhciBsZXZlbHMgPSBkYXRhLmxldmVscztcblxuXHRcdFx0XHRmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoICd1dWlkJywgbGV2ZWwub2JqZWN0ICk7XG5cblx0XHRcdFx0XHRpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdHZhciBURVhUVVJFX01BUFBJTkcgPSB7XG5cdFx0VVZNYXBwaW5nOiBVVk1hcHBpbmcsXG5cdFx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXG5cdFx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsXG5cdFx0RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyxcblx0XHRTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzogU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcsXG5cdFx0Q3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxuXHRcdEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZ1xuXHR9O1xuXG5cdHZhciBURVhUVVJFX1dSQVBQSU5HID0ge1xuXHRcdFJlcGVhdFdyYXBwaW5nOiBSZXBlYXRXcmFwcGluZyxcblx0XHRDbGFtcFRvRWRnZVdyYXBwaW5nOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRcdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcblx0fTtcblxuXHR2YXIgVEVYVFVSRV9GSUxURVIgPSB7XG5cdFx0TmVhcmVzdEZpbHRlcjogTmVhcmVzdEZpbHRlcixcblx0XHROZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIsXG5cdFx0TmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcjogTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcixcblx0XHRMaW5lYXJGaWx0ZXI6IExpbmVhckZpbHRlcixcblx0XHRMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyLFxuXHRcdExpbmVhck1pcE1hcExpbmVhckZpbHRlcjogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgdGhlc3BpdGUgLyBodHRwOi8vY2xpY2t0b3JlbGVhc2UuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBJbWFnZUJpdG1hcExvYWRlciggbWFuYWdlciApIHtcblxuXHRcdGlmICggdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGNyZWF0ZUltYWdlQml0bWFwKCkgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBmZXRjaCgpIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlciAhPT0gdW5kZWZpbmVkID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblx0XHR0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdEltYWdlQml0bWFwTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBJbWFnZUJpdG1hcExvYWRlcixcblxuXHRcdHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uIGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XG5cblx0XHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xuXG5cdFx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRcdH0sIDAgKTtcblxuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZldGNoKCB1cmwgKS50aGVuKCBmdW5jdGlvbiAoIHJlcyApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmVzLmJsb2IoKTtcblxuXHRcdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggYmxvYiApIHtcblxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoIGJsb2IsIHNjb3BlLm9wdGlvbnMgKTtcblxuXHRcdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggaW1hZ2VCaXRtYXAgKSB7XG5cblx0XHRcdFx0Q2FjaGUuYWRkKCB1cmwsIGltYWdlQml0bWFwICk7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGltYWdlQml0bWFwICk7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSApLmNhdGNoKCBmdW5jdGlvbiAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZSApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSxcblxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIC8qIHZhbHVlICovICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0ICogbWluaW1hbCBjbGFzcyBmb3IgcHJveGluZyBmdW5jdGlvbnMgdG8gUGF0aC4gUmVwbGFjZXMgb2xkIFwiZXh0cmFjdFN1YnBhdGhzKClcIlxuXHQgKiovXG5cblx0ZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlUGF0aCc7XG5cblx0XHR0aGlzLnN1YlBhdGhzID0gW107XG5cdFx0dGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFNoYXBlUGF0aC5wcm90b3R5cGUsIHtcblxuXHRcdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBhdGgoKTtcblx0XHRcdHRoaXMuc3ViUGF0aHMucHVzaCggdGhpcy5jdXJyZW50UGF0aCApO1xuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuXHRcdH0sXG5cblx0XHRsaW5lVG86IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5saW5lVG8oIHgsIHkgKTtcblxuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcblxuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKTtcblxuXHRcdH0sXG5cblx0XHRiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XG5cblx0XHRcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApO1xuXG5cdFx0fSxcblxuXHRcdHNwbGluZVRocnU6IGZ1bmN0aW9uICggcHRzICkge1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUoIHB0cyApO1xuXG5cdFx0fSxcblxuXHRcdHRvU2hhcGVzOiBmdW5jdGlvbiAoIGlzQ0NXLCBub0hvbGVzICkge1xuXG5cdFx0XHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XG5cblx0XHRcdFx0dmFyIHNoYXBlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG5cdFx0XHRcdFx0dmFyIHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XG5cdFx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHNoYXBlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbiggaW5QdCwgaW5Qb2x5Z29uICkge1xuXG5cdFx0XHRcdHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcblxuXHRcdFx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuXHRcdFx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXG5cdFx0XHRcdC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcblx0XHRcdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcblx0XHRcdFx0dmFyIGluc2lkZSA9IGZhbHNlO1xuXHRcdFx0XHRmb3IgKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcCBdO1xuXHRcdFx0XHRcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XG5cblx0XHRcdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XG5cdFx0XHRcdFx0dmFyIGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggZWRnZUR5ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cdFx0XHRcdFx0XHRpZiAoIGVkZ2VEeSA8IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBxIF07IGVkZ2VEeCA9IC0gZWRnZUR4O1xuXHRcdFx0XHRcdFx0XHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07IGVkZ2VEeSA9IC0gZWRnZUR5O1xuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpblB0LnggPT09IGVkZ2VMb3dQdC54IClcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdFx0XHQvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPT09IDAgKVx0XHRcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlIDwgMCApIFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG5cdFx0XHRcdFx0XHRpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBcdFx0Y29udGludWU7XHRcdFx0Ly8gcGFyYWxsZWxcblx0XHRcdFx0XHRcdC8vIGVkZ2UgbGllcyBvbiB0aGUgc2FtZSBob3Jpem9udGFsIGxpbmUgYXMgaW5QdFxuXHRcdFx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxuXHRcdFx0XHRcdFx0XHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVx0XHRyZXR1cm5cdHRydWU7XHQvLyBpblB0OiBQb2ludCBvbiBjb250b3VyICFcblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm5cdGluc2lkZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXNDbG9ja1dpc2UgPSBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xuXG5cdFx0XHR2YXIgc3ViUGF0aHMgPSB0aGlzLnN1YlBhdGhzO1xuXHRcdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cblx0XHRcdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG5cdFx0XHR2YXIgc29saWQsIHRtcFBhdGgsIHRtcFNoYXBlLCBzaGFwZXMgPSBbXTtcblxuXHRcdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XG5cdFx0XHRcdHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XG5cdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHRcdFx0cmV0dXJuIHNoYXBlcztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaG9sZXNGaXJzdCA9ICEgaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcblx0XHRcdGhvbGVzRmlyc3QgPSBpc0NDVyA/ICEgaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cblx0XHRcdHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG5cdFx0XHR2YXIgbmV3U2hhcGVzID0gW107XG5cdFx0XHR2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuXHRcdFx0dmFyIG1haW5JZHggPSAwO1xuXHRcdFx0dmFyIHRtcFBvaW50cztcblxuXHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcblx0XHRcdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcblx0XHRcdFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XG5cdFx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XG5cblx0XHRcdFx0aWYgKCBzb2xpZCApIHtcblxuXHRcdFx0XHRcdGlmICggKCAhIGhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1sgbWFpbklkeCBdICkgKVx0bWFpbklkeCArKztcblxuXHRcdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XG5cdFx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuXHRcdFx0XHRcdGlmICggaG9sZXNGaXJzdCApXHRtYWluSWR4ICsrO1xuXHRcdFx0XHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xuXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY3cnLCBpKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWyAwIF0gfSApO1xuXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuXHRcdFx0aWYgKCAhIG5ld1NoYXBlc1sgMCBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0XHRcdGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0dmFyIGFtYmlndW91cyA9IGZhbHNlO1xuXHRcdFx0XHR2YXIgdG9DaGFuZ2UgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcblxuXHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcblxuXHRcdFx0XHRcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaG8gPSBzaG9bIGhJZHggXTtcblx0XHRcdFx0XHRcdHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaXNQb2ludEluc2lkZVBvbHlnb24oIGhvLnAsIG5ld1NoYXBlc1sgczJJZHggXS5wICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHNJZHggIT09IHMySWR4IClcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0ucHVzaCggaG8gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJhbWJpZ3VvdXM6IFwiLCBhbWJpZ3VvdXMpO1xuXHRcdFx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcblx0XHRcdFx0XHRpZiAoICEgYW1iaWd1b3VzIClcdG5ld1NoYXBlSG9sZXMgPSBiZXR0ZXJTaGFwZUhvbGVzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG1wSG9sZXM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xuXHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblx0XHRcdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBGb250KCBkYXRhICkge1xuXG5cdFx0dGhpcy50eXBlID0gJ0ZvbnQnO1xuXG5cdFx0dGhpcy5kYXRhID0gZGF0YTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggRm9udC5wcm90b3R5cGUsIHtcblxuXHRcdGlzRm9udDogdHJ1ZSxcblxuXHRcdGdlbmVyYXRlU2hhcGVzOiBmdW5jdGlvbiAoIHRleHQsIHNpemUsIGRpdmlzaW9ucyApIHtcblxuXHRcdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gMTAwO1xuXHRcdFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDQ7XG5cblx0XHRcdHZhciBzaGFwZXMgPSBbXTtcblx0XHRcdHZhciBwYXRocyA9IGNyZWF0ZVBhdGhzKCB0ZXh0LCBzaXplLCBkaXZpc2lvbnMsIHRoaXMuZGF0YSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNoYXBlcztcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0ZnVuY3Rpb24gY3JlYXRlUGF0aHMoIHRleHQsIHNpemUsIGRpdmlzaW9ucywgZGF0YSApIHtcblxuXHRcdHZhciBjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApO1xuXHRcdHZhciBzY2FsZSA9IHNpemUgLyBkYXRhLnJlc29sdXRpb247XG5cdFx0dmFyIGxpbmVfaGVpZ2h0ID0gKCBkYXRhLmJvdW5kaW5nQm94LnlNYXggLSBkYXRhLmJvdW5kaW5nQm94LnlNaW4gKyBkYXRhLnVuZGVybGluZVRoaWNrbmVzcyApICogc2NhbGU7XG5cblx0XHR2YXIgcGF0aHMgPSBbXTtcblxuXHRcdHZhciBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGFyID0gY2hhcnNbIGkgXTtcblxuXHRcdFx0aWYgKCBjaGFyID09PSAnXFxuJyApIHtcblxuXHRcdFx0XHRvZmZzZXRYID0gMDtcblx0XHRcdFx0b2Zmc2V0WSAtPSBsaW5lX2hlaWdodDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgcmV0ID0gY3JlYXRlUGF0aCggY2hhciwgZGl2aXNpb25zLCBzY2FsZSwgb2Zmc2V0WCwgb2Zmc2V0WSwgZGF0YSApO1xuXHRcdFx0XHRvZmZzZXRYICs9IHJldC5vZmZzZXRYO1xuXHRcdFx0XHRwYXRocy5wdXNoKCByZXQucGF0aCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aHM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoIGNoYXIsIGRpdmlzaW9ucywgc2NhbGUsIG9mZnNldFgsIG9mZnNldFksIGRhdGEgKSB7XG5cblx0XHR2YXIgZ2x5cGggPSBkYXRhLmdseXBoc1sgY2hhciBdIHx8IGRhdGEuZ2x5cGhzWyAnPycgXTtcblxuXHRcdGlmICggISBnbHlwaCApIHJldHVybjtcblxuXHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXG5cdFx0dmFyIHgsIHksIGNweCwgY3B5LCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyO1xuXG5cdFx0aWYgKCBnbHlwaC5vICkge1xuXG5cdFx0XHR2YXIgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGw7ICkge1xuXG5cdFx0XHRcdHZhciBhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XG5cblx0XHRcdFx0c3dpdGNoICggYWN0aW9uICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbSc6IC8vIG1vdmVUb1xuXG5cdFx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0eSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcblxuXHRcdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsJzogLy8gbGluZVRvXG5cblx0XHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XG5cdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXG5cdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCwgeSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvXG5cblx0XHRcdFx0XHRcdGNweCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcblx0XHRcdFx0XHRcdGNweSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcblx0XHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XG5cdFx0XHRcdFx0XHRjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXG5cdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGNweDEsIGNweTEsIGNweCwgY3B5ICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYic6IC8vIGJlemllckN1cnZlVG9cblxuXHRcdFx0XHRcdFx0Y3B4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0Y3B5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xuXHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcblx0XHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XG5cdFx0XHRcdFx0XHRjcHgyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xuXHRcdFx0XHRcdFx0Y3B5MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcblxuXHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB7IG9mZnNldFg6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6IHBhdGggfTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEZvbnRMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggRm9udExvYWRlci5wcm90b3R5cGUsIHtcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdFx0dmFyIGpzb247XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Gb250TG9hZGVyOiB0eXBlZmFjZS5qcyBzdXBwb3J0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSB0eXBlZmFjZS5qc29uIGluc3RlYWQuJyApO1xuXHRcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0LnN1YnN0cmluZyggNjUsIHRleHQubGVuZ3RoIC0gMiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmb250ID0gc2NvcGUucGFyc2UoIGpzb24gKTtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggZm9udCApO1xuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBGb250KCBqc29uICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdHZhciBjb250ZXh0O1xuXG5cdHZhciBBdWRpb0NvbnRleHQgPSB7XG5cblx0XHRnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggY29udGV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb250ZXh0O1xuXG5cdFx0fSxcblxuXHRcdHNldENvbnRleHQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnRleHQgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIFJlZWNlIEFhcm9uIExlY3JpdmFpbiAvIGh0dHA6Ly9yZWVjZW5vdGVzLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gQXVkaW9Mb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggQXVkaW9Mb2FkZXIucHJvdG90eXBlLCB7XG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdFx0dmFyIGNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xuXG5cdFx0XHRcdGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCBidWZmZXIsIGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIGF1ZGlvQnVmZmVyICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBTdGVyZW9DYW1lcmEoKSB7XG5cblx0XHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcblxuXHRcdHRoaXMuYXNwZWN0ID0gMTtcblxuXHRcdHRoaXMuZXllU2VwID0gMC4wNjQ7XG5cblx0XHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xuXHRcdHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHR0aGlzLmNhbWVyYVIubGF5ZXJzLmVuYWJsZSggMiApO1xuXHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFN0ZXJlb0NhbWVyYS5wcm90b3R5cGUsIHtcblxuXHRcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBpbnN0YW5jZSwgZm9jdXMsIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIHpvb20sIGV5ZVNlcDtcblxuXHRcdFx0dmFyIGV5ZVJpZ2h0ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdHZhciBleWVMZWZ0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xuXG5cdFx0XHRcdHZhciBuZWVkc1VwZGF0ZSA9IGluc3RhbmNlICE9PSB0aGlzIHx8IGZvY3VzICE9PSBjYW1lcmEuZm9jdXMgfHwgZm92ICE9PSBjYW1lcmEuZm92IHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0IHx8IG5lYXIgIT09IGNhbWVyYS5uZWFyIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZhciAhPT0gY2FtZXJhLmZhciB8fCB6b29tICE9PSBjYW1lcmEuem9vbSB8fCBleWVTZXAgIT09IHRoaXMuZXllU2VwO1xuXG5cdFx0XHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0XHRpbnN0YW5jZSA9IHRoaXM7XG5cdFx0XHRcdFx0Zm9jdXMgPSBjYW1lcmEuZm9jdXM7XG5cdFx0XHRcdFx0Zm92ID0gY2FtZXJhLmZvdjtcblx0XHRcdFx0XHRhc3BlY3QgPSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3Q7XG5cdFx0XHRcdFx0bmVhciA9IGNhbWVyYS5uZWFyO1xuXHRcdFx0XHRcdGZhciA9IGNhbWVyYS5mYXI7XG5cdFx0XHRcdFx0em9vbSA9IGNhbWVyYS56b29tO1xuXG5cdFx0XHRcdFx0Ly8gT2ZmLWF4aXMgc3RlcmVvc2NvcGljIGVmZmVjdCBiYXNlZCBvblxuXHRcdFx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXG5cblx0XHRcdFx0XHR2YXIgcHJvamVjdGlvbk1hdHJpeCA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNsb25lKCk7XG5cdFx0XHRcdFx0ZXllU2VwID0gdGhpcy5leWVTZXAgLyAyO1xuXHRcdFx0XHRcdHZhciBleWVTZXBPblByb2plY3Rpb24gPSBleWVTZXAgKiBuZWFyIC8gZm9jdXM7XG5cdFx0XHRcdFx0dmFyIHltYXggPSAoIG5lYXIgKiBNYXRoLnRhbiggX01hdGguREVHMlJBRCAqIGZvdiAqIDAuNSApICkgLyB6b29tO1xuXHRcdFx0XHRcdHZhciB4bWluLCB4bWF4O1xuXG5cdFx0XHRcdFx0Ly8gdHJhbnNsYXRlIHhPZmZzZXRcblxuXHRcdFx0XHRcdGV5ZUxlZnQuZWxlbWVudHNbIDEyIF0gPSAtIGV5ZVNlcDtcblx0XHRcdFx0XHRleWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcDtcblxuXHRcdFx0XHRcdC8vIGZvciBsZWZ0IGV5ZVxuXG5cdFx0XHRcdFx0eG1pbiA9IC0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblx0XHRcdFx0XHR4bWF4ID0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblxuXHRcdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuXHRcdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcblxuXHRcdFx0XHRcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0XHRcdC8vIGZvciByaWdodCBleWVcblxuXHRcdFx0XHRcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cblx0XHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF0gPSAyICogbmVhciAvICggeG1heCAtIHhtaW4gKTtcblx0XHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gPSAoIHhtYXggKyB4bWluICkgLyAoIHhtYXggLSB4bWluICk7XG5cblx0XHRcdFx0XHR0aGlzLmNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBwcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuY2FtZXJhTC5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseSggZXllTGVmdCApO1xuXHRcdFx0XHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZVJpZ2h0ICk7XG5cblx0XHRcdH07XG5cblx0XHR9ICkoKVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXG5cdCAqXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxuXHQgKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBDdWJlQ2FtZXJhKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xuXG5cdFx0dmFyIGZvdiA9IDkwLCBhc3BlY3QgPSAxO1xuXG5cdFx0dmFyIGNhbWVyYVBYID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRjYW1lcmFQWC5sb29rQXQoIG5ldyBWZWN0b3IzKCAxLCAwLCAwICkgKTtcblx0XHR0aGlzLmFkZCggY2FtZXJhUFggKTtcblxuXHRcdHZhciBjYW1lcmFOWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYU5YLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdFx0Y2FtZXJhTlgubG9va0F0KCBuZXcgVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcblx0XHR0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuXHRcdHZhciBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYVBZLnVwLnNldCggMCwgMCwgMSApO1xuXHRcdGNhbWVyYVBZLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFQWSApO1xuXG5cdFx0dmFyIGNhbWVyYU5ZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRjYW1lcmFOWS5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAtIDEsIDAgKSApO1xuXHRcdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xuXG5cdFx0dmFyIGNhbWVyYVBaID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdFx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0XHRjYW1lcmFQWi5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAwLCAxICkgKTtcblx0XHR0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuXHRcdHZhciBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRcdGNhbWVyYU5aLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdFx0Y2FtZXJhTloubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgMCwgLSAxICkgKTtcblx0XHR0aGlzLmFkZCggY2FtZXJhTlogKTtcblxuXHRcdHZhciBvcHRpb25zID0geyBmb3JtYXQ6IFJHQkZvcm1hdCwgbWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogTGluZWFyRmlsdGVyIH07XG5cblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgb3B0aW9ucyApO1xuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiQ3ViZUNhbWVyYVwiO1xuXG5cdFx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuXHRcdFx0dmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDA7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDM7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcblxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IGk7XG5cdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdFx0cmVuZGVyZXIuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xuXG5cdFx0fTtcblxuXHR9XG5cblx0Q3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcblx0Q3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJlQ2FtZXJhO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBBdWRpb0xpc3RlbmVyKCkge1xuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuXG5cdFx0dGhpcy5jb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcblxuXHRcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG5cdH1cblxuXHRBdWRpb0xpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQXVkaW9MaXN0ZW5lcixcblxuXHRcdGdldElucHV0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdhaW47XG5cblx0XHR9LFxuXG5cdFx0cmVtb3ZlRmlsdGVyOiBmdW5jdGlvbiAoICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblx0XHRcdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXHRcdFx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRnZXRGaWx0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsdGVyO1xuXG5cdFx0fSxcblxuXHRcdHNldEZpbHRlcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XG5cdFx0XHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHRcdHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdFx0fSxcblxuXHRcdGdldE1hc3RlclZvbHVtZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0c2V0TWFzdGVyVm9sdW1lOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHZhciBvcmllbnRhdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRcdFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xuXHRcdFx0XHR2YXIgdXAgPSB0aGlzLnVwO1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcblxuXHRcdFx0XHRvcmllbnRhdGlvbi5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRcdGlmICggbGlzdGVuZXIucG9zaXRpb25YICkge1xuXG5cdFx0XHRcdFx0bGlzdGVuZXIucG9zaXRpb25YLnNldFZhbHVlQXRUaW1lKCBwb3NpdGlvbi54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcblx0XHRcdFx0XHRsaXN0ZW5lci5wb3NpdGlvblkuc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRcdGxpc3RlbmVyLnBvc2l0aW9uWi5zZXRWYWx1ZUF0VGltZSggcG9zaXRpb24ueiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XG5cdFx0XHRcdFx0bGlzdGVuZXIuZm9yd2FyZFguc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRcdGxpc3RlbmVyLmZvcndhcmRZLnNldFZhbHVlQXRUaW1lKCBvcmllbnRhdGlvbi55LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcblx0XHRcdFx0XHRsaXN0ZW5lci5mb3J3YXJkWi5zZXRWYWx1ZUF0VGltZSggb3JpZW50YXRpb24ueiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XG5cdFx0XHRcdFx0bGlzdGVuZXIudXBYLnNldFZhbHVlQXRUaW1lKCB1cC54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcblx0XHRcdFx0XHRsaXN0ZW5lci51cFkuc2V0VmFsdWVBdFRpbWUoIHVwLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xuXHRcdFx0XHRcdGxpc3RlbmVyLnVwWi5zZXRWYWx1ZUF0VGltZSggdXAueiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cdFx0XHRcdFx0bGlzdGVuZXIuc2V0T3JpZW50YXRpb24oIG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIHVwLngsIHVwLnksIHVwLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9ICkoKVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBSZWVjZSBBYXJvbiBMZWNyaXZhaW4gLyBodHRwOi8vcmVlY2Vub3Rlcy5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEF1ZGlvKCBsaXN0ZW5lciApIHtcblxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cblx0XHR0aGlzLmNvbnRleHQgPSBsaXN0ZW5lci5jb250ZXh0O1xuXG5cdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0XHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xuXG5cdFx0dGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5idWZmZXIgPSBudWxsO1xuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gMDtcblx0XHR0aGlzLm9mZnNldCA9IDA7XG5cdFx0dGhpcy5wbGF5YmFja1JhdGUgPSAxO1xuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdlbXB0eSc7XG5cblx0XHR0aGlzLmZpbHRlcnMgPSBbXTtcblxuXHR9XG5cblx0QXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBBdWRpbyxcblxuXHRcdGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nYWluO1xuXG5cdFx0fSxcblxuXHRcdHNldE5vZGVTb3VyY2U6IGZ1bmN0aW9uICggYXVkaW9Ob2RlICkge1xuXG5cdFx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2F1ZGlvTm9kZSc7XG5cdFx0XHR0aGlzLnNvdXJjZSA9IGF1ZGlvTm9kZTtcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRCdWZmZXI6IGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XG5cblx0XHRcdHRoaXMuYnVmZmVyID0gYXVkaW9CdWZmZXI7XG5cdFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcblxuXHRcdFx0aWYgKCB0aGlzLmF1dG9wbGF5ICkgdGhpcy5wbGF5KCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHBsYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cblx0XHRcdHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcblx0XHRcdHNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xuXHRcdFx0c291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCggdGhpcyApO1xuXHRcdFx0c291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZSggdGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuc3RhcnRUaW1lICk7XG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcblx0XHRcdHNvdXJjZS5zdGFydCggdGhpcy5zdGFydFRpbWUsIHRoaXMub2Zmc2V0ICk7XG5cblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cblx0XHRcdHJldHVybiB0aGlzLmNvbm5lY3QoKTtcblxuXHRcdH0sXG5cblx0XHRwYXVzZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHRoaXMuc291cmNlLnN0b3AoKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gKCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgLSB0aGlzLnN0YXJ0VGltZSApICogdGhpcy5wbGF5YmFja1JhdGU7XG5cdFx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c3RvcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XG5cdFx0XHR0aGlzLm9mZnNldCA9IDA7XG5cdFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5maWx0ZXJzWyAwIF0gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5maWx0ZXJzWyAwIF0gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRnZXRGaWx0ZXJzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmZpbHRlcnM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RmlsdGVyczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCAhIHZhbHVlICkgdmFsdWUgPSBbXTtcblxuXHRcdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcblx0XHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGdldEZpbHRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbIDAgXTtcblxuXHRcdH0sXG5cblx0XHRzZXRGaWx0ZXI6IGZ1bmN0aW9uICggZmlsdGVyICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKCBmaWx0ZXIgPyBbIGZpbHRlciBdIDogW10gKTtcblxuXHRcdH0sXG5cblx0XHRzZXRQbGF5YmFja1JhdGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cblx0XHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKCB0aGlzLnBsYXliYWNrUmF0ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuXHRcdH0sXG5cblx0XHRvbkVuZGVkOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0Z2V0TG9vcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5sb29wO1xuXG5cdFx0fSxcblxuXHRcdHNldExvb3A6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubG9vcCA9IHZhbHVlO1xuXG5cdFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHRoaXMuc291cmNlLmxvb3AgPSB0aGlzLmxvb3A7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Vm9sdW1lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRzZXRWb2x1bWU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gUG9zaXRpb25hbEF1ZGlvKCBsaXN0ZW5lciApIHtcblxuXHRcdEF1ZGlvLmNhbGwoIHRoaXMsIGxpc3RlbmVyICk7XG5cblx0XHR0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcblx0XHR0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcblxuXHR9XG5cblx0UG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEF1ZGlvLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogUG9zaXRpb25hbEF1ZGlvLFxuXG5cdFx0Z2V0T3V0cHV0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnBhbm5lcjtcblxuXHRcdH0sXG5cblx0XHRnZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cblx0XHR9LFxuXG5cdFx0c2V0UmVmRGlzdGFuY2U6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Um9sbG9mZkZhY3RvcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcblxuXHRcdH0sXG5cblx0XHRzZXRSb2xsb2ZmRmFjdG9yOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RGlzdGFuY2VNb2RlbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcblxuXHRcdH0sXG5cblx0XHRzZXREaXN0YW5jZU1vZGVsOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuXG5cdFx0fSxcblxuXHRcdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuXHRcdFx0XHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHRcdFx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSApKClcblxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gQXVkaW9BbmFseXNlciggYXVkaW8sIGZmdFNpemUgKSB7XG5cblx0XHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHRcdHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemUgIT09IHVuZGVmaW5lZCA/IGZmdFNpemUgOiAyMDQ4O1xuXG5cdFx0dGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoIHRoaXMuYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQgKTtcblxuXHRcdGF1ZGlvLmdldE91dHB1dCgpLmNvbm5lY3QoIHRoaXMuYW5hbHlzZXIgKTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggQXVkaW9BbmFseXNlci5wcm90b3R5cGUsIHtcblxuXHRcdGdldEZyZXF1ZW5jeURhdGE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSggdGhpcy5kYXRhICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmRhdGE7XG5cblx0XHR9LFxuXG5cdFx0Z2V0QXZlcmFnZUZyZXF1ZW5jeTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSAwLCBkYXRhID0gdGhpcy5nZXRGcmVxdWVuY3lEYXRhKCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhbHVlICs9IGRhdGFbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyBkYXRhLmxlbmd0aDtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqXG5cdCAqIEJ1ZmZlcmVkIHNjZW5lIGdyYXBoIHByb3BlcnR5IHRoYXQgYWxsb3dzIHdlaWdodGVkIGFjY3VtdWxhdGlvbi5cblx0ICpcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0ZnVuY3Rpb24gUHJvcGVydHlNaXhlciggYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSApIHtcblxuXHRcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG5cdFx0dGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XG5cblx0XHR2YXIgYnVmZmVyVHlwZSA9IEZsb2F0NjRBcnJheSxcblx0XHRcdG1peEZ1bmN0aW9uO1xuXG5cdFx0c3dpdGNoICggdHlwZU5hbWUgKSB7XG5cblx0XHRcdGNhc2UgJ3F1YXRlcm5pb24nOlxuXHRcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NsZXJwO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdFx0XHRidWZmZXJUeXBlID0gQXJyYXk7XG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2VsZWN0O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5idWZmZXIgPSBuZXcgYnVmZmVyVHlwZSggdmFsdWVTaXplICogNCApO1xuXHRcdC8vIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIF1cblx0XHQvL1xuXHRcdC8vIGludGVycG9sYXRvcnMgY2FuIHVzZSAuYnVmZmVyIGFzIHRoZWlyIC5yZXN1bHRcblx0XHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xuXHRcdC8vXG5cdFx0Ly8gJ2FjY3UwJyBhbmQgJ2FjY3UxJyBhcmUgdXNlZCBmcmFtZS1pbnRlcmxlYXZlZCBmb3Jcblx0XHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3Rcblx0XHQvLyBjaGFuZ2VzXG5cdFx0Ly9cblx0XHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcblxuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuXHRcdHRoaXMudXNlQ291bnQgPSAwO1xuXHRcdHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eU1peGVyLnByb3RvdHlwZSwge1xuXG5cdFx0Ly8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhY2N1PGk+J1xuXHRcdGFjY3VtdWxhdGU6IGZ1bmN0aW9uICggYWNjdUluZGV4LCB3ZWlnaHQgKSB7XG5cblx0XHRcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXG5cdFx0XHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxuXG5cdFx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXG5cblx0XHRcdFx0Y3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcblxuXHRcdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xuXG5cdFx0XHRcdC8vIGFjY3VOIDo9IGluY29taW5nICogd2VpZ2h0XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgaW5jb21pbmcgKiB3ZWlnaHRcblxuXHRcdFx0XHRjdXJyZW50V2VpZ2h0ICs9IHdlaWdodDtcblx0XHRcdFx0dmFyIG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XG5cdFx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiggYnVmZmVyLCBvZmZzZXQsIDAsIG1peCwgc3RyaWRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcblxuXHRcdH0sXG5cblx0XHQvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXG5cdFx0YXBwbHk6IGZ1bmN0aW9uICggYWNjdUluZGV4ICkge1xuXG5cdFx0XHR2YXIgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRcdGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuXHRcdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXG5cblx0XHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuXG5cdFx0XHRcdGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cblx0XHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cblx0XHRcdGlmICggd2VpZ2h0IDwgMSApIHtcblxuXHRcdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIG9yaWdpbmFsICogKCAxIC0gY3VtdWxhdGl2ZVdlaWdodCApXG5cblx0XHRcdFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiAzO1xuXG5cdFx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcblx0XHRcdFx0XHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSBzdHJpZGUsIGUgPSBzdHJpZGUgKyBzdHJpZGU7IGkgIT09IGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0aWYgKCBidWZmZXJbIGkgXSAhPT0gYnVmZmVyWyBpICsgc3RyaWRlIF0gKSB7XG5cblx0XHRcdFx0XHQvLyB2YWx1ZSBoYXMgY2hhbmdlZCAtPiB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuXHRcdFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gcmVtZW1iZXIgdGhlIHN0YXRlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eSBhbmQgY29weSBpdCB0byBib3RoIGFjY3VzXG5cdFx0c2F2ZU9yaWdpbmFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cblx0XHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIDM7XG5cblx0XHRcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xuXG5cdFx0XHQvLyBhY2N1WzAuLjFdIDo9IG9yaWcgLS0gaW5pdGlhbGx5IGRldGVjdCBjaGFuZ2VzIGFnYWluc3QgdGhlIG9yaWdpbmFsXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IG9yaWdpbmFsVmFsdWVPZmZzZXQ7IGkgIT09IGU7ICsrIGkgKSB7XG5cblx0XHRcdFx0YnVmZmVyWyBpIF0gPSBidWZmZXJbIG9yaWdpbmFsVmFsdWVPZmZzZXQgKyAoIGkgJSBzdHJpZGUgKSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cblx0XHR9LFxuXG5cdFx0Ly8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcblx0XHRyZXN0b3JlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHRoaXMudmFsdWVTaXplICogMztcblx0XHRcdHRoaXMuYmluZGluZy5zZXRWYWx1ZSggdGhpcy5idWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcblxuXHRcdH0sXG5cblxuXHRcdC8vIG1peCBmdW5jdGlvbnNcblxuXHRcdF9zZWxlY3Q6IGZ1bmN0aW9uICggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xuXG5cdFx0XHRpZiAoIHQgPj0gMC41ICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRcdFx0YnVmZmVyWyBkc3RPZmZzZXQgKyBpIF0gPSBidWZmZXJbIHNyY09mZnNldCArIGkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRfc2xlcnA6IGZ1bmN0aW9uICggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCApIHtcblxuXHRcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQgKTtcblxuXHRcdH0sXG5cblx0XHRfbGVycDogZnVuY3Rpb24gKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cblx0XHRcdHZhciBzID0gMSAtIHQ7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRcdHZhciBqID0gZHN0T2Zmc2V0ICsgaTtcblxuXHRcdFx0XHRidWZmZXJbIGogXSA9IGJ1ZmZlclsgaiBdICogcyArIGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdICogdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICpcblx0ICogQSByZWZlcmVuY2UgdG8gYSByZWFsIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaC5cblx0ICpcblx0ICpcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG5cdCAqIEBhdXRob3IgdHNjaHdcblx0ICovXG5cblx0Ly8gQ2hhcmFjdGVycyBbXS46LyBhcmUgcmVzZXJ2ZWQgZm9yIHRyYWNrIGJpbmRpbmcgc3ludGF4LlxuXHR2YXIgUkVTRVJWRURfQ0hBUlNfUkUgPSAnXFxcXFtcXFxcXVxcXFwuOlxcXFwvJztcblxuXHRmdW5jdGlvbiBDb21wb3NpdGUoIHRhcmdldEdyb3VwLCBwYXRoLCBvcHRpb25hbFBhcnNlZFBhdGggKSB7XG5cblx0XHR2YXIgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHRcdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XG5cdFx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIENvbXBvc2l0ZS5wcm90b3R5cGUsIHtcblxuXHRcdGdldFZhbHVlOiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdHRoaXMuYmluZCgpOyAvLyBiaW5kIGFsbCBiaW5kaW5nXG5cblx0XHRcdHZhciBmaXJzdFZhbGlkSW5kZXggPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1sgZmlyc3RWYWxpZEluZGV4IF07XG5cblx0XHRcdC8vIGFuZCBvbmx5IGNhbGwgLmdldFZhbHVlIG9uIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0XHRcdCAgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdLnNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRiaW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdFx0XHQgIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0YmluZGluZ3NbIGkgXS5iaW5kKCk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0XHRcdCAgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdLnVuYmluZCgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSApO1xuXG5cblx0ZnVuY3Rpb24gUHJvcGVydHlCaW5kaW5nKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcblxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdFx0dGhpcy5wYXJzZWRQYXRoID0gcGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHRcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggcm9vdE5vZGUsIHRoaXMucGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHJvb3ROb2RlO1xuXG5cdFx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eUJpbmRpbmcsIHtcblxuXHRcdENvbXBvc2l0ZTogQ29tcG9zaXRlLFxuXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiAoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cblx0XHRcdGlmICggISAoIHJvb3QgJiYgcm9vdC5pc0FuaW1hdGlvbk9iamVjdEdyb3VwICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzIHNwYWNlcyB3aXRoIHVuZGVyc2NvcmVzIGFuZCByZW1vdmVzIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMgZnJvbVxuXHRcdCAqIG5vZGUgbmFtZXMsIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggcGFyc2VUcmFja05hbWUoKS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBOb2RlIG5hbWUgdG8gYmUgc2FuaXRpemVkLlxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHQgKi9cblx0XHRzYW5pdGl6ZU5vZGVOYW1lOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHJlc2VydmVkUmUgPSBuZXcgUmVnRXhwKCAnWycgKyBSRVNFUlZFRF9DSEFSU19SRSArICddJywgJ2cnICk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBzYW5pdGl6ZU5vZGVOYW1lKCBuYW1lICkge1xuXG5cdFx0XHRcdHJldHVybiBuYW1lLnJlcGxhY2UoIC9cXHMvZywgJ18nICkucmVwbGFjZSggcmVzZXJ2ZWRSZSwgJycgKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSApLFxuXG5cdFx0cGFyc2VUcmFja05hbWU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gQXR0ZW1wdHMgdG8gYWxsb3cgbm9kZSBuYW1lcyBmcm9tIGFueSBsYW5ndWFnZS4gRVM1J3MgYFxcd2AgcmVnZXhwIG1hdGNoZXNcblx0XHRcdC8vIG9ubHkgbGF0aW4gY2hhcmFjdGVycywgYW5kIHRoZSB1bmljb2RlIFxccHtMfSBpcyBub3QgeWV0IHN1cHBvcnRlZC4gU29cblx0XHRcdC8vIGluc3RlYWQsIHdlIGV4Y2x1ZGUgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgbWF0Y2ggZXZlcnl0aGluZyBlbHNlLlxuXHRcdFx0dmFyIHdvcmRDaGFyID0gJ1teJyArIFJFU0VSVkVEX0NIQVJTX1JFICsgJ10nO1xuXHRcdFx0dmFyIHdvcmRDaGFyT3JEb3QgPSAnW14nICsgUkVTRVJWRURfQ0hBUlNfUkUucmVwbGFjZSggJ1xcXFwuJywgJycgKSArICddJztcblxuXHRcdFx0Ly8gUGFyZW50IGRpcmVjdG9yaWVzLCBkZWxpbWl0ZWQgYnkgJy8nIG9yICc6Jy4gQ3VycmVudGx5IHVudXNlZCwgYnV0IG11c3Rcblx0XHRcdC8vIGJlIG1hdGNoZWQgdG8gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlIHRyYWNrIG5hbWUuXG5cdFx0XHR2YXIgZGlyZWN0b3J5UmUgPSAvKCg/OldDK1tcXC86XSkqKS8uc291cmNlLnJlcGxhY2UoICdXQycsIHdvcmRDaGFyICk7XG5cblx0XHRcdC8vIFRhcmdldCBub2RlLiBNYXkgY29udGFpbiB3b3JkIGNoYXJhY3RlcnMgKGEtekEtWjAtOV8pIGFuZCAnLicgb3IgJy0nLlxuXHRcdFx0dmFyIG5vZGVSZSA9IC8oV0NPRCspPy8uc291cmNlLnJlcGxhY2UoICdXQ09EJywgd29yZENoYXJPckRvdCApO1xuXG5cdFx0XHQvLyBPYmplY3Qgb24gdGFyZ2V0IG5vZGUsIGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkXG5cdFx0XHQvLyBjaGFyYWN0ZXJzLiBBY2Nlc3NvciBtYXkgY29udGFpbiBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBjbG9zaW5nIGJyYWNrZXQuXG5cdFx0XHR2YXIgb2JqZWN0UmUgPSAvKD86XFwuKFdDKykoPzpcXFsoLispXFxdKT8pPy8uc291cmNlLnJlcGxhY2UoICdXQycsIHdvcmRDaGFyICk7XG5cblx0XHRcdC8vIFByb3BlcnR5IGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heVxuXHRcdFx0Ly8gY29udGFpbiBhbnkgbm9uLWJyYWNrZXQgY2hhcmFjdGVycy5cblx0XHRcdHZhciBwcm9wZXJ0eVJlID0gL1xcLihXQyspKD86XFxbKC4rKVxcXSk/Ly5zb3VyY2UucmVwbGFjZSggJ1dDJywgd29yZENoYXIgKTtcblxuXHRcdFx0dmFyIHRyYWNrUmUgPSBuZXcgUmVnRXhwKCAnJ1xuXHRcdFx0XHQrICdeJ1xuXHRcdFx0XHQrIGRpcmVjdG9yeVJlXG5cdFx0XHRcdCsgbm9kZVJlXG5cdFx0XHRcdCsgb2JqZWN0UmVcblx0XHRcdFx0KyBwcm9wZXJ0eVJlXG5cdFx0XHRcdCsgJyQnXG5cdFx0XHQpO1xuXG5cdFx0XHR2YXIgc3VwcG9ydGVkT2JqZWN0TmFtZXMgPSBbICdtYXRlcmlhbCcsICdtYXRlcmlhbHMnLCAnYm9uZXMnIF07XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYXJzZVRyYWNrTmFtZSggdHJhY2tOYW1lICkge1xuXG5cdFx0XHRcdHZhciBtYXRjaGVzID0gdHJhY2tSZS5leGVjKCB0cmFja05hbWUgKTtcblxuXHRcdFx0XHRpZiAoICEgbWF0Y2hlcyApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Byb3BlcnR5QmluZGluZzogQ2Fubm90IHBhcnNlIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmVzdWx0cyA9IHtcblx0XHRcdFx0XHQvLyBkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWyAxIF0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxuXHRcdFx0XHRcdG5vZGVOYW1lOiBtYXRjaGVzWyAyIF0sXG5cdFx0XHRcdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1sgMyBdLFxuXHRcdFx0XHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWyA0IF0sXG5cdFx0XHRcdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWyA1IF0sIC8vIHJlcXVpcmVkXG5cdFx0XHRcdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sgNiBdXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIGxhc3REb3QgPSByZXN1bHRzLm5vZGVOYW1lICYmIHJlc3VsdHMubm9kZU5hbWUubGFzdEluZGV4T2YoICcuJyApO1xuXG5cdFx0XHRcdGlmICggbGFzdERvdCAhPT0gdW5kZWZpbmVkICYmIGxhc3REb3QgIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdHZhciBvYmplY3ROYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIGxhc3REb3QgKyAxICk7XG5cblx0XHRcdFx0XHQvLyBPYmplY3QgbmFtZXMgbXVzdCBiZSBjaGVja2VkIGFnYWluc3QgYSB3aGl0ZWxpc3QuIE90aGVyd2lzZSwgdGhlcmVcblx0XHRcdFx0XHQvLyBpcyBubyB3YXkgdG8gcGFyc2UgJ2Zvby5iYXIuYmF6JzogJ2JheicgbXVzdCBiZSBhIHByb3BlcnR5LCBidXRcblx0XHRcdFx0XHQvLyAnYmFyJyBjb3VsZCBiZSB0aGUgb2JqZWN0TmFtZSwgb3IgcGFydCBvZiBhIG5vZGVOYW1lICh3aGljaCBjYW5cblx0XHRcdFx0XHQvLyBpbmNsdWRlICcuJyBjaGFyYWN0ZXJzKS5cblx0XHRcdFx0XHRpZiAoIHN1cHBvcnRlZE9iamVjdE5hbWVzLmluZGV4T2YoIG9iamVjdE5hbWUgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRyZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIDAsIGxhc3REb3QgKTtcblx0XHRcdFx0XHRcdHJlc3VsdHMub2JqZWN0TmFtZSA9IG9iamVjdE5hbWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGZpbmROb2RlOiBmdW5jdGlvbiAoIHJvb3QsIG5vZGVOYW1lICkge1xuXG5cdFx0XHRpZiAoICEgbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09IFwiXCIgfHwgbm9kZU5hbWUgPT09IFwicm9vdFwiIHx8IG5vZGVOYW1lID09PSBcIi5cIiB8fCBub2RlTmFtZSA9PT0gLSAxIHx8IG5vZGVOYW1lID09PSByb290Lm5hbWUgfHwgbm9kZU5hbWUgPT09IHJvb3QudXVpZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcm9vdDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZWFyY2ggaW50byBza2VsZXRvbiBib25lcy5cblx0XHRcdGlmICggcm9vdC5za2VsZXRvbiApIHtcblxuXHRcdFx0XHR2YXIgYm9uZSA9IHJvb3Quc2tlbGV0b24uZ2V0Qm9uZUJ5TmFtZSggbm9kZU5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIGJvbmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXG5cdFx0XHRpZiAoIHJvb3QuY2hpbGRyZW4gKSB7XG5cblx0XHRcdFx0dmFyIHNlYXJjaE5vZGVTdWJ0cmVlID0gZnVuY3Rpb24gKCBjaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGNoaWxkTm9kZSA9IGNoaWxkcmVuWyBpIF07XG5cblx0XHRcdFx0XHRcdGlmICggY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hpbGROb2RlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciByZXN1bHQgPSBzZWFyY2hOb2RlU3VidHJlZSggY2hpbGROb2RlLmNoaWxkcmVuICk7XG5cblx0XHRcdFx0XHRcdGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUoIHJvb3QuY2hpbGRyZW4gKTtcblxuXHRcdFx0XHRpZiAoIHN1YlRyZWVOb2RlICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmFzc2lnbiggUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSwgeyAvLyBwcm90b3R5cGUsIGNvbnRpbnVlZFxuXG5cdFx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxuXHRcdF9nZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24gKCkge30sXG5cdFx0X3NldFZhbHVlX3VuYXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7fSxcblxuXHRcdEJpbmRpbmdUeXBlOiB7XG5cdFx0XHREaXJlY3Q6IDAsXG5cdFx0XHRFbnRpcmVBcnJheTogMSxcblx0XHRcdEFycmF5RWxlbWVudDogMixcblx0XHRcdEhhc0Zyb21Ub0FycmF5OiAzXG5cdFx0fSxcblxuXHRcdFZlcnNpb25pbmc6IHtcblx0XHRcdE5vbmU6IDAsXG5cdFx0XHROZWVkc1VwZGF0ZTogMSxcblx0XHRcdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcblx0XHR9LFxuXG5cdFx0R2V0dGVyQnlCaW5kaW5nVHlwZTogW1xuXG5cdFx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF07XG5cblx0XHRcdH0sXG5cblx0XHRcdGZ1bmN0aW9uIGdldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR2YXIgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHNvdXJjZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArKyBdID0gc291cmNlWyBpIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBnZXRWYWx1ZV90b0FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XSxcblxuXHRcdFNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nOiBbXG5cblx0XHRcdFtcblx0XHRcdFx0Ly8gRGlyZWN0XG5cblx0XHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cdFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XSwgW1xuXG5cdFx0XHRcdC8vIEVudGlyZUFycmF5XG5cblx0XHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdF0sIFtcblxuXHRcdFx0XHQvLyBBcnJheUVsZW1lbnRcblxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cdFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cdFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRdLCBbXG5cblx0XHRcdFx0Ly8gSGFzVG9Gcm9tQXJyYXlcblxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuXHRcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRdXG5cblx0XHRdLFxuXG5cdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHRhcmdldEFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0dGhpcy5nZXRWYWx1ZSggdGFyZ2V0QXJyYXksIG9mZnNldCApO1xuXG5cdFx0XHQvLyBOb3RlOiBUaGlzIGNsYXNzIHVzZXMgYSBTdGF0ZSBwYXR0ZXJuIG9uIGEgcGVyLW1ldGhvZCBiYXNpczpcblx0XHRcdC8vICdiaW5kJyBzZXRzICd0aGlzLmdldFZhbHVlJyAvICdzZXRWYWx1ZScgYW5kIHNoYWRvd3MgdGhlXG5cdFx0XHQvLyBwcm90b3R5cGUgdmVyc2lvbiBvZiB0aGVzZSBtZXRob2RzIHdpdGggb25lIHRoYXQgcmVwcmVzZW50c1xuXHRcdFx0Ly8gdGhlIGJvdW5kIHN0YXRlLiBXaGVuIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHRoZSBtZXRob2RzXG5cdFx0XHQvLyBiZWNvbWUgbm8tb3BzLlxuXG5cdFx0fSxcblxuXHRcdHNldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdHRoaXMuc2V0VmFsdWUoIHNvdXJjZUFycmF5LCBvZmZzZXQgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXG5cdFx0YmluZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlLFxuXHRcdFx0XHRwYXJzZWRQYXRoID0gdGhpcy5wYXJzZWRQYXRoLFxuXG5cdFx0XHRcdG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWUsXG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lLFxuXHRcdFx0XHRwcm9wZXJ0eUluZGV4ID0gcGFyc2VkUGF0aC5wcm9wZXJ0eUluZGV4O1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXG5cdFx0XHRcdHRhcmdldE9iamVjdCA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggdGhpcy5yb290Tm9kZSwgcGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHRoaXMucm9vdE5vZGU7XG5cblx0XHRcdFx0dGhpcy5ub2RlID0gdGFyZ2V0T2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXG5cdFx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5hdmFpbGFibGU7XG5cdFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5hdmFpbGFibGU7XG5cblx0XHRcdC8vIGVuc3VyZSB0aGVyZSBpcyBhIHZhbHVlIG5vZGVcblx0XHRcdGlmICggISB0YXJnZXRPYmplY3QgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogJyArIHRoaXMucGF0aCArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggb2JqZWN0TmFtZSApIHtcblxuXHRcdFx0XHR2YXIgb2JqZWN0SW5kZXggPSBwYXJzZWRQYXRoLm9iamVjdEluZGV4O1xuXG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZXMgd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cblx0XHRcdFx0c3dpdGNoICggb2JqZWN0TmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XG5cblx0XHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5LicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHM7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYm9uZXMnOlxuXG5cdFx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbi4nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBwb3RlbnRpYWwgZnV0dXJlIG9wdGltaXphdGlvbjogc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0XHQvLyBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cblx0XHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcblxuXHRcdFx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGFyZ2V0T2JqZWN0Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgaSBdLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0SW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlIHVuZGVmaW5lZC4nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoIG9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLicsIHRoaXMsIHRhcmdldE9iamVjdCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXNvbHZlIHByb3BlcnR5XG5cdFx0XHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0aWYgKCBub2RlUHJvcGVydHkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgbm9kZU5hbWUgPSBwYXJzZWRQYXRoLm5vZGVOYW1lO1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgcHJvcGVydHkgZm9yIHRyYWNrOiAnICsgbm9kZU5hbWUgK1xuXHRcdFx0XHRcdCcuJyArIHByb3BlcnR5TmFtZSArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicsIHRhcmdldE9iamVjdCApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXG5cdFx0XHR2YXIgdmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5Ob25lO1xuXG5cdFx0XHRpZiAoIHRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBtYXRlcmlhbFxuXG5cdFx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU7XG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBub2RlIHRyYW5zZm9ybVxuXG5cdFx0XHRcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTWF0cml4V29ybGROZWVkc1VwZGF0ZTtcblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGV0ZXJtaW5lIGhvdyB0aGUgcHJvcGVydHkgZ2V0cyBib3VuZFxuXHRcdFx0dmFyIGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5EaXJlY3Q7XG5cblx0XHRcdGlmICggcHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIGFjY2VzcyBhIHN1YiBlbGVtZW50IG9mIHRoZSBwcm9wZXJ0eSBhcnJheSAob25seSBwcmltaXRpdmVzIGFyZSBzdXBwb3J0ZWQgcmlnaHQgbm93KVxuXG5cdFx0XHRcdGlmICggcHJvcGVydHlOYW1lID09PSBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiICkge1xuXG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cblx0XHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5LicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpIF0ubmFtZSA9PT0gcHJvcGVydHlJbmRleCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLicsIHRoaXMgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPT09IHByb3BlcnR5SW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkFycmF5RWxlbWVudDtcblxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cdFx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5vZGVQcm9wZXJ0eS5mcm9tQXJyYXkgIT09IHVuZGVmaW5lZCAmJiBub2RlUHJvcGVydHkudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cblxuXHRcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXk7XG5cblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBub2RlUHJvcGVydHkgKSApIHtcblxuXHRcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRW50aXJlQXJyYXk7XG5cblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNlbGVjdCBnZXR0ZXIgLyBzZXR0ZXJcblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbIGJpbmRpbmdUeXBlIF07XG5cdFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1sgYmluZGluZ1R5cGUgXVsgdmVyc2lvbmluZyBdO1xuXG5cdFx0fSxcblxuXHRcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLm5vZGUgPSBudWxsO1xuXG5cdFx0XHQvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXG5cdFx0XHQvLyBub3RlOiBhdm9pZGluZyB0byBtdXRhdGUgdGhlIHNoYXBlIG9mICd0aGlzJyB2aWEgJ2RlbGV0ZSdcblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmJvdW5kO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8vIVxcIERFQ0xBUkUgQUxJQVMgQUZURVIgYXNzaWduIHByb3RvdHlwZSAhXG5cdE9iamVjdC5hc3NpZ24oIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUsIHtcblxuXHRcdC8vIGluaXRpYWwgc3RhdGUgb2YgdGhlc2UgbWV0aG9kcyB0aGF0IGNhbGxzICdiaW5kJ1xuXHRcdF9nZXRWYWx1ZV91bmJvdW5kOiBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLmdldFZhbHVlLFxuXHRcdF9zZXRWYWx1ZV91bmJvdW5kOiBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlLFxuXG5cdH0gKTtcblxuXHQvKipcblx0ICpcblx0ICogQSBncm91cCBvZiBvYmplY3RzIHRoYXQgcmVjZWl2ZXMgYSBzaGFyZWQgYW5pbWF0aW9uIHN0YXRlLlxuXHQgKlxuXHQgKiBVc2FnZTpcblx0ICpcblx0ICogXHQtXHRBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxuXHQgKiBcdFx0Y29uc3RydWN0b3Igb3IgdGhlIC5jbGlwQWN0aW9uIG1ldGhvZCBvZiBBbmltYXRpb25NaXhlci5cblx0ICpcblx0ICogXHQtXHRJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxuXHQgKlxuXHQgKiBcdC1cdFlvdSBjYW4gYWxzbyBhZGQgYW5kIHJlbW92ZSBvYmplY3RzIGxhdGVyIHdoZW4gdGhlIG1peGVyXG5cdCAqIFx0XHRpcyBydW5uaW5nLlxuXHQgKlxuXHQgKiBOb3RlOlxuXHQgKlxuXHQgKiAgXHRPYmplY3RzIG9mIHRoaXMgY2xhc3MgYXBwZWFyIGFzIG9uZSBvYmplY3QgdG8gdGhlIG1peGVyLFxuXHQgKiAgXHRzbyBjYWNoZSBjb250cm9sIG9mIHRoZSBpbmRpdmlkdWFsIG9iamVjdHMgbXVzdCBiZSBkb25lXG5cdCAqICBcdG9uIHRoZSBncm91cC5cblx0ICpcblx0ICogTGltaXRhdGlvbjpcblx0ICpcblx0ICogXHQtIFx0VGhlIGFuaW1hdGVkIHByb3BlcnRpZXMgbXVzdCBiZSBjb21wYXRpYmxlIGFtb25nIHRoZVxuXHQgKiBcdFx0YWxsIG9iamVjdHMgaW4gdGhlIGdyb3VwLlxuXHQgKlxuXHQgKiAgLVx0QSBzaW5nbGUgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBjb250cm9sbGVkIHRocm91Z2ggYVxuXHQgKiAgXHR0YXJnZXQgZ3JvdXAgb3IgZGlyZWN0bHksIGJ1dCBub3QgYm90aC5cblx0ICpcblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBBbmltYXRpb25PYmplY3RHcm91cCgpIHtcblxuXHRcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0Ly8gY2FjaGVkIG9iamVjdHMgZm9sbG93ZWQgYnkgdGhlIGFjdGl2ZSBvbmVzXG5cdFx0dGhpcy5fb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDtcdFx0XHQvLyB0aHJlc2hvbGRcblx0XHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcblxuXHRcdHZhciBpbmRpY2VzID0ge307XG5cdFx0dGhpcy5faW5kaWNlc0J5VVVJRCA9IGluZGljZXM7XHRcdC8vIGZvciBib29ra2VlcGluZ1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0aW5kaWNlc1sgYXJndW1lbnRzWyBpIF0udXVpZCBdID0gaTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3BhdGhzID0gW107XHRcdFx0XHRcdC8vIGluc2lkZTogc3RyaW5nXG5cdFx0dGhpcy5fcGFyc2VkUGF0aHMgPSBbXTtcdFx0XHRcdC8vIGluc2lkZTogeyB3ZSBkb24ndCBjYXJlLCBoZXJlIH1cblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyBcdFx0XHRcdC8vIGluc2lkZTogQXJyYXk8IFByb3BlcnR5QmluZGluZyA+XG5cdFx0dGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoID0ge307IFx0Ly8gaW5zaWRlOiBpbmRpY2VzIGluIHRoZXNlIGFycmF5c1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHRoaXMuc3RhdHMgPSB7XG5cblx0XHRcdG9iamVjdHM6IHtcblx0XHRcdFx0Z2V0IHRvdGFsKCkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50b3RhbCAtIHNjb3BlLm5DYWNoZWRPYmplY3RzXztcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Z2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkge1xuXG5cdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25PYmplY3RHcm91cC5wcm90b3R5cGUsIHtcblxuXHRcdGlzQW5pbWF0aW9uT2JqZWN0R3JvdXA6IHRydWUsXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuXHRcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcblx0XHRcdFx0cGF0aHMgPSB0aGlzLl9wYXRocyxcblx0XHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoLFxuXHRcdFx0XHRrbm93bk9iamVjdCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuXHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIHVua25vd24gb2JqZWN0IC0+IGFkZCBpdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxuXG5cdFx0XHRcdFx0aW5kZXggPSBuT2JqZWN0cyArKztcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0XHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHRiaW5kaW5nc1sgaiBdLnB1c2goIG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcblxuXHRcdFx0XHRcdGtub3duT2JqZWN0ID0gb2JqZWN0c1sgaW5kZXggXTtcblxuXHRcdFx0XHRcdC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG5cblx0XHRcdFx0XHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXTtcblxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XG5cblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSA9IG9iamVjdDtcblxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcblxuXHRcdFx0XHRcdFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXG5cdFx0XHRcdFx0XHRcdC8vIGZvciBvYmplY3RzIHRoYXQgYXJlIGNhY2hlZCwgdGhlIGJpbmRpbmcgbWF5XG5cdFx0XHRcdFx0XHRcdC8vIG9yIG1heSBub3QgZXhpc3RcblxuXHRcdFx0XHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdHNbIGluZGV4IF0gIT09IGtub3duT2JqZWN0ICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwOiBEaWZmZXJlbnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIFVVSUQgJyArXG5cdFx0XHRcdFx0XHRcdCdkZXRlY3RlZC4gQ2xlYW4gdGhlIGNhY2hlcyBvciByZWNyZWF0ZSB5b3VyIGluZnJhc3RydWN0dXJlIHdoZW4gcmVsb2FkaW5nIHNjZW5lcy4nICk7XG5cblx0XHRcdFx0fSAvLyBlbHNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSB3aGVyZSB3ZSB3YW50IGl0IHRvIGJlXG5cblx0XHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cdFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMgKSB7XG5cblx0XHRcdFx0XHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCBpbnRvIHRoZSBDQUNIRUQgcmVnaW9uXG5cblx0XHRcdFx0XHR2YXIgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMgKyssXG5cdFx0XHRcdFx0XHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdO1xuXG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgZmlyc3RBY3RpdmVPYmplY3QudXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGZpcnN0QWN0aXZlT2JqZWN0O1xuXG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gbGFzdENhY2hlZEluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcblx0XHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdLFxuXHRcdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZTtcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcmVtb3ZlICYgZm9yZ2V0XG5cdFx0dW5jYWNoZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG5cdFx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBvYmplY3QgaXMgY2FjaGVkLCBzaHJpbmsgdGhlIENBQ0hFRCByZWdpb25cblxuXHRcdFx0XHRcdFx0dmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLSBuQ2FjaGVkT2JqZWN0cyxcblx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdFx0bGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXG5cdFx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcblxuXHRcdFx0XHRcdFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2Vcblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcblxuXHRcdFx0XHRcdFx0Ly8gbGFzdCBvYmplY3QgZ29lcyB0byB0aGUgYWN0aXZhdGVkIHNsb3QgYW5kIHBvcFxuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuXHRcdFx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdE9iamVjdDtcblx0XHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XG5cblx0XHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxuXHRcdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdFx0XHRsYXN0ID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBsYXN0Q2FjaGVkO1xuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XG5cdFx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGFjdGl2ZSwganVzdCBzd2FwIHdpdGggdGhlIGxhc3QgYW5kIHBvcFxuXG5cdFx0XHRcdFx0XHR2YXIgbGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXG5cdFx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcblxuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0T2JqZWN0O1xuXHRcdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuXHRcdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF07XG5cblx0XHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblx0XHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoLnBvcCgpO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblxuXHRcdFx0XHR9IC8vIGlmIG9iamVjdCBpcyBrbm93blxuXG5cdFx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXHRcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuXHRcdH0sXG5cblx0XHQvLyBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBieSBiZWZyaWVuZGVkIFByb3BlcnR5QmluZGluZy5Db21wb3NpdGU6XG5cblx0XHRzdWJzY3JpYmVfOiBmdW5jdGlvbiAoIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cblx0XHRcdC8vIHJldHVybnMgYW4gYXJyYXkgb2YgYmluZGluZ3MgZm9yIHRoZSBnaXZlbiBwYXRoIHRoYXQgaXMgY2hhbmdlZFxuXHRcdFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjb250YWluZWQgb2JqZWN0cyBpbiB0aGUgZ3JvdXBcblxuXHRcdFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdLFxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYmluZGluZ3NbIGluZGV4IF07XG5cblx0XHRcdHZhciBwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0XHRvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcblx0XHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdFx0YmluZGluZ3NGb3JQYXRoID0gbmV3IEFycmF5KCBuT2JqZWN0cyApO1xuXG5cdFx0XHRpbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblxuXHRcdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XG5cblx0XHRcdHBhdGhzLnB1c2goIHBhdGggKTtcblx0XHRcdHBhcnNlZFBhdGhzLnB1c2goIHBhcnNlZFBhdGggKTtcblx0XHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IG5DYWNoZWRPYmplY3RzLCBuID0gb2JqZWN0cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIG9iamVjdCA9IG9iamVjdHNbIGkgXTtcblx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpIF0gPSBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYmluZGluZ3NGb3JQYXRoO1xuXG5cdFx0fSxcblxuXHRcdHVuc3Vic2NyaWJlXzogZnVuY3Rpb24gKCBwYXRoICkge1xuXG5cdFx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcblxuXHRcdFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRcdGxhc3RCaW5kaW5nc0luZGV4ID0gYmluZGluZ3MubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRsYXN0QmluZGluZ3MgPSBiaW5kaW5nc1sgbGFzdEJpbmRpbmdzSW5kZXggXSxcblx0XHRcdFx0XHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcblxuXHRcdFx0XHRpbmRpY2VzQnlQYXRoWyBsYXN0QmluZGluZ3NQYXRoIF0gPSBpbmRleDtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaW5kZXggXSA9IGxhc3RCaW5kaW5ncztcblx0XHRcdFx0YmluZGluZ3MucG9wKCk7XG5cblx0XHRcdFx0cGFyc2VkUGF0aHNbIGluZGV4IF0gPSBwYXJzZWRQYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcblx0XHRcdFx0cGFyc2VkUGF0aHMucG9wKCk7XG5cblx0XHRcdFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcblx0XHRcdFx0cGF0aHMucG9wKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqXG5cdCAqIEFjdGlvbiBwcm92aWRlZCBieSBBbmltYXRpb25NaXhlciBmb3Igc2NoZWR1bGluZyBjbGlwIHBsYXliYWNrIG9uIHNwZWNpZmljXG5cdCAqIG9iamVjdHMuXG5cdCAqXG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuXHQgKiBAYXV0aG9yIHRzY2h3XG5cdCAqXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEFuaW1hdGlvbkFjdGlvbiggbWl4ZXIsIGNsaXAsIGxvY2FsUm9vdCApIHtcblxuXHRcdHRoaXMuX21peGVyID0gbWl4ZXI7XG5cdFx0dGhpcy5fY2xpcCA9IGNsaXA7XG5cdFx0dGhpcy5fbG9jYWxSb290ID0gbG9jYWxSb290IHx8IG51bGw7XG5cblx0XHR2YXIgdHJhY2tzID0gY2xpcC50cmFja3MsXG5cdFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRcdGludGVycG9sYW50cyA9IG5ldyBBcnJheSggblRyYWNrcyApO1xuXG5cdFx0dmFyIGludGVycG9sYW50U2V0dGluZ3MgPSB7XG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuXHRcdH07XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRyYWNrc1sgaSBdLmNyZWF0ZUludGVycG9sYW50KCBudWxsICk7XG5cdFx0XHRpbnRlcnBvbGFudHNbIGkgXSA9IGludGVycG9sYW50O1xuXHRcdFx0aW50ZXJwb2xhbnQuc2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7XHQvLyBib3VuZCBieSB0aGUgbWl4ZXJcblxuXHRcdC8vIGluc2lkZTogUHJvcGVydHlNaXhlciAobWFuYWdlZCBieSB0aGUgbWl4ZXIpXG5cdFx0dGhpcy5fcHJvcGVydHlCaW5kaW5ncyA9IG5ldyBBcnJheSggblRyYWNrcyApO1xuXG5cdFx0dGhpcy5fY2FjaGVJbmRleCA9IG51bGw7XHRcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXHRcdHRoaXMuX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1x0XHQvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cblx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG5cdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXG5cdFx0dGhpcy5sb29wID0gTG9vcFJlcGVhdDtcblx0XHR0aGlzLl9sb29wQ291bnQgPSAtIDE7XG5cblx0XHQvLyBnbG9iYWwgbWl4ZXIgdGltZSB3aGVuIHRoZSBhY3Rpb24gaXMgdG8gYmUgc3RhcnRlZFxuXHRcdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0XHQvLyBzY2FsZWQgbG9jYWwgdGltZSBvZiB0aGUgYWN0aW9uXG5cdFx0Ly8gZ2V0cyBjbGFtcGVkIG9yIHdyYXBwZWQgdG8gMC4uY2xpcC5kdXJhdGlvbiBhY2NvcmRpbmcgdG8gbG9vcFxuXHRcdHRoaXMudGltZSA9IDA7XG5cblx0XHR0aGlzLnRpbWVTY2FsZSA9IDE7XG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gMTtcblxuXHRcdHRoaXMud2VpZ2h0ID0gMTtcblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSAxO1xuXG5cdFx0dGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5OyBcdFx0Ly8gbm8uIG9mIHJlcGV0aXRpb25zIHdoZW4gbG9vcGluZ1xuXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcdFx0XHRcdC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgdGltZSBzY2FsZVxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XHRcdFx0XHQvLyBmYWxzZSAtPiB6ZXJvIGVmZmVjdGl2ZSB3ZWlnaHRcblxuXHRcdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgXHQ9IGZhbHNlO1x0Ly8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xuXG5cdFx0dGhpcy56ZXJvU2xvcGVBdFN0YXJ0IFx0PSB0cnVlO1x0XHQvLyBmb3Igc21vb3RoIGludGVycG9sYXRpb24gdy9vIHNlcGFyYXRlXG5cdFx0dGhpcy56ZXJvU2xvcGVBdEVuZFx0XHQ9IHRydWU7XHRcdC8vIGNsaXBzIGZvciBzdGFydCwgbG9vcCBhbmQgZW5kXG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkFjdGlvbi5wcm90b3R5cGUsIHtcblxuXHRcdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xuXG5cdFx0cGxheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c3RvcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLl9taXhlci5fZGVhY3RpdmF0ZUFjdGlvbiggdGhpcyApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xuXG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLnRpbWUgPSAwO1x0XHRcdC8vIHJlc3RhcnQgY2xpcFxuXHRcdFx0dGhpcy5fbG9vcENvdW50ID0gLSAxO1x0Ly8gZm9yZ2V0IHByZXZpb3VzIGxvb3BzXG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1x0Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKCk7XG5cblx0XHR9LFxuXG5cdFx0aXNSdW5uaW5nOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmVuYWJsZWQgJiYgISB0aGlzLnBhdXNlZCAmJiB0aGlzLnRpbWVTY2FsZSAhPT0gMCAmJlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHQvLyByZXR1cm4gdHJ1ZSB3aGVuIHBsYXkgaGFzIGJlZW4gY2FsbGVkXG5cdFx0aXNTY2hlZHVsZWQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdHN0YXJ0QXQ6IGZ1bmN0aW9uICggdGltZSApIHtcblxuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0TG9vcDogZnVuY3Rpb24gKCBtb2RlLCByZXBldGl0aW9ucyApIHtcblxuXHRcdFx0dGhpcy5sb29wID0gbW9kZTtcblx0XHRcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gV2VpZ2h0XG5cblx0XHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xuXHRcdC8vIGFsdGhvdWdoIC5lbmFibGVkID0gZmFsc2UgeWllbGRzIGFuIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgemVybywgdGhpc1xuXHRcdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAuZW5hYmxlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcblx0XHRzZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uICggd2VpZ2h0ICkge1xuXG5cdFx0XHR0aGlzLndlaWdodCA9IHdlaWdodDtcblxuXHRcdFx0Ly8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxuXHRcdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gdGhpcy5lbmFibGVkID8gd2VpZ2h0IDogMDtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpO1xuXG5cdFx0fSxcblxuXHRcdC8vIHJldHVybiB0aGUgd2VpZ2h0IGNvbnNpZGVyaW5nIGZhZGluZyBhbmQgLmVuYWJsZWRcblx0XHRnZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcblxuXHRcdH0sXG5cblx0XHRmYWRlSW46IGZ1bmN0aW9uICggZHVyYXRpb24gKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDAsIDEgKTtcblxuXHRcdH0sXG5cblx0XHRmYWRlT3V0OiBmdW5jdGlvbiAoIGR1cmF0aW9uICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAxLCAwICk7XG5cblx0XHR9LFxuXG5cdFx0Y3Jvc3NGYWRlRnJvbTogZnVuY3Rpb24gKCBmYWRlT3V0QWN0aW9uLCBkdXJhdGlvbiwgd2FycCApIHtcblxuXHRcdFx0ZmFkZU91dEFjdGlvbi5mYWRlT3V0KCBkdXJhdGlvbiApO1xuXHRcdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XG5cblx0XHRcdGlmICggd2FycCApIHtcblxuXHRcdFx0XHR2YXIgZmFkZUluRHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxuXHRcdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXG5cblx0XHRcdFx0XHRzdGFydEVuZFJhdGlvID0gZmFkZU91dER1cmF0aW9uIC8gZmFkZUluRHVyYXRpb24sXG5cdFx0XHRcdFx0ZW5kU3RhcnRSYXRpbyA9IGZhZGVJbkR1cmF0aW9uIC8gZmFkZU91dER1cmF0aW9uO1xuXG5cdFx0XHRcdGZhZGVPdXRBY3Rpb24ud2FycCggMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbiApO1xuXHRcdFx0XHR0aGlzLndhcnAoIGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjcm9zc0ZhZGVUbzogZnVuY3Rpb24gKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG5cdFx0XHRyZXR1cm4gZmFkZUluQWN0aW9uLmNyb3NzRmFkZUZyb20oIHRoaXMsIGR1cmF0aW9uLCB3YXJwICk7XG5cblx0XHR9LFxuXG5cdFx0c3RvcEZhZGluZzogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKCB3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XG5cdFx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggd2VpZ2h0SW50ZXJwb2xhbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyBUaW1lIFNjYWxlIENvbnRyb2xcblxuXHRcdC8vIHNldCB0aGUgdGltZSBzY2FsZSBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIHdhcnBpbmdcblx0XHQvLyBhbHRob3VnaCAucGF1c2VkID0gdHJ1ZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHRpbWUgc2NhbGUgb2YgemVybywgdGhpc1xuXHRcdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAucGF1c2VkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXHRcdHNldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24gKCB0aW1lU2NhbGUgKSB7XG5cblx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuXG5cdFx0fSxcblxuXHRcdC8vIHJldHVybiB0aGUgdGltZSBzY2FsZSBjb25zaWRlcmluZyB3YXJwaW5nIGFuZCAucGF1c2VkXG5cdFx0Z2V0RWZmZWN0aXZlVGltZVNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU7XG5cblx0XHR9LFxuXG5cdFx0c2V0RHVyYXRpb246IGZ1bmN0aW9uICggZHVyYXRpb24gKSB7XG5cblx0XHRcdHRoaXMudGltZVNjYWxlID0gdGhpcy5fY2xpcC5kdXJhdGlvbiAvIGR1cmF0aW9uO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuXG5cdFx0fSxcblxuXHRcdHN5bmNXaXRoOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblxuXHRcdFx0dGhpcy50aW1lID0gYWN0aW9uLnRpbWU7XG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IGFjdGlvbi50aW1lU2NhbGU7XG5cblx0XHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0XHR9LFxuXG5cdFx0aGFsdDogZnVuY3Rpb24gKCBkdXJhdGlvbiApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMud2FycCggdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlLCAwLCBkdXJhdGlvbiApO1xuXG5cdFx0fSxcblxuXHRcdHdhcnA6IGZ1bmN0aW9uICggc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XG5cblx0XHRcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxuXHRcdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50LFxuXG5cdFx0XHRcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xuXG5cdFx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xuXG5cdFx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcblx0XHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblxuXHRcdFx0dGltZXNbIDAgXSA9IG5vdztcblx0XHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcblxuXHRcdFx0dmFsdWVzWyAwIF0gPSBzdGFydFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcblx0XHRcdHZhbHVlc1sgMSBdID0gZW5kVGltZVNjYWxlIC8gdGltZVNjYWxlO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzdG9wV2FycGluZzogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKCB0aW1lU2NhbGVJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG5cdFx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggdGltZVNjYWxlSW50ZXJwb2xhbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyBPYmplY3QgQWNjZXNzb3JzXG5cblx0XHRnZXRNaXhlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q2xpcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xpcDtcblxuXHRcdH0sXG5cblx0XHRnZXRSb290OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLl9sb2NhbFJvb3QgfHwgdGhpcy5fbWl4ZXIuX3Jvb3Q7XG5cblx0XHR9LFxuXG5cdFx0Ly8gSW50ZXJuYVxuXG5cdFx0X3VwZGF0ZTogZnVuY3Rpb24gKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcblxuXHRcdFx0Ly8gY2FsbGVkIGJ5IHRoZSBtaXhlclxuXG5cdFx0XHRpZiAoICEgdGhpcy5lbmFibGVkICkge1xuXG5cdFx0XHRcdC8vIGNhbGwgLl91cGRhdGVXZWlnaHQoKSB0byB1cGRhdGUgLl9lZmZlY3RpdmVXZWlnaHRcblxuXHRcdFx0XHR0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWU7XG5cblx0XHRcdGlmICggc3RhcnRUaW1lICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBzY2hlZHVsZWQgc3RhcnQgb2YgYWN0aW9uXG5cblx0XHRcdFx0dmFyIHRpbWVSdW5uaW5nID0gKCB0aW1lIC0gc3RhcnRUaW1lICkgKiB0aW1lRGlyZWN0aW9uO1xuXHRcdFx0XHRpZiAoIHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuOyAvLyB5ZXQgdG8gY29tZSAvIGRvbid0IGRlY2lkZSB3aGVuIGRlbHRhID0gMFxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzdGFydFxuXG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcblx0XHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFwcGx5IHRpbWUgc2NhbGUgYW5kIGFkdmFuY2UgdGltZVxuXG5cdFx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XG5cdFx0XHR2YXIgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcblxuXHRcdFx0Ly8gbm90ZTogX3VwZGF0ZVRpbWUgbWF5IGRpc2FibGUgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW5cblx0XHRcdC8vIGFuIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgMFxuXG5cdFx0XHR2YXIgd2VpZ2h0ID0gdGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XG5cblx0XHRcdGlmICggd2VpZ2h0ID4gMCApIHtcblxuXHRcdFx0XHR2YXIgaW50ZXJwb2xhbnRzID0gdGhpcy5faW50ZXJwb2xhbnRzO1xuXHRcdFx0XHR2YXIgcHJvcGVydHlNaXhlcnMgPSB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHRpbnRlcnBvbGFudHNbIGogXS5ldmFsdWF0ZSggY2xpcFRpbWUgKTtcblx0XHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0X3VwZGF0ZVdlaWdodDogZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0XHR2YXIgd2VpZ2h0ID0gMDtcblxuXHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgKSB7XG5cblx0XHRcdFx0d2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XG5cdFx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHRcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuc3RvcEZhZGluZygpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGludGVycG9sYW50VmFsdWUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gZmFkZWQgb3V0LCBkaXNhYmxlXG5cdFx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHdlaWdodDtcblx0XHRcdHJldHVybiB3ZWlnaHQ7XG5cblx0XHR9LFxuXG5cdFx0X3VwZGF0ZVRpbWVTY2FsZTogZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0XHR2YXIgdGltZVNjYWxlID0gMDtcblxuXHRcdFx0aWYgKCAhIHRoaXMucGF1c2VkICkge1xuXG5cdFx0XHRcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xuXG5cdFx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG5cdFx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHRcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0aW1lU2NhbGUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gbW90aW9uIGhhcyBoYWx0ZWQsIHBhdXNlXG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyB3YXJwIGRvbmUgLSBhcHBseSBmaW5hbCB0aW1lIHNjYWxlXG5cdFx0XHRcdFx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcblx0XHRcdHJldHVybiB0aW1lU2NhbGU7XG5cblx0XHR9LFxuXG5cdFx0X3VwZGF0ZVRpbWU6IGZ1bmN0aW9uICggZGVsdGFUaW1lICkge1xuXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMudGltZSArIGRlbHRhVGltZTtcblxuXHRcdFx0aWYgKCBkZWx0YVRpbWUgPT09IDAgKSByZXR1cm4gdGltZTtcblxuXHRcdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcblxuXHRcdFx0XHRsb29wID0gdGhpcy5sb29wLFxuXHRcdFx0XHRsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQ7XG5cblx0XHRcdGlmICggbG9vcCA9PT0gTG9vcE9uY2UgKSB7XG5cblx0XHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXG5cdFx0XHRcdFx0dGhpcy5fbG9vcENvdW50ID0gMDtcblx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRoYW5kbGVfc3RvcDoge1xuXG5cdFx0XHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uICkge1xuXG5cdFx0XHRcdFx0XHR0aW1lID0gZHVyYXRpb247XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aW1lIDwgMCApIHtcblxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cblx0XHRcdFx0XHR9IGVsc2UgYnJlYWsgaGFuZGxlX3N0b3A7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcblx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lIDwgMCA/IC0gMSA6IDFcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgeyAvLyByZXBldGl0aXZlIFJlcGVhdCBvciBQaW5nUG9uZ1xuXG5cdFx0XHRcdHZhciBwaW5nUG9uZyA9ICggbG9vcCA9PT0gTG9vcFBpbmdQb25nICk7XG5cblx0XHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXG5cdFx0XHRcdFx0aWYgKCBkZWx0YVRpbWUgPj0gMCApIHtcblxuXHRcdFx0XHRcdFx0bG9vcENvdW50ID0gMDtcblxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcblx0XHRcdFx0XHRcdC8vIHRyYW5zaXRpb24gdGhyb3VnaCB6ZXJvIGNvdW50cyBhcyBhIHJlcGV0aXRpb24sXG5cdFx0XHRcdFx0XHQvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcblxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwICkge1xuXG5cdFx0XHRcdFx0Ly8gd3JhcCBhcm91bmRcblxuXHRcdFx0XHRcdHZhciBsb29wRGVsdGEgPSBNYXRoLmZsb29yKCB0aW1lIC8gZHVyYXRpb24gKTsgLy8gc2lnbmVkXG5cdFx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcblxuXHRcdFx0XHRcdGxvb3BDb3VudCArPSBNYXRoLmFicyggbG9vcERlbHRhICk7XG5cblx0XHRcdFx0XHR2YXIgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XG5cblx0XHRcdFx0XHRpZiAoIHBlbmRpbmcgPCAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBoYXZlIHRvIHN0b3AgKHN3aXRjaCBzdGF0ZSwgY2xhbXAgdGltZSwgZmlyZSBldmVudClcblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XG5cblx0XHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA+IDAgPyAxIDogLSAxXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBrZWVwIHJ1bm5pbmdcblxuXHRcdFx0XHRcdFx0aWYgKCBwZW5kaW5nID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGVudGVyaW5nIHRoZSBsYXN0IHJvdW5kXG5cblx0XHRcdFx0XHRcdFx0dmFyIGF0U3RhcnQgPSBkZWx0YVRpbWUgPCAwO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCBhdFN0YXJ0LCAhIGF0U3RhcnQsIHBpbmdQb25nICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcblxuXHRcdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdC8vIGludmVydCB0aW1lIGZvciB0aGUgXCJwb25nIHJvdW5kXCJcblxuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy50aW1lID0gdGltZTtcblx0XHRcdHJldHVybiB0aW1lO1xuXG5cdFx0fSxcblxuXHRcdF9zZXRFbmRpbmdzOiBmdW5jdGlvbiAoIGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZyApIHtcblxuXHRcdFx0dmFyIHNldHRpbmdzID0gdGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncztcblxuXHRcdFx0aWYgKCBwaW5nUG9uZyApIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCBcdD0gWmVyb1Nsb3BlRW5kaW5nO1xuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmRcdFx0PSBaZXJvU2xvcGVFbmRpbmc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gYXNzdW1pbmcgZm9yIExvb3BPbmNlIGF0U3RhcnQgPT0gYXRFbmQgPT0gdHJ1ZVxuXG5cdFx0XHRcdGlmICggYXRTdGFydCApIHtcblxuXHRcdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGF0RW5kICkge1xuXG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gdGhpcy56ZXJvU2xvcGVBdEVuZCA/IFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCBcdCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0X3NjaGVkdWxlRmFkaW5nOiBmdW5jdGlvbiAoIGR1cmF0aW9uLCB3ZWlnaHROb3csIHdlaWdodFRoZW4gKSB7XG5cblx0XHRcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxuXHRcdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG5cdFx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xuXG5cdFx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcblx0XHRcdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblxuXHRcdFx0dGltZXNbIDAgXSA9IG5vdzsgXHRcdFx0XHR2YWx1ZXNbIDAgXSA9IHdlaWdodE5vdztcblx0XHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcdHZhbHVlc1sgMSBdID0gd2VpZ2h0VGhlbjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBQbGF5ZXIgZm9yIEFuaW1hdGlvbkNsaXBzLlxuXHQgKlxuXHQgKlxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cblx0ICogQGF1dGhvciB0c2Nod1xuXHQgKi9cblxuXHRmdW5jdGlvbiBBbmltYXRpb25NaXhlciggcm9vdCApIHtcblxuXHRcdHRoaXMuX3Jvb3QgPSByb290O1xuXHRcdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XG5cdFx0dGhpcy5fYWNjdUluZGV4ID0gMDtcblxuXHRcdHRoaXMudGltZSA9IDA7XG5cblx0XHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcblxuXHR9XG5cblx0QW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogQW5pbWF0aW9uTWl4ZXIsXG5cblx0XHRfYmluZEFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApIHtcblxuXHRcdFx0dmFyIHJvb3QgPSBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0XHR0cmFja3MgPSBhY3Rpb24uX2NsaXAudHJhY2tzLFxuXHRcdFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRcdFx0YmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3MsXG5cdFx0XHRcdGludGVycG9sYW50cyA9IGFjdGlvbi5faW50ZXJwb2xhbnRzLFxuXHRcdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblx0XHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRcdGJpbmRpbmdzQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRcdGlmICggYmluZGluZ3NCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRiaW5kaW5nc0J5TmFtZSA9IHt9O1xuXHRcdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdzQnlOYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcblxuXHRcdFx0XHR2YXIgdHJhY2sgPSB0cmFja3NbIGkgXSxcblx0XHRcdFx0XHR0cmFja05hbWUgPSB0cmFjay5uYW1lLFxuXHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0J5TmFtZVsgdHJhY2tOYW1lIF07XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gZXhpc3RpbmcgYmluZGluZywgbWFrZSBzdXJlIHRoZSBjYWNoZSBrbm93c1xuXG5cdFx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcGF0aCA9IHByb3RvdHlwZUFjdGlvbiAmJiBwcm90b3R5cGVBY3Rpb24uXG5cdFx0XHRcdFx0XHRfcHJvcGVydHlCaW5kaW5nc1sgaSBdLmJpbmRpbmcucGFyc2VkUGF0aDtcblxuXHRcdFx0XHRcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlNaXhlcihcblx0XHRcdFx0XHRcdFByb3BlcnR5QmluZGluZy5jcmVhdGUoIHJvb3QsIHRyYWNrTmFtZSwgcGF0aCApLFxuXHRcdFx0XHRcdFx0dHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkgKTtcblxuXHRcdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XG5cblx0XHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xuXG5cdFx0XHRpZiAoICEgdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xuXG5cdFx0XHRcdGlmICggYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXG5cdFx0XHRcdFx0Ly8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcblxuXHRcdFx0XHRcdHZhciByb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQsXG5cdFx0XHRcdFx0XHRjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgJiYgYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF0gKTtcblxuXHRcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdFx0Ly8gaW5jcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcudXNlQ291bnQgKysgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2xlbmRCaW5kaW5nKCBiaW5kaW5nICk7XG5cdFx0XHRcdFx0XHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xlbmRBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0X2RlYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuXHRcdFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdFx0Ly8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIC0tIGJpbmRpbmcudXNlQ291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcblx0XHRcdFx0XHRcdHRoaXMuX3Rha2VCYWNrQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl90YWtlQmFja0FjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyBNZW1vcnkgbWFuYWdlclxuXG5cdFx0X2luaXRNZW1vcnlNYW5hZ2VyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG5cdFx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XG5cblx0XHRcdHRoaXMuX2FjdGlvbnNCeUNsaXAgPSB7fTtcblx0XHRcdC8vIGluc2lkZTpcblx0XHRcdC8vIHtcblx0XHRcdC8vIFx0XHRrbm93bkFjdGlvbnM6IEFycmF5PCBBbmltYXRpb25BY3Rpb24gPlx0LSB1c2VkIGFzIHByb3RvdHlwZXNcblx0XHRcdC8vIFx0XHRhY3Rpb25CeVJvb3Q6IEFuaW1hdGlvbkFjdGlvblx0XHRcdC0gbG9va3VwXG5cdFx0XHQvLyB9XG5cblxuXHRcdFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gJ25BY3RpdmVCaW5kaW5ncycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xuXHRcdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblxuXHRcdFx0dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lID0ge307IC8vIGluc2lkZTogTWFwPCBuYW1lLCBQcm9wZXJ0eU1peGVyID5cblxuXG5cdFx0XHR0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzID0gW107IC8vIHNhbWUgZ2FtZSBhcyBhYm92ZVxuXHRcdFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLnN0YXRzID0ge1xuXG5cdFx0XHRcdGFjdGlvbnM6IHtcblx0XHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fYWN0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGdldCBpblVzZSgpIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQWN0aW9ucztcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0YmluZGluZ3M6IHtcblx0XHRcdFx0XHRnZXQgdG90YWwoKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb250cm9sSW50ZXJwb2xhbnRzOiB7XG5cdFx0XHRcdFx0Z2V0IHRvdGFsKCkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHNcblxuXHRcdF9pc0FjdGl2ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblx0XHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xuXG5cdFx0fSxcblxuXHRcdF9hZGRJbmFjdGl2ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApIHtcblxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB7XG5cblx0XHRcdFx0XHRrbm93bkFjdGlvbnM6IFsgYWN0aW9uIF0sXG5cdFx0XHRcdFx0YWN0aW9uQnlSb290OiB7fVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcblxuXHRcdFx0XHRhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdID0gYWN0aW9uc0ZvckNsaXA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIGtub3duQWN0aW9ucyA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcblxuXHRcdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBrbm93bkFjdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRrbm93bkFjdGlvbnMucHVzaCggYWN0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XG5cdFx0XHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xuXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gPSBhY3Rpb247XG5cblx0XHR9LFxuXG5cdFx0X3JlbW92ZUluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBhY3Rpb25zLmxlbmd0aCAtIDEgXSxcblx0XHRcdFx0Y2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcblxuXHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRcdGFjdGlvbnNbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcblx0XHRcdGFjdGlvbnMucG9wKCk7XG5cblx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cblxuXHRcdFx0dmFyIGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXG5cdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuXHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0sXG5cdFx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXG5cblx0XHRcdFx0bGFzdEtub3duQWN0aW9uID1cblx0XHRcdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCAtIDEgXSxcblxuXHRcdFx0XHRieUNsaXBDYWNoZUluZGV4ID0gYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4O1xuXG5cdFx0XHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xuXHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsgYnlDbGlwQ2FjaGVJbmRleCBdID0gbGFzdEtub3duQWN0aW9uO1xuXHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcC5wb3AoKTtcblxuXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcblxuXG5cdFx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxuXHRcdFx0XHRyb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQ7XG5cblx0XHRcdGRlbGV0ZSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRcdGlmICgga25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XG5cblx0XHR9LFxuXG5cdFx0X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xuXG5cdFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggLS0gYmluZGluZy5yZWZlcmVuY2VDb3VudCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdF9sZW5kQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblxuXHRcdFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8ICBpbmFjdGl2ZSBhY3Rpb25zICBdXG5cdFx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHRcdC8vICAgICAgICAgICAgICAgICBzICAgICAgICBhXG5cdFx0XHQvLyAgICAgICAgICAgICAgICAgIDwtc3dhcC0+XG5cdFx0XHQvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xuXG5cdFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcblxuXHRcdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyArKyxcblxuXHRcdFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdID0gYWN0aW9uO1xuXG5cdFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuXHRcdFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQWN0aW9uO1xuXG5cdFx0fSxcblxuXHRcdF90YWtlQmFja0FjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cblx0XHRcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zICB8IGluYWN0aXZlIGFjdGlvbnMgXVxuXHRcdFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8PCBpbmFjdGl2ZSBhY3Rpb25zICBdXG5cdFx0XHQvLyAgICAgICAgYSAgICAgICAgc1xuXHRcdFx0Ly8gICAgICAgICA8LXN3YXAtPlxuXHRcdFx0Ly8gICAgICAgIHMgICAgICAgIGFcblxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG5cblx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdFx0bGFzdEFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG5cdFx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuXHRcdFx0bGFzdEFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUFjdGlvbjtcblxuXHRcdH0sXG5cblx0XHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXG5cblx0XHRfYWRkSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKSB7XG5cblx0XHRcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxuXG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRcdGlmICggYmluZGluZ0J5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJpbmRpbmdCeU5hbWUgPSB7fTtcblx0XHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdID0gYmluZGluZztcblxuXHRcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcblxuXHRcdH0sXG5cblx0XHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcgKSB7XG5cblx0XHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0XHRwcm9wQmluZGluZyA9IGJpbmRpbmcuYmluZGluZyxcblx0XHRcdFx0cm9vdFV1aWQgPSBwcm9wQmluZGluZy5yb290Tm9kZS51dWlkLFxuXHRcdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuXHRcdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxuXG5cdFx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxuXHRcdFx0XHRjYWNoZUluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleDtcblxuXHRcdFx0bGFzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG5cdFx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcblx0XHRcdGJpbmRpbmdzLnBvcCgpO1xuXG5cdFx0XHRkZWxldGUgYmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF07XG5cblx0XHRcdHJlbW92ZV9lbXB0eV9tYXA6IHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgXyBpbiBiaW5kaW5nQnlOYW1lICkgYnJlYWsgcmVtb3ZlX2VtcHR5X21hcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cdFx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdF9sZW5kQmluZGluZzogZnVuY3Rpb24gKCBiaW5kaW5nICkge1xuXG5cdFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcblxuXHRcdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXG5cblx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG5cdFx0XHRiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVCaW5kaW5nO1xuXG5cdFx0fSxcblxuXHRcdF90YWtlQmFja0JpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZyApIHtcblxuXHRcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXG5cblx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzLFxuXG5cdFx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdFx0YmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYmluZGluZztcblxuXHRcdFx0bGFzdEFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0XHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQmluZGluZztcblxuXHRcdH0sXG5cblxuXHRcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXG5cblx0XHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcblx0XHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgKyssXG5cdFx0XHRcdGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXTtcblxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGludGVycG9sYW50ID0gbmV3IExpbmVhckludGVycG9sYW50KFxuXHRcdFx0XHRcdG5ldyBGbG9hdDMyQXJyYXkoIDIgKSwgbmV3IEZsb2F0MzJBcnJheSggMiApLFxuXHRcdFx0XHRcdDEsIHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgKTtcblxuXHRcdFx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG5cdFx0XHRcdGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW50ZXJwb2xhbnQ7XG5cblx0XHR9LFxuXG5cdFx0X3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50OiBmdW5jdGlvbiAoIGludGVycG9sYW50ICkge1xuXG5cdFx0XHR2YXIgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcblx0XHRcdFx0cHJldkluZGV4ID0gaW50ZXJwb2xhbnQuX19jYWNoZUluZGV4LFxuXG5cdFx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxuXG5cdFx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cblx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRcdGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuXHRcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRcdGludGVycG9sYW50c1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XG5cblx0XHR9LFxuXG5cdFx0X2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkoIDEgKSxcblxuXHRcdC8vIHJldHVybiBhbiBhY3Rpb24gZm9yIGEgY2xpcCBvcHRpb25hbGx5IHVzaW5nIGEgY3VzdG9tIHJvb3QgdGFyZ2V0XG5cdFx0Ly8gb2JqZWN0ICh0aGlzIG1ldGhvZCBhbGxvY2F0ZXMgYSBsb3Qgb2YgZHluYW1pYyBtZW1vcnkgaW4gY2FzZSBhXG5cdFx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXG5cdFx0Y2xpcEFjdGlvbjogZnVuY3Rpb24gKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cblx0XHRcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG5cdFx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXG5cdFx0XHRcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcblxuXHRcdFx0XHRjbGlwVXVpZCA9IGNsaXBPYmplY3QgIT09IG51bGwgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwLFxuXG5cdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcblx0XHRcdFx0cHJvdG90eXBlQWN0aW9uID0gbnVsbDtcblxuXHRcdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBleGlzdGluZ0FjdGlvbiA9XG5cdFx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRcdFx0aWYgKCBleGlzdGluZ0FjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB3ZSBrbm93IHRoZSBjbGlwLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHBhcnNlIGFsbFxuXHRcdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcblx0XHRcdFx0cHJvdG90eXBlQWN0aW9uID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF07XG5cblx0XHRcdFx0Ly8gYWxzbywgdGFrZSB0aGUgY2xpcCBmcm9tIHRoZSBwcm90b3R5cGUgYWN0aW9uXG5cdFx0XHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApXG5cdFx0XHRcdFx0Y2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuXHRcdFx0aWYgKCBjbGlwT2JqZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XG5cdFx0XHR2YXIgbmV3QWN0aW9uID0gbmV3IEFuaW1hdGlvbkFjdGlvbiggdGhpcywgY2xpcE9iamVjdCwgb3B0aW9uYWxSb290ICk7XG5cblx0XHRcdHRoaXMuX2JpbmRBY3Rpb24oIG5ld0FjdGlvbiwgcHJvdG90eXBlQWN0aW9uICk7XG5cblx0XHRcdC8vIGFuZCBtYWtlIHRoZSBhY3Rpb24ga25vd24gdG8gdGhlIG1lbW9yeSBtYW5hZ2VyXG5cdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggbmV3QWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKTtcblxuXHRcdFx0cmV0dXJuIG5ld0FjdGlvbjtcblxuXHRcdH0sXG5cblx0XHQvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG5cdFx0ZXhpc3RpbmdBY3Rpb246IGZ1bmN0aW9uICggY2xpcCwgb3B0aW9uYWxSb290ICkge1xuXG5cdFx0XHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblxuXHRcdFx0XHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRBbmltYXRpb25DbGlwLmZpbmRCeU5hbWUoIHJvb3QsIGNsaXAgKSA6IGNsaXAsXG5cblx0XHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblxuXHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cblx0XHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdIHx8IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9LFxuXG5cdFx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcblx0XHRzdG9wQWxsQWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XG5cdFx0XHR0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xuXG5cdFx0XHRcdGFjdGlvbnNbIGkgXS5yZXNldCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xuXG5cdFx0XHRcdGJpbmRpbmdzWyBpIF0udXNlQ291bnQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAoIGRlbHRhVGltZSApIHtcblxuXHRcdFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xuXG5cdFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cblx0XHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXG5cdFx0XHRcdHRpbWVEaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRlbHRhVGltZSApLFxuXG5cdFx0XHRcdGFjY3VJbmRleCA9IHRoaXMuX2FjY3VJbmRleCBePSAxO1xuXG5cdFx0XHQvLyBydW4gYWN0aXZlIGFjdGlvbnNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcblxuXHRcdFx0XHR2YXIgYWN0aW9uID0gYWN0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdGFjdGlvbi5fdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG5cdFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdLmFwcGx5KCBhY2N1SW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHQvLyByZXR1cm4gdGhpcyBtaXhlcidzIHJvb3QgdGFyZ2V0IG9iamVjdFxuXHRcdGdldFJvb3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XG5cblx0XHR9LFxuXG5cdFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXG5cdFx0dW5jYWNoZUNsaXA6IGZ1bmN0aW9uICggY2xpcCApIHtcblxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0XHRjbGlwVXVpZCA9IGNsaXAudXVpZCxcblx0XHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXG5cdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuXHRcdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIG5vdGU6IGp1c3QgY2FsbGluZyBfcmVtb3ZlSW5hY3RpdmVBY3Rpb24gd291bGQgbWVzcyB1cCB0aGVcblx0XHRcdFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxuXHRcdFx0XHQvLyBqdXN0IHRocm93IGF3YXlcblxuXHRcdFx0XHR2YXIgYWN0aW9uc1RvUmVtb3ZlID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHR2YXIgYWN0aW9uID0gYWN0aW9uc1RvUmVtb3ZlWyBpIF07XG5cblx0XHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0XHRcdHZhciBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xuXHRcdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblx0XHRcdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuXHRcdFx0XHRcdGFjdGlvbnNbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcblx0XHRcdFx0XHRhY3Rpb25zLnBvcCgpO1xuXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciByb290IHRhcmdldCBvYmplY3Rcblx0XHR1bmNhY2hlUm9vdDogZnVuY3Rpb24gKCByb290ICkge1xuXG5cdFx0XHR2YXIgcm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xuXG5cdFx0XHRmb3IgKCB2YXIgY2xpcFV1aWQgaW4gYWN0aW9uc0J5Q2xpcCApIHtcblxuXHRcdFx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXS5hY3Rpb25CeVJvb3QsXG5cdFx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRcdGlmICggYWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcblx0XHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgdHJhY2tOYW1lIGluIGJpbmRpbmdCeU5hbWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xuXHRcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXG5cdFx0dW5jYWNoZUFjdGlvbjogZnVuY3Rpb24gKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cblx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLmV4aXN0aW5nQWN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKTtcblxuXHRcdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gVW5pZm9ybSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVuaWZvcm06IFR5cGUgcGFyYW1ldGVyIGlzIG5vIGxvbmdlciBuZWVkZWQuJyApO1xuXHRcdFx0dmFsdWUgPSBhcmd1bWVudHNbIDEgXTtcblxuXHRcdH1cblxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHR9XG5cblx0VW5pZm9ybS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFVuaWZvcm0oIHRoaXMudmFsdWUuY2xvbmUgPT09IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmNsb25lKCkgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcblx0ICovXG5cblx0ZnVuY3Rpb24gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKSB7XG5cblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknO1xuXHRcdHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksXG5cblx0XHRpc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5OiB0cnVlLFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRcdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0XHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gc291cmNlLm1heEluc3RhbmNlZENvdW50O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcblx0ICovXG5cblx0ZnVuY3Rpb24gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBub3JtYWxpemVkICkge1xuXG5cdFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xuXG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XG5cblx0XHRjb3VudDoge1xuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0YXJyYXk6IHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRPYmplY3QuYXNzaWduKCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcblxuXHRcdGlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXG5cblx0XHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xuXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xuXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXSA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XG5cblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xuXG5cdFx0fSxcblxuXHRcdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xuXG5cdFx0fSxcblxuXHRcdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG5cdFx0fSxcblxuXHRcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xuXG5cdFx0fSxcblxuXHRcdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG5cdFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlICkge1xuXG5cdFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XG5cdFx0dGhpcy5zdHJpZGUgPSBzdHJpZGU7XG5cdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xuXG5cdFx0dGhpcy5keW5hbWljID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XG5cblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XG5cblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLCAnbmVlZHNVcGRhdGUnLCB7XG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSwge1xuXG5cdFx0aXNJbnRlcmxlYXZlZEJ1ZmZlcjogdHJ1ZSxcblxuXHRcdHNldEFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGUgOiAwO1xuXHRcdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXG5cdFx0fSxcblxuXHRcdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xuXHRcdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcblx0XHRcdHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcblx0XHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdFx0aW5kZXgxICo9IHRoaXMuc3RyaWRlO1xuXHRcdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5zdHJpZGU7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHRcdH0sXG5cblx0XHRvblVwbG9hZDogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG5cdFx0SW50ZXJsZWF2ZWRCdWZmZXIuY2FsbCggdGhpcywgYXJyYXksIHN0cmlkZSApO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xuXG5cdH1cblxuXHRJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLFxuXG5cdFx0aXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjogdHJ1ZSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0XHRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHRcdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG5cdFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xuXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xuXG5cdH1cblxuXHRJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLFxuXG5cdFx0aXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXG5cblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdFx0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdFx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuXHQgKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gUmF5Y2FzdGVyKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xuXG5cdFx0dGhpcy5yYXkgPSBuZXcgUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHR0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cblx0XHR0aGlzLnBhcmFtcyA9IHtcblx0XHRcdE1lc2g6IHt9LFxuXHRcdFx0TGluZToge30sXG5cdFx0XHRMT0Q6IHt9LFxuXHRcdFx0UG9pbnRzOiB7IHRocmVzaG9sZDogMSB9LFxuXHRcdFx0U3ByaXRlOiB7fVxuXHRcdH07XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5wYXJhbXMsIHtcblx0XHRcdFBvaW50Q2xvdWQ6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuUG9pbnRzO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XG5cblx0XHRyZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0b2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cblx0XHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdHJ1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdE9iamVjdC5hc3NpZ24oIFJheWNhc3Rlci5wcm90b3R5cGUsIHtcblxuXHRcdGxpbmVQcmVjaXNpb246IDEsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoICggY2FtZXJhICYmIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkgKSB7XG5cblx0XHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAoIGNhbWVyYSAmJiBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSApIHtcblxuXHRcdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksICggY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyICkgLyAoIGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhciApICkudW5wcm9qZWN0KCBjYW1lcmEgKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IG9wdGlvbmFsVGFyZ2V0IHx8IFtdO1xuXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cblx0XHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xuXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciBpbnRlcnNlY3RzID0gb3B0aW9uYWxUYXJnZXQgfHwgW107XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0cyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xuXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIENsb2NrKCBhdXRvU3RhcnQgKSB7XG5cblx0XHR0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XG5cblx0XHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdFx0dGhpcy5vbGRUaW1lID0gMDtcblx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBDbG9jay5wcm90b3R5cGUsIHtcblxuXHRcdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gKCB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZSA6IHBlcmZvcm1hbmNlICkubm93KCk7IC8vIHNlZSAjMTA3MzJcblxuXHRcdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG5cdFx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cblx0XHR9LFxuXG5cdFx0c3RvcDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhpcy5nZXREZWx0YSgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGRpZmYgPSAwO1xuXG5cdFx0XHRpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICEgdGhpcy5ydW5uaW5nICkge1xuXG5cdFx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdFx0dmFyIG5ld1RpbWUgPSAoIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UgKS5ub3coKTtcblxuXHRcdFx0XHRkaWZmID0gKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICkgLyAxMDAwO1xuXHRcdFx0XHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXG5cdFx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlmZjtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqXG5cdCAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG5cdCAqXG5cdCAqIFRoZSBwb2xlcyAocGhpKSBhcmUgYXQgdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB5IGF4aXMuXG5cdCAqIFRoZSBlcXVhdG9yIHN0YXJ0cyBhdCBwb3NpdGl2ZSB6LlxuXHQgKi9cblxuXHRmdW5jdGlvbiBTcGhlcmljYWwoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMS4wO1xuXHRcdHRoaXMucGhpID0gKCBwaGkgIT09IHVuZGVmaW5lZCApID8gcGhpIDogMDsgLy8gdXAgLyBkb3duIHRvd2FyZHMgdG9wIGFuZCBib3R0b20gcG9sZVxuXHRcdHRoaXMudGhldGEgPSAoIHRoZXRhICE9PSB1bmRlZmluZWQgKSA/IHRoZXRhIDogMDsgLy8gYXJvdW5kIHRoZSBlcXVhdG9yIG9mIHRoZSBzcGhlcmVcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRPYmplY3QuYXNzaWduKCBTcGhlcmljYWwucHJvdG90eXBlLCB7XG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMucGhpID0gcGhpO1xuXHRcdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBvdGhlciApIHtcblxuXHRcdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0XHR0aGlzLnBoaSA9IG90aGVyLnBoaTtcblx0XHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xuXHRcdG1ha2VTYWZlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcblx0XHRcdHRoaXMucGhpID0gTWF0aC5tYXgoIEVQUywgTWF0aC5taW4oIE1hdGguUEkgLSBFUFMsIHRoaXMucGhpICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjMyApIHtcblxuXHRcdFx0dGhpcy5yYWRpdXMgPSB2ZWMzLmxlbmd0aCgpO1xuXG5cdFx0XHRpZiAoIHRoaXMucmFkaXVzID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMudGhldGEgPSAwO1xuXHRcdFx0XHR0aGlzLnBoaSA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy50aGV0YSA9IE1hdGguYXRhbjIoIHZlYzMueCwgdmVjMy56ICk7IC8vIGVxdWF0b3IgYW5nbGUgYXJvdW5kIHktdXAgYXhpc1xuXHRcdFx0XHR0aGlzLnBoaSA9IE1hdGguYWNvcyggX01hdGguY2xhbXAoIHZlYzMueSAvIHRoaXMucmFkaXVzLCAtIDEsIDEgKSApOyAvLyBwb2xhciBhbmdsZVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICpcblx0ICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DeWxpbmRyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxuXHQgKlxuXHQgKi9cblxuXHRmdW5jdGlvbiBDeWxpbmRyaWNhbCggcmFkaXVzLCB0aGV0YSwgeSApIHtcblxuXHRcdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMS4wOyAvLyBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lXG5cdFx0dGhpcy50aGV0YSA9ICggdGhldGEgIT09IHVuZGVmaW5lZCApID8gdGhldGEgOiAwOyAvLyBjb3VudGVyY2xvY2t3aXNlIGFuZ2xlIGluIHRoZSB4LXogcGxhbmUgbWVhc3VyZWQgaW4gcmFkaWFucyBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXNcblx0XHR0aGlzLnkgPSAoIHkgIT09IHVuZGVmaW5lZCApID8geSA6IDA7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggQ3lsaW5kcmljYWwucHJvdG90eXBlLCB7XG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggcmFkaXVzLCB0aGV0YSwgeSApIHtcblxuXHRcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHR0aGlzLnRoZXRhID0gdGhldGE7XG5cdFx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0XHR9LFxuXG5cdFx0Y29weTogZnVuY3Rpb24gKCBvdGhlciApIHtcblxuXHRcdFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG5cdFx0XHR0aGlzLnRoZXRhID0gb3RoZXIudGhldGE7XG5cdFx0XHR0aGlzLnkgPSBvdGhlci55O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2ZWMzICkge1xuXG5cdFx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggdmVjMy54ICogdmVjMy54ICsgdmVjMy56ICogdmVjMy56ICk7XG5cdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggdmVjMy54LCB2ZWMzLnogKTtcblx0XHRcdHRoaXMueSA9IHZlYzMueTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEJveDIoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVmVjdG9yMiggKyBJbmZpbml0eSwgKyBJbmZpbml0eSApO1xuXHRcdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxuXHR9XG5cblx0T2JqZWN0LmFzc2lnbiggQm94Mi5wcm90b3R5cGUsIHtcblxuXHRcdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHRcdFx0dGhpcy5taW4uY29weSggbWluICk7XG5cdFx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xuXG5cdFx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cdFx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdFx0fSxcblxuXHRcdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9ICsgSW5maW5pdHk7XG5cdFx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAgKSA6IHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cblx0XHR9LFxuXG5cdFx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuXHRcdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcblx0XHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcblxuXHRcdH0sXG5cblx0XHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxuXHRcdFx0XHR0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueTtcblxuXHRcdH0sXG5cblx0XHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxuXHRcdFx0KTtcblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0Ly8gdXNpbmcgNCBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnNcblxuXHRcdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuXHRcdFx0XHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XG5cblx0XHR9LFxuXG5cdFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuXHRcdH0sXG5cblx0XHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXHRcdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuXHRcdFx0fTtcblxuXHRcdH0oKSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuXHRcdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuXHRcdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEltbWVkaWF0ZVJlbmRlck9iamVjdCggbWF0ZXJpYWwgKSB7XG5cblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIC8qIHJlbmRlckNhbGxiYWNrICovICkge307XG5cblx0fVxuXG5cdEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcblx0SW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltbWVkaWF0ZVJlbmRlck9iamVjdDtcblxuXHRJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmlzSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIFZlcnRleE5vcm1hbHNIZWxwZXIoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuXHRcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xuXG5cdFx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHRcdC8vXG5cblx0XHR2YXIgbk5vcm1hbHMgPSAwO1xuXG5cdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XG5cblx0XHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcblxuXHRcdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuY291bnQ7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcblxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XG5cblx0XHQvL1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblx0VmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZXJ0ZXhOb3JtYWxzSGVscGVyO1xuXG5cdFZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuXHRcdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cblx0XHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHR2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcblxuXHRcdFx0XHR2YXIgaWR4ID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xuXG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF07XG5cblx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG5cdFx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG5cdFx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0XHR2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0XHRcdHZhciBpZHggPSAwO1xuXG5cdFx0XHRcdC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2MS5zZXQoIG9ialBvcy5nZXRYKCBqICksIG9ialBvcy5nZXRZKCBqICksIG9ialBvcy5nZXRaKCBqICkgKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcblxuXHRcdFx0XHRcdHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH07XG5cblx0fSgpICk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKi9cblxuXHRmdW5jdGlvbiBTcG90TGlnaHRIZWxwZXIoIGxpZ2h0LCBjb2xvciApIHtcblxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHR2YXIgcG9zaXRpb25zID0gW1xuXHRcdFx0MCwgMCwgMCwgXHQwLCAwLCAxLFxuXHRcdFx0MCwgMCwgMCwgXHQxLCAwLCAxLFxuXHRcdFx0MCwgMCwgMCxcdC0gMSwgMCwgMSxcblx0XHRcdDAsIDAsIDAsIFx0MCwgMSwgMSxcblx0XHRcdDAsIDAsIDAsIFx0MCwgLSAxLCAxXG5cdFx0XTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDEsIGwgPSAzMjsgaSA8IGw7IGkgKyssIGogKysgKSB7XG5cblx0XHRcdHZhciBwMSA9ICggaSAvIGwgKSAqIE1hdGguUEkgKiAyO1xuXHRcdFx0dmFyIHAyID0gKCBqIC8gbCApICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdHBvc2l0aW9ucy5wdXNoKFxuXHRcdFx0XHRNYXRoLmNvcyggcDEgKSwgTWF0aC5zaW4oIHAxICksIDEsXG5cdFx0XHRcdE1hdGguY29zKCBwMiApLCBNYXRoLnNpbiggcDIgKSwgMVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRTcG90TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcG90TGlnaHRIZWxwZXI7XG5cblx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH07XG5cblx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwO1xuXHRcdFx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xuXG5cdFx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xuXG5cdFx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHR2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XG5cblx0XHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcblx0ICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGdldEJvbmVMaXN0KCBvYmplY3QgKSB7XG5cblx0XHR2YXIgYm9uZUxpc3QgPSBbXTtcblxuXHRcdGlmICggb2JqZWN0ICYmIG9iamVjdC5pc0JvbmUgKSB7XG5cblx0XHRcdGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Ym9uZUxpc3QucHVzaC5hcHBseSggYm9uZUxpc3QsIGdldEJvbmVMaXN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYm9uZUxpc3Q7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFNrZWxldG9uSGVscGVyKCBvYmplY3QgKSB7XG5cblx0XHR2YXIgYm9uZXMgPSBnZXRCb25lTGlzdCggb2JqZWN0ICk7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdHZhciBjb2xvcnMgPSBbXTtcblxuXHRcdHZhciBjb2xvcjEgPSBuZXcgQ29sb3IoIDAsIDAsIDEgKTtcblx0XHR2YXIgY29sb3IyID0gbmV3IENvbG9yKCAwLCAxLCAwICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBib25lID0gYm9uZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iICk7XG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0dGhpcy5yb290ID0gb2JqZWN0O1xuXHRcdHRoaXMuYm9uZXMgPSBib25lcztcblxuXHRcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdH1cblxuXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5cdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNrZWxldG9uSGVscGVyO1xuXG5cdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIGJvbmVNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0XHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRcdG1hdHJpeFdvcmxkSW52LmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBib25lID0gYm9uZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcblxuXHRcdFx0XHRcdGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBqLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGogKyAxLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0XHRqICs9IDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gUG9pbnRMaWdodEhlbHBlciggbGlnaHQsIHNwaGVyZVNpemUsIGNvbG9yICkge1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBTcGhlcmVCdWZmZXJHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuXG5cdFx0TWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblxuXHRcdC8qXG5cdFx0dmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xuXHRcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuXHRcdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXG5cdFx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdGlmICggZCA9PT0gMC4wICkge1xuXG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xuXHRcdCovXG5cblx0fVxuXG5cdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKTtcblx0UG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0SGVscGVyO1xuXG5cdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHR9O1xuXG5cdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cblx0XHR9XG5cblx0XHQvKlxuXHRcdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblxuXHRcdGlmICggZCA9PT0gMC4wICkge1xuXG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG5cdFx0fVxuXHRcdCovXG5cblx0fTtcblxuXHQvKipcblx0ICogQGF1dGhvciBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKi9cblxuXHRmdW5jdGlvbiBSZWN0QXJlYUxpZ2h0SGVscGVyKCBsaWdodCwgY29sb3IgKSB7XG5cblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA1ICogMyApLCAzICkgKTtcblxuXHRcdHRoaXMubGluZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG5cdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG5cdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdEFyZWFMaWdodEhlbHBlcjtcblxuXHRSZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLmNoaWxkcmVuWyAwIF0ubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH07XG5cblx0UmVjdEFyZWFMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gY2FsY3VsYXRlIG5ldyBkaW1lbnNpb25zIG9mIHRoZSBoZWxwZXJcblxuXHRcdHZhciBoeCA9IHRoaXMubGlnaHQud2lkdGggKiAwLjU7XG5cdFx0dmFyIGh5ID0gdGhpcy5saWdodC5oZWlnaHQgKiAwLjU7XG5cblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmxpbmUuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHR2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcblxuXHRcdC8vIHVwZGF0ZSB2ZXJ0aWNlc1xuXG5cdFx0YXJyYXlbIDAgXSA9IGh4OyBhcnJheVsgMSBdID0gLSBoeTsgYXJyYXlbIDIgXSA9IDA7XG5cdFx0YXJyYXlbIDMgXSA9IGh4OyBhcnJheVsgNCBdID0gaHk7IGFycmF5WyA1IF0gPSAwO1xuXHRcdGFycmF5WyA2IF0gPSAtIGh4OyBhcnJheVsgNyBdID0gaHk7IGFycmF5WyA4IF0gPSAwO1xuXHRcdGFycmF5WyA5IF0gPSAtIGh4OyBhcnJheVsgMTAgXSA9IC0gaHk7IGFycmF5WyAxMSBdID0gMDtcblx0XHRhcnJheVsgMTIgXSA9IGh4OyBhcnJheVsgMTMgXSA9IC0gaHk7IGFycmF5WyAxNCBdID0gMDtcblxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEhlbWlzcGhlcmVMaWdodEhlbHBlciggbGlnaHQsIHNpemUsIGNvbG9yICkge1xuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCBzaXplICk7XG5cdFx0Z2VvbWV0cnkucm90YXRlWSggTWF0aC5QSSAqIDAuNSApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuXHRcdGlmICggdGhpcy5jb2xvciA9PT0gdW5kZWZpbmVkICkgdGhpcy5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBWZXJ0ZXhDb2xvcnM7XG5cblx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb24uY291bnQgKiAzICk7XG5cblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cblx0XHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkgKTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG5cdEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcblx0SGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhlbWlzcGhlcmVMaWdodEhlbHBlcjtcblxuXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNoaWxkcmVuWyAwIF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cblx0fTtcblxuXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0dmFyIGNvbG9yMSA9IG5ldyBDb2xvcigpO1xuXHRcdHZhciBjb2xvcjIgPSBuZXcgQ29sb3IoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRcdHZhciBtZXNoID0gdGhpcy5jaGlsZHJlblsgMCBdO1xuXG5cdFx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBjb2xvcnMgPSBtZXNoLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ2NvbG9yJyApO1xuXG5cdFx0XHRcdGNvbG9yMS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XG5cdFx0XHRcdGNvbG9yMi5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBjb2xvciA9ICggaSA8ICggbCAvIDIgKSApID8gY29sb3IxIDogY29sb3IyO1xuXG5cdFx0XHRcdFx0Y29sb3JzLnNldFhZWiggaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1lc2gubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKi9cblxuXHRmdW5jdGlvbiBHcmlkSGVscGVyKCBzaXplLCBkaXZpc2lvbnMsIGNvbG9yMSwgY29sb3IyICkge1xuXG5cdFx0c2l6ZSA9IHNpemUgfHwgMTA7XG5cdFx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEwO1xuXHRcdGNvbG9yMSA9IG5ldyBDb2xvciggY29sb3IxICE9PSB1bmRlZmluZWQgPyBjb2xvcjEgOiAweDQ0NDQ0NCApO1xuXHRcdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICE9PSB1bmRlZmluZWQgPyBjb2xvcjIgOiAweDg4ODg4OCApO1xuXG5cdFx0dmFyIGNlbnRlciA9IGRpdmlzaW9ucyAvIDI7XG5cdFx0dmFyIHN0ZXAgPSBzaXplIC8gZGl2aXNpb25zO1xuXHRcdHZhciBoYWxmU2l6ZSA9IHNpemUgLyAyO1xuXG5cdFx0dmFyIHZlcnRpY2VzID0gW10sIGNvbG9ycyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgayA9IC0gaGFsZlNpemU7IGkgPD0gZGl2aXNpb25zOyBpICsrLCBrICs9IHN0ZXAgKSB7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIC0gaGFsZlNpemUsIDAsIGssIGhhbGZTaXplLCAwLCBrICk7XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCBrLCAwLCAtIGhhbGZTaXplLCBrLCAwLCBoYWxmU2l6ZSApO1xuXG5cdFx0XHR2YXIgY29sb3IgPSBpID09PSBjZW50ZXIgPyBjb2xvcjEgOiBjb2xvcjI7XG5cblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXHRcdFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XG5cblx0XHR9XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XG5cblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cdEdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuXHRHcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRIZWxwZXI7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcblx0ICogQGF1dGhvciBIZWN0YXRlIC8gaHR0cDovL3d3dy5naXRodWIuY29tL0hlY3RhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gUG9sYXJHcmlkSGVscGVyKCByYWRpdXMsIHJhZGlhbHMsIGNpcmNsZXMsIGRpdmlzaW9ucywgY29sb3IxLCBjb2xvcjIgKSB7XG5cblx0XHRyYWRpdXMgPSByYWRpdXMgfHwgMTA7XG5cdFx0cmFkaWFscyA9IHJhZGlhbHMgfHwgMTY7XG5cdFx0Y2lyY2xlcyA9IGNpcmNsZXMgfHwgODtcblx0XHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgNjQ7XG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgIT09IHVuZGVmaW5lZCA/IGNvbG9yMSA6IDB4NDQ0NDQ0ICk7XG5cdFx0Y29sb3IyID0gbmV3IENvbG9yKCBjb2xvcjIgIT09IHVuZGVmaW5lZCA/IGNvbG9yMiA6IDB4ODg4ODg4ICk7XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHR2YXIgY29sb3JzID0gW107XG5cblx0XHR2YXIgeCwgejtcblx0XHR2YXIgdiwgaSwgaiwgciwgY29sb3I7XG5cblx0XHQvLyBjcmVhdGUgdGhlIHJhZGlhbHNcblxuXHRcdGZvciAoIGkgPSAwOyBpIDw9IHJhZGlhbHM7IGkgKysgKSB7XG5cblx0XHRcdHYgPSAoIGkgLyByYWRpYWxzICkgKiAoIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdHggPSBNYXRoLnNpbiggdiApICogcmFkaXVzO1xuXHRcdFx0eiA9IE1hdGguY29zKCB2ICkgKiByYWRpdXM7XG5cblx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcblx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcblxuXHRcdFx0Y29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XG5cblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG5cdFx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIHRoZSBjaXJjbGVzXG5cblx0XHRmb3IgKCBpID0gMDsgaSA8PSBjaXJjbGVzOyBpICsrICkge1xuXG5cdFx0XHRjb2xvciA9ICggaSAmIDEgKSA/IGNvbG9yMSA6IGNvbG9yMjtcblxuXHRcdFx0ciA9IHJhZGl1cyAtICggcmFkaXVzIC8gY2lyY2xlcyAqIGkgKTtcblxuXHRcdFx0Zm9yICggaiA9IDA7IGogPCBkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0Ly8gZmlyc3QgdmVydGV4XG5cblx0XHRcdFx0diA9ICggaiAvIGRpdmlzaW9ucyApICogKCBNYXRoLlBJICogMiApO1xuXG5cdFx0XHRcdHggPSBNYXRoLnNpbiggdiApICogcjtcblx0XHRcdFx0eiA9IE1hdGguY29zKCB2ICkgKiByO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0XHQvLyBzZWNvbmQgdmVydGV4XG5cblx0XHRcdFx0diA9ICggKCBqICsgMSApIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdFx0eCA9IE1hdGguc2luKCB2ICkgKiByO1xuXHRcdFx0XHR6ID0gTWF0aC5jb3MoIHYgKSAqIHI7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xuXHRcdFx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XG5cblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cdFBvbGFyR3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5cdFBvbGFyR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2xhckdyaWRIZWxwZXI7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKi9cblxuXHRmdW5jdGlvbiBGYWNlTm9ybWFsc0hlbHBlciggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuXHRcdC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcblxuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG5cdFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XG5cblx0XHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBuTm9ybWFscyA9IDA7XG5cblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuXHRcdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcblxuXHRcdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLicgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcblxuXHRcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcblxuXHRcdC8vXG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdH1cblxuXHRGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5cdEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZhY2VOb3JtYWxzSGVscGVyO1xuXG5cdEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdC8vXG5cblx0XHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XG5cblx0XHRcdHZhciBpZHggPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cblx0XHRcdFx0djEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcblx0XHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxuXHRcdFx0XHRcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXG5cdFx0XHRcdFx0LmRpdmlkZVNjYWxhciggMyApXG5cdFx0XHRcdFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9O1xuXG5cdH0oKSApO1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICovXG5cblx0ZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodEhlbHBlciggbGlnaHQsIHNpemUsIGNvbG9yICkge1xuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cblx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAxO1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggW1xuXHRcdFx0LSBzaXplLCBzaXplLCAwLFxuXHRcdFx0c2l6ZSwgc2l6ZSwgMCxcblx0XHRcdHNpemUsIC0gc2l6ZSwgMCxcblx0XHRcdC0gc2l6ZSwgLSBzaXplLCAwLFxuXHRcdFx0LSBzaXplLCBzaXplLCAwXG5cdFx0XSwgMyApICk7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG5cblx0XHR0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xuXG5cdFx0Z2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIDAsIDAsIDAsIDAsIDAsIDEgXSwgMyApICk7XG5cblx0XHR0aGlzLnRhcmdldExpbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0dGhpcy5hZGQoIHRoaXMudGFyZ2V0TGluZSApO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHR9XG5cblx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcblx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuXG5cdERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdH07XG5cblx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciB2MyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRcdHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xuXG5cdFx0XHR0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuXG5cdFx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XG5cdFx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXHRcdFx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGFyZ2V0TGluZS5sb29rQXQoIHYzICk7XG5cdFx0XHR0aGlzLnRhcmdldExpbmUuc2NhbGUueiA9IHYzLmxlbmd0aCgpO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG5cdCAqXG5cdCAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcblx0ICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuXHQgKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcblx0ICpcdFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuXHQgKi9cblxuXHRmdW5jdGlvbiBDYW1lcmFIZWxwZXIoIGNhbWVyYSApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogRmFjZUNvbG9ycyB9ICk7XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHR2YXIgY29sb3JzID0gW107XG5cblx0XHR2YXIgcG9pbnRNYXAgPSB7fTtcblxuXHRcdC8vIGNvbG9yc1xuXG5cdFx0dmFyIGNvbG9yRnJ1c3R1bSA9IG5ldyBDb2xvciggMHhmZmFhMDAgKTtcblx0XHR2YXIgY29sb3JDb25lID0gbmV3IENvbG9yKCAweGZmMDAwMCApO1xuXHRcdHZhciBjb2xvclVwID0gbmV3IENvbG9yKCAweDAwYWFmZiApO1xuXHRcdHZhciBjb2xvclRhcmdldCA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblx0XHR2YXIgY29sb3JDcm9zcyA9IG5ldyBDb2xvciggMHgzMzMzMzMgKTtcblxuXHRcdC8vIG5lYXJcblxuXHRcdGFkZExpbmUoICduMScsICduMicsIGNvbG9yRnJ1c3R1bSApO1xuXHRcdGFkZExpbmUoICduMicsICduNCcsIGNvbG9yRnJ1c3R1bSApO1xuXHRcdGFkZExpbmUoICduNCcsICduMycsIGNvbG9yRnJ1c3R1bSApO1xuXHRcdGFkZExpbmUoICduMycsICduMScsIGNvbG9yRnJ1c3R1bSApO1xuXG5cdFx0Ly8gZmFyXG5cblx0XHRhZGRMaW5lKCAnZjEnLCAnZjInLCBjb2xvckZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCAnZjInLCAnZjQnLCBjb2xvckZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCAnZjQnLCAnZjMnLCBjb2xvckZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCAnZjMnLCAnZjEnLCBjb2xvckZydXN0dW0gKTtcblxuXHRcdC8vIHNpZGVzXG5cblx0XHRhZGRMaW5lKCAnbjEnLCAnZjEnLCBjb2xvckZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCAnbjInLCAnZjInLCBjb2xvckZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCAnbjMnLCAnZjMnLCBjb2xvckZydXN0dW0gKTtcblx0XHRhZGRMaW5lKCAnbjQnLCAnZjQnLCBjb2xvckZydXN0dW0gKTtcblxuXHRcdC8vIGNvbmVcblxuXHRcdGFkZExpbmUoICdwJywgJ24xJywgY29sb3JDb25lICk7XG5cdFx0YWRkTGluZSggJ3AnLCAnbjInLCBjb2xvckNvbmUgKTtcblx0XHRhZGRMaW5lKCAncCcsICduMycsIGNvbG9yQ29uZSApO1xuXHRcdGFkZExpbmUoICdwJywgJ240JywgY29sb3JDb25lICk7XG5cblx0XHQvLyB1cFxuXG5cdFx0YWRkTGluZSggJ3UxJywgJ3UyJywgY29sb3JVcCApO1xuXHRcdGFkZExpbmUoICd1MicsICd1MycsIGNvbG9yVXAgKTtcblx0XHRhZGRMaW5lKCAndTMnLCAndTEnLCBjb2xvclVwICk7XG5cblx0XHQvLyB0YXJnZXRcblxuXHRcdGFkZExpbmUoICdjJywgJ3QnLCBjb2xvclRhcmdldCApO1xuXHRcdGFkZExpbmUoICdwJywgJ2MnLCBjb2xvckNyb3NzICk7XG5cblx0XHQvLyBjcm9zc1xuXG5cdFx0YWRkTGluZSggJ2NuMScsICdjbjInLCBjb2xvckNyb3NzICk7XG5cdFx0YWRkTGluZSggJ2NuMycsICdjbjQnLCBjb2xvckNyb3NzICk7XG5cblx0XHRhZGRMaW5lKCAnY2YxJywgJ2NmMicsIGNvbG9yQ3Jvc3MgKTtcblx0XHRhZGRMaW5lKCAnY2YzJywgJ2NmNCcsIGNvbG9yQ3Jvc3MgKTtcblxuXHRcdGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIsIGNvbG9yICkge1xuXG5cdFx0XHRhZGRQb2ludCggYSwgY29sb3IgKTtcblx0XHRcdGFkZFBvaW50KCBiLCBjb2xvciApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkUG9pbnQoIGlkLCBjb2xvciApIHtcblxuXHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xuXHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcblxuXHRcdFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XG5cblx0XHRcdH1cblxuXHRcdFx0cG9pbnRNYXBbIGlkIF0ucHVzaCggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgLSAxICk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXHRcdGlmICggdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCApIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuXHRcdHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5wb2ludE1hcCA9IHBvaW50TWFwO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHR9XG5cblx0Q2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblx0Q2FtZXJhSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYUhlbHBlcjtcblxuXHRDYW1lcmFIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgY2FtZXJhID0gbmV3IENhbWVyYSgpO1xuXG5cdFx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xuXG5cdFx0XHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuXHRcdFx0dmFyIHBvaW50cyA9IHBvaW50TWFwWyBwb2ludCBdO1xuXG5cdFx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBwb2ludHNbIGkgXSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0Z2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdFx0cG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xuXG5cdFx0XHR2YXIgdyA9IDEsIGggPSAxO1xuXG5cdFx0XHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG5cdFx0XHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxuXG5cdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHRcdC8vIGNlbnRlciAvIHRhcmdldFxuXG5cdFx0XHRzZXRQb2ludCggJ2MnLCAwLCAwLCAtIDEgKTtcblx0XHRcdHNldFBvaW50KCAndCcsIDAsIDAsIDEgKTtcblxuXHRcdFx0Ly8gbmVhclxuXG5cdFx0XHRzZXRQb2ludCggJ24xJywgLSB3LCAtIGgsIC0gMSApO1xuXHRcdFx0c2V0UG9pbnQoICduMicsIHcsIC0gaCwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggJ24zJywgLSB3LCBoLCAtIDEgKTtcblx0XHRcdHNldFBvaW50KCAnbjQnLCB3LCBoLCAtIDEgKTtcblxuXHRcdFx0Ly8gZmFyXG5cblx0XHRcdHNldFBvaW50KCAnZjEnLCAtIHcsIC0gaCwgMSApO1xuXHRcdFx0c2V0UG9pbnQoICdmMicsIHcsIC0gaCwgMSApO1xuXHRcdFx0c2V0UG9pbnQoICdmMycsIC0gdywgaCwgMSApO1xuXHRcdFx0c2V0UG9pbnQoICdmNCcsIHcsIGgsIDEgKTtcblxuXHRcdFx0Ly8gdXBcblxuXHRcdFx0c2V0UG9pbnQoICd1MScsIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xuXHRcdFx0c2V0UG9pbnQoICd1MicsIC0gdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggJ3UzJywgMCwgaCAqIDIsIC0gMSApO1xuXG5cdFx0XHQvLyBjcm9zc1xuXG5cdFx0XHRzZXRQb2ludCggJ2NmMScsIC0gdywgMCwgMSApO1xuXHRcdFx0c2V0UG9pbnQoICdjZjInLCB3LCAwLCAxICk7XG5cdFx0XHRzZXRQb2ludCggJ2NmMycsIDAsIC0gaCwgMSApO1xuXHRcdFx0c2V0UG9pbnQoICdjZjQnLCAwLCBoLCAxICk7XG5cblx0XHRcdHNldFBvaW50KCAnY24xJywgLSB3LCAwLCAtIDEgKTtcblx0XHRcdHNldFBvaW50KCAnY24yJywgdywgMCwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggJ2NuMycsIDAsIC0gaCwgLSAxICk7XG5cdFx0XHRzZXRQb2ludCggJ2NuNCcsIDAsIGgsIC0gMSApO1xuXG5cdFx0XHRnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHQvKipcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cDovL2dpdGh1Yi5jb20vTXVnZW44N1xuXHQgKi9cblxuXHRmdW5jdGlvbiBCb3hIZWxwZXIoIG9iamVjdCwgY29sb3IgKSB7XG5cblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XG5cblx0XHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcblx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0fVxuXG5cdEJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5cdEJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hIZWxwZXI7XG5cblx0Qm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBib3ggPSBuZXcgQm94MygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMub2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ym94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBib3guaXNFbXB0eSgpICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgbWluID0gYm94Lm1pbjtcblx0XHRcdHZhciBtYXggPSBib3gubWF4O1xuXG5cdFx0XHQvKlxuXHRcdFx0ICA1X19fXzRcblx0XHRcdDEvX19fMC98XG5cdFx0XHR8IDZfX3xfN1xuXHRcdFx0Mi9fX18zL1xuXG5cdFx0XHQwOiBtYXgueCwgbWF4LnksIG1heC56XG5cdFx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG5cdFx0XHQyOiBtaW4ueCwgbWluLnksIG1heC56XG5cdFx0XHQzOiBtYXgueCwgbWluLnksIG1heC56XG5cdFx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG5cdFx0XHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XG5cdFx0XHQ2OiBtaW4ueCwgbWluLnksIG1pbi56XG5cdFx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG5cdFx0XHQqL1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHR2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0YXJyYXlbIDAgXSA9IG1heC54OyBhcnJheVsgMSBdID0gbWF4Lnk7IGFycmF5WyAyIF0gPSBtYXguejtcblx0XHRcdGFycmF5WyAzIF0gPSBtaW4ueDsgYXJyYXlbIDQgXSA9IG1heC55OyBhcnJheVsgNSBdID0gbWF4Lno7XG5cdFx0XHRhcnJheVsgNiBdID0gbWluLng7IGFycmF5WyA3IF0gPSBtaW4ueTsgYXJyYXlbIDggXSA9IG1heC56O1xuXHRcdFx0YXJyYXlbIDkgXSA9IG1heC54OyBhcnJheVsgMTAgXSA9IG1pbi55OyBhcnJheVsgMTEgXSA9IG1heC56O1xuXHRcdFx0YXJyYXlbIDEyIF0gPSBtYXgueDsgYXJyYXlbIDEzIF0gPSBtYXgueTsgYXJyYXlbIDE0IF0gPSBtaW4uejtcblx0XHRcdGFycmF5WyAxNSBdID0gbWluLng7IGFycmF5WyAxNiBdID0gbWF4Lnk7IGFycmF5WyAxNyBdID0gbWluLno7XG5cdFx0XHRhcnJheVsgMTggXSA9IG1pbi54OyBhcnJheVsgMTkgXSA9IG1pbi55OyBhcnJheVsgMjAgXSA9IG1pbi56O1xuXHRcdFx0YXJyYXlbIDIxIF0gPSBtYXgueDsgYXJyYXlbIDIyIF0gPSBtaW4ueTsgYXJyYXlbIDIzIF0gPSBtaW4uejtcblxuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRCb3hIZWxwZXIucHJvdG90eXBlLnNldEZyb21PYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICovXG5cblx0ZnVuY3Rpb24gQm94M0hlbHBlciggYm94LCBoZXggKSB7XG5cblx0XHR0aGlzLnR5cGUgPSAnQm94M0hlbHBlcic7XG5cblx0XHR0aGlzLmJveCA9IGJveDtcblxuXHRcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xuXG5cdFx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XG5cblx0XHR2YXIgcG9zaXRpb25zID0gWyAxLCAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAtIDEsIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIDEsIC0gMSwgLSAxIF07XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcblxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cblx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdH1cblxuXHRCb3gzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblx0Qm94M0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3gzSGVscGVyO1xuXG5cdEJveDNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuXHRcdHZhciBib3ggPSB0aGlzLmJveDtcblxuXHRcdGlmICggYm94LmlzRW1wdHkoKSApIHJldHVybjtcblxuXHRcdGJveC5nZXRDZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcblxuXHRcdGJveC5nZXRTaXplKCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLnNjYWxlLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuXHQgKi9cblxuXHRmdW5jdGlvbiBQbGFuZUhlbHBlciggcGxhbmUsIHNpemUsIGhleCApIHtcblxuXHRcdHRoaXMudHlwZSA9ICdQbGFuZUhlbHBlcic7XG5cblx0XHR0aGlzLnBsYW5lID0gcGxhbmU7XG5cblx0XHR0aGlzLnNpemUgPSAoIHNpemUgPT09IHVuZGVmaW5lZCApID8gMSA6IHNpemU7XG5cblx0XHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBbIDEsIC0gMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgLSAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAwLCAwLCAwIF07XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0TGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcblxuXHRcdC8vXG5cblx0XHR2YXIgcG9zaXRpb25zMiA9IFsgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIC0gMSwgMSBdO1xuXG5cdFx0dmFyIGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdGdlb21ldHJ5Mi5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMyLCAzICkgKTtcblx0XHRnZW9tZXRyeTIuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5MiwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC4yLCB0cmFuc3BhcmVudDogdHJ1ZSwgZGVwdGhXcml0ZTogZmFsc2UgfSApICkgKTtcblxuXHR9XG5cblx0UGxhbmVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZS5wcm90b3R5cGUgKTtcblx0UGxhbmVIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVIZWxwZXI7XG5cblx0UGxhbmVIZWxwZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuXHRcdHZhciBzY2FsZSA9IC0gdGhpcy5wbGFuZS5jb25zdGFudDtcblxuXHRcdGlmICggTWF0aC5hYnMoIHNjYWxlICkgPCAxZS04ICkgc2NhbGUgPSAxZS04OyAvLyBzaWduIGRvZXMgbm90IG1hdHRlclxuXG5cdFx0dGhpcy5zY2FsZS5zZXQoIDAuNSAqIHRoaXMuc2l6ZSwgMC41ICogdGhpcy5zaXplLCBzY2FsZSApO1xuXG5cdFx0dGhpcy5sb29rQXQoIHRoaXMucGxhbmUubm9ybWFsICk7XG5cblx0XHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL2dpdGh1Yi5jb20veno4NVxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG5cdCAqXG5cdCAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcblx0ICpcblx0ICogUGFyYW1ldGVyczpcblx0ICogIGRpciAtIFZlY3RvcjNcblx0ICogIG9yaWdpbiAtIFZlY3RvcjNcblx0ICogIGxlbmd0aCAtIE51bWJlclxuXHQgKiAgY29sb3IgLSBjb2xvciBpbiBoZXggdmFsdWVcblx0ICogIGhlYWRMZW5ndGggLSBOdW1iZXJcblx0ICogIGhlYWRXaWR0aCAtIE51bWJlclxuXHQgKi9cblxuXHR2YXIgbGluZUdlb21ldHJ5O1xuXHR2YXIgY29uZUdlb21ldHJ5O1xuXG5cdGZ1bmN0aW9uIEFycm93SGVscGVyKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBjb2xvciwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG5cdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcblx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMTtcblx0XHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG5cdFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cblx0XHRpZiAoIGxpbmVHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsaW5lR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdGxpbmVHZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIDAsIDAsIDAsIDAsIDEsIDAgXSwgMyApICk7XG5cblx0XHRcdGNvbmVHZW9tZXRyeSA9IG5ldyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcblx0XHRcdGNvbmVHZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0gMC41LCAwICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xuXG5cdFx0dGhpcy5saW5lID0gbmV3IExpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcblx0XHR0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcblxuXHRcdHRoaXMuY29uZSA9IG5ldyBNZXNoKCBjb25lR2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cdFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0XHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XG5cdFx0dGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cblx0fVxuXG5cdEFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuXHRBcnJvd0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJvd0hlbHBlcjtcblxuXHRBcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgYXhpcyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHJhZGlhbnM7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RGlyZWN0aW9uKCBkaXIgKSB7XG5cblx0XHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdFx0aWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAxLCAwLCAwLCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0cmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcblxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKSApO1xuXG5cdEFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG5cdFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuXHRcdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG5cdFx0dGhpcy5saW5lLnNjYWxlLnNldCggMSwgTWF0aC5tYXgoIDAsIGxlbmd0aCAtIGhlYWRMZW5ndGggKSwgMSApO1xuXHRcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcblxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cdFx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG5cdFx0dGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdH07XG5cblx0QXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBjb2xvciApO1xuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBjb2xvciApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cblx0ICovXG5cblx0ZnVuY3Rpb24gQXhlc0hlbHBlciggc2l6ZSApIHtcblxuXHRcdHNpemUgPSBzaXplIHx8IDE7XG5cblx0XHR2YXIgdmVydGljZXMgPSBbXG5cdFx0XHQwLCAwLCAwLFx0c2l6ZSwgMCwgMCxcblx0XHRcdDAsIDAsIDAsXHQwLCBzaXplLCAwLFxuXHRcdFx0MCwgMCwgMCxcdDAsIDAsIHNpemVcblx0XHRdO1xuXG5cdFx0dmFyIGNvbG9ycyA9IFtcblx0XHRcdDEsIDAsIDAsXHQxLCAwLjYsIDAsXG5cdFx0XHQwLCAxLCAwLFx0MC42LCAxLCAwLFxuXHRcdFx0MCwgMCwgMSxcdDAsIDAuNiwgMVxuXHRcdF07XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XG5cblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cdEF4ZXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuXHRBeGVzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF4ZXNIZWxwZXI7XG5cblx0LyoqXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEZhY2U0KCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG5ldyBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xuXG5cdH1cblxuXHR2YXIgTGluZVN0cmlwID0gMDtcblxuXHR2YXIgTGluZVBpZWNlcyA9IDE7XG5cblx0ZnVuY3Rpb24gTWVzaEZhY2VNYXRlcmlhbCggbWF0ZXJpYWxzICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG1hdGVyaWFscztcblxuXHR9XG5cblx0ZnVuY3Rpb24gTXVsdGlNYXRlcmlhbCggbWF0ZXJpYWxzICkge1xuXG5cdFx0aWYgKCBtYXRlcmlhbHMgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFscyA9IFtdO1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTXVsdGlNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nICk7XG5cdFx0bWF0ZXJpYWxzLmlzTXVsdGlNYXRlcmlhbCA9IHRydWU7XG5cdFx0bWF0ZXJpYWxzLm1hdGVyaWFscyA9IG1hdGVyaWFscztcblx0XHRtYXRlcmlhbHMuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbHMuc2xpY2UoKTtcblxuXHRcdH07XG5cdFx0cmV0dXJuIG1hdGVyaWFscztcblxuXHR9XG5cblx0ZnVuY3Rpb24gUG9pbnRDbG91ZCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBQYXJ0aWNsZSggbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlNwcml0ZS4nICk7XG5cdFx0cmV0dXJuIG5ldyBTcHJpdGUoIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFBhcnRpY2xlU3lzdGVtKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBQb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBQYXJ0aWNsZUJhc2ljTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFZlcnRleCggeCwgeSwgeiApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlcnRleCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuVmVjdG9yMyBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gbmV3IFZlY3RvcjMoIHgsIHksIHogKTtcblxuXHR9XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBEeW5hbWljQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0RHluYW1pYyggdHJ1ZSApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKS5zZXREeW5hbWljKCB0cnVlICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIEludDhBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQ4QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG5ldyBJbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gVWludDhBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQ4QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gbmV3IFVpbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gVWludDhDbGFtcGVkQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIEludDE2QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG5ldyBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFVpbnQxNkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDE2QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG5ldyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBJbnQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgSW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBVaW50MzJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgVWludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gRmxvYXQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBGbG9hdDY0QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GbG9hdDY0QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XG5cblx0fVxuXG5cdC8vXG5cblx0Q3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3QsIGdldFBvaW50ICkge1xuXG5cdFx0Y29uc29sZS5sb2coICdUSFJFRS5DdXJ2ZS5jcmVhdGUoKSBoYXMgYmVlbiBkZXByZWNhdGVkJyApO1xuXG5cdFx0Y29uc3RydWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuXHRcdGNvbnN0cnVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Q7XG5cdFx0Y29uc3RydWN0LnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50O1xuXG5cdFx0cmV0dXJuIGNvbnN0cnVjdDtcblxuXHR9O1xuXG5cdC8vXG5cblx0T2JqZWN0LmFzc2lnbiggQ3VydmVQYXRoLnByb3RvdHlwZSwge1xuXG5cdFx0Y3JlYXRlUG9pbnRzR2VvbWV0cnk6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZVBhdGg6IC5jcmVhdGVQb2ludHNHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXG5cblx0XHRcdHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cblx0XHR9LFxuXG5cdFx0Y3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnk6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZVBhdGg6IC5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxuXG5cdFx0XHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG5cdFx0fSxcblxuXHRcdGNyZWF0ZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmVQYXRoOiAuY3JlYXRlR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICkgaW5zdGVhZC4nICk7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvL1xuXG5cdE9iamVjdC5hc3NpZ24oIFBhdGgucHJvdG90eXBlLCB7XG5cblx0XHRmcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGF0aDogLmZyb21Qb2ludHMoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tUG9pbnRzKCkuJyApO1xuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBDbG9zZWRTcGxpbmVDdXJ2ZTMoIHBvaW50cyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLicgKTtcblxuXHRcdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XG5cdFx0dGhpcy50eXBlID0gJ2NhdG11bGxyb20nO1xuXHRcdHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxuXHR9XG5cblx0Q2xvc2VkU3BsaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlICk7XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBTcGxpbmVDdXJ2ZTMoIHBvaW50cyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZUN1cnZlMyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLicgKTtcblxuXHRcdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XG5cdFx0dGhpcy50eXBlID0gJ2NhdG11bGxyb20nO1xuXG5cdH1cblxuXHRTcGxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcblxuXHQvL1xuXG5cdGZ1bmN0aW9uIFNwbGluZSggcG9pbnRzICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzIGluc3RlYWQuJyApO1xuXG5cdFx0Q2F0bXVsbFJvbUN1cnZlMy5jYWxsKCB0aGlzLCBwb2ludHMgKTtcblx0XHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XG5cblx0fVxuXG5cdFNwbGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIFNwbGluZS5wcm90b3R5cGUsIHtcblxuXHRcdGluaXRGcm9tQXJyYXk6IGZ1bmN0aW9uICggLyogYSAqLyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLmluaXRGcm9tQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH0sXG5cdFx0Z2V0Q29udHJvbFBvaW50c0FycmF5OiBmdW5jdGlvbiAoIC8qIG9wdGlvbmFsVGFyZ2V0ICovICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3BsaW5lOiAuZ2V0Q29udHJvbFBvaW50c0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdHJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aDogZnVuY3Rpb24gKCAvKiBzYW1wbGluZ0NvZWYgKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TcGxpbmU6IC5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBBeGlzSGVscGVyKCBzaXplICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXhpc0hlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkF4ZXNIZWxwZXIuJyApO1xuXHRcdHJldHVybiBuZXcgQXhlc0hlbHBlciggc2l6ZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBCb3VuZGluZ0JveEhlbHBlciggb2JqZWN0LCBjb2xvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJvdW5kaW5nQm94SGVscGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIENyZWF0aW5nIGEgVEhSRUUuQm94SGVscGVyIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgQm94SGVscGVyKCBvYmplY3QsIGNvbG9yICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIEVkZ2VzSGVscGVyKCBvYmplY3QsIGhleCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkVkZ2VzSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5FZGdlc0dlb21ldHJ5IGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgRWRnZXNHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4ICE9PSB1bmRlZmluZWQgPyBoZXggOiAweGZmZmZmZiB9ICkgKTtcblxuXHR9XG5cblx0R3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdyaWRIZWxwZXI6IHNldENvbG9ycygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBhc3MgdGhlbSBpbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZC4nICk7XG5cblx0fTtcblxuXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNrZWxldG9uSGVscGVyOiB1cGRhdGUoKSBubyBsb25nZXIgbmVlZHMgdG8gYmUgY2FsbGVkLicgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFdpcmVmcmFtZUhlbHBlciggb2JqZWN0LCBoZXggKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XaXJlZnJhbWVIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLldpcmVmcmFtZUdlb21ldHJ5IGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmYgfSApICk7XG5cblx0fVxuXG5cdC8vXG5cblx0T2JqZWN0LmFzc2lnbiggTG9hZGVyLnByb3RvdHlwZSwge1xuXG5cdFx0ZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXI6IC5leHRyYWN0VXJsQmFzZSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5Mb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSgpIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0ZnVuY3Rpb24gWEhSTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuWEhSTG9hZGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuRmlsZUxvYWRlci4nICk7XG5cdFx0cmV0dXJuIG5ldyBGaWxlTG9hZGVyKCBtYW5hZ2VyICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIEJpbmFyeVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuRGF0YVRleHR1cmVMb2FkZXIuJyApO1xuXHRcdHJldHVybiBuZXcgRGF0YVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0Ly9cblxuXHRPYmplY3QuYXNzaWduKCBCb3gyLnByb3RvdHlwZSwge1xuXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCBvcHRpb25hbFRhcmdldCApO1xuXG5cdFx0fSxcblx0XHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuZW1wdHkoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pc0VtcHR5KCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xuXG5cdFx0fSxcblx0XHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcblxuXHRcdH0sXG5cdFx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZSggb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH1cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIEJveDMucHJvdG90eXBlLCB7XG5cblx0XHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHR9LFxuXHRcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG5cblx0XHR9LFxuXHRcdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xuXG5cdFx0fSxcblx0XHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvblNwaGVyZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNTcGhlcmUoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcblxuXHRcdH0sXG5cdFx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZSggb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH1cblx0fSApO1xuXG5cdExpbmUzLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZTM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH07XG5cblx0T2JqZWN0LmFzc2lnbiggX01hdGgsIHtcblxuXHRcdHJhbmRvbTE2OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGg6IC5yYW5kb20xNigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBNYXRoLnJhbmRvbSgpIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIE1hdGgucmFuZG9tKCk7XG5cblx0XHR9LFxuXG5cdFx0bmVhcmVzdFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGg6IC5uZWFyZXN0UG93ZXJPZlR3bygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZsb29yUG93ZXJPZlR3bygpLicgKTtcblx0XHRcdHJldHVybiBfTWF0aC5mbG9vclBvd2VyT2ZUd28oIHZhbHVlICk7XG5cblx0XHR9LFxuXG5cdFx0bmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGg6IC5uZXh0UG93ZXJPZlR3bygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNlaWxQb3dlck9mVHdvKCkuJyApO1xuXHRcdFx0cmV0dXJuIF9NYXRoLmNlaWxQb3dlck9mVHdvKCB2YWx1ZSApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRPYmplY3QuYXNzaWduKCBNYXRyaXgzLnByb3RvdHlwZSwge1xuXG5cdFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1hdHJpeDM6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuXCIgKTtcblx0XHRcdHJldHVybiB0aGlzLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKTtcblxuXHRcdH0sXG5cdFx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cblx0XHR9LFxuXHRcdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGEgKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH0sXG5cdFx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCBidWZmZXIgLyosIG9mZnNldCwgbGVuZ3RoICovICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb0J1ZmZlcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBidWZmZXIgKTtcblxuXHRcdH0sXG5cdFx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCAvKiBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb1ZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRPYmplY3QuYXNzaWduKCBNYXRyaXg0LnByb3RvdHlwZSwge1xuXG5cdFx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5leHRyYWN0UG9zaXRpb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3B5UG9zaXRpb24oKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcblxuXHRcdH0sXG5cdFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1hdHJpeDQ6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuXCIgKTtcblx0XHRcdHJldHVybiB0aGlzLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKTtcblxuXHRcdH0sXG5cdFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHYxO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG5cblx0XHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMyApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSgpLFxuXHRcdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cblx0XHR9LFxuXHRcdG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlUb0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG5cdFx0fSxcblx0XHRtdWx0aXBseVZlY3RvcjQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHRcdH0sXG5cdFx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggLyogYSAqLyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fSxcblx0XHRyb3RhdGVBeGlzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRcdHYudHJhbnNmb3JtRGlyZWN0aW9uKCB0aGlzICk7XG5cblx0XHR9LFxuXHRcdGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuXHRcdH0sXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fSxcblx0XHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoIGJ1ZmZlciAvKiwgb2Zmc2V0LCBsZW5ndGggKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5hcHBseVRvQnVmZmVyKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlciApO1xuXG5cdFx0fSxcblx0XHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGFycmF5LCBvZmZzZXQsIGxlbmd0aCAqLyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdG1ha2VGcnVzdHVtOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubWFrZUZydXN0dW0oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0UGxhbmUucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uTGluZSA9IGZ1bmN0aW9uICggbGluZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS4nICk7XG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0xpbmUoIGxpbmUgKTtcblxuXHR9O1xuXG5cdFF1YXRlcm5pb24ucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XG5cblx0fTtcblxuXHRPYmplY3QuYXNzaWduKCBSYXkucHJvdG90eXBlLCB7XG5cblx0XHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xuXG5cdFx0fSxcblx0XHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblBsYW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1BsYW5lKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApO1xuXG5cdFx0fSxcblx0XHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRPYmplY3QuYXNzaWduKCBTaGFwZS5wcm90b3R5cGUsIHtcblxuXHRcdGV4dHJhY3RBbGxQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLmV4dHJhY3RBbGxQb2ludHMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLmV4dHJhY3RQb2ludHMoKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmV4dHJhY3RQb2ludHMoIGRpdmlzaW9ucyApO1xuXG5cdFx0fSxcblx0XHRleHRydWRlOiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAuZXh0cnVkZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFeHRydWRlR2VvbWV0cnkoKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG5cblx0XHR9LFxuXHRcdG1ha2VHZW9tZXRyeTogZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLm1ha2VHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBTaGFwZUdlb21ldHJ5KCkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmFzc2lnbiggVmVjdG9yMi5wcm90b3R5cGUsIHtcblxuXHRcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKTtcblxuXHRcdH0sXG5cdFx0ZGlzdGFuY2VUb01hbmhhdHRhbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICk7XG5cblx0XHR9LFxuXHRcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIFZlY3RvcjMucHJvdG90eXBlLCB7XG5cblx0XHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xuXG5cdFx0fSxcblx0XHRzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xuXG5cdFx0fSxcblx0XHRnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xuXG5cdFx0fSxcblx0XHRnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xuXG5cdFx0fSxcblx0XHRnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG1hdHJpeCwgaW5kZXggKTtcblxuXHRcdH0sXG5cdFx0YXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseVByb2plY3Rpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLmFwcGx5TWF0cml4NCggbSApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtICk7XG5cblx0XHR9LFxuXHRcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKTtcblxuXHRcdH0sXG5cdFx0ZGlzdGFuY2VUb01hbmhhdHRhbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICk7XG5cblx0XHR9LFxuXHRcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5hc3NpZ24oIFZlY3RvcjQucHJvdG90eXBlLCB7XG5cblx0XHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICk7XG5cblx0XHR9LFxuXHRcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8vXG5cblx0T2JqZWN0LmFzc2lnbiggR2VvbWV0cnkucHJvdG90eXBlLCB7XG5cblx0XHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdGNvbXB1dGVMaW5lRGlzdGFuY2VzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeTogLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkxpbmUuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKSBpbnN0ZWFkLicgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmFzc2lnbiggT2JqZWN0M0QucHJvdG90eXBlLCB7XG5cblx0XHRnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XG5cblx0XHR9LFxuXHRcdHJlbmRlckRlcHRoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XG5cblx0XHR9LFxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE9iamVjdDNELnByb3RvdHlwZSwge1xuXG5cdFx0ZXVsZXJPcmRlcjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGlvbi5vcmRlcjtcblxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XG5cdFx0XHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dXNlUXVhdGVybmlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTE9ELnByb3RvdHlwZSwge1xuXG5cdFx0b2JqZWN0czoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTE9EOiAub2JqZWN0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5sZXZlbHMuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5sZXZlbHM7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggU2tlbGV0b24ucHJvdG90eXBlLCAndXNlVmVydGV4VGV4dHVyZScsIHtcblxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbjogdXNlVmVydGV4VGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiB1c2VWZXJ0ZXhUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEN1cnZlLnByb3RvdHlwZSwgJ19fYXJjTGVuZ3RoRGl2aXNpb25zJywge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlOiAuX19hcmNMZW5ndGhEaXZpc2lvbnMgaXMgbm93IC5hcmNMZW5ndGhEaXZpc2lvbnMuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xuXG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlOiAuX19hcmNMZW5ndGhEaXZpc2lvbnMgaXMgbm93IC5hcmNMZW5ndGhEaXZpc2lvbnMuJyApO1xuXHRcdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSB2YWx1ZTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0Ly9cblxuXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZpbG1HYXVnZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5zZXRMZW5zIGlzIGRlcHJlY2F0ZWQuIFwiICtcblx0XHRcdFx0XCJVc2UgLnNldEZvY2FsTGVuZ3RoIGFuZCAuZmlsbUdhdWdlIGZvciBhIHBob3RvZ3JhcGhpYyBzZXR1cC5cIiApO1xuXG5cdFx0aWYgKCBmaWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIHRoaXMuZmlsbUdhdWdlID0gZmlsbUdhdWdlO1xuXHRcdHRoaXMuc2V0Rm9jYWxMZW5ndGgoIGZvY2FsTGVuZ3RoICk7XG5cblx0fTtcblxuXHQvL1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaWdodC5wcm90b3R5cGUsIHtcblx0XHRvbmx5U2hhZG93OiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLm9ubHlTaGFkb3cgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUZvdjoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRm92IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mb3YuJyApO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuZm92ID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUxlZnQ6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUxlZnQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmxlZnQuJyApO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFSaWdodDoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhUmlnaHQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLnJpZ2h0LicgKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLnJpZ2h0ID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYVRvcDoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVG9wIGlzIG5vdyAuc2hhZG93LmNhbWVyYS50b3AuJyApO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEudG9wID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYUJvdHRvbToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhQm90dG9tIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5ib3R0b20uJyApO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd0NhbWVyYU5lYXI6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYU5lYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLm5lYXIuJyApO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEubmVhciA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFGYXI6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZmFyLicgKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZhciA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dDYW1lcmFWaXNpYmxlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVZpc2libGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvdy5jYW1lcmEgKSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93Qmlhczoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93QmlhcyBpcyBub3cgLnNoYWRvdy5iaWFzLicgKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaGFkb3dEYXJrbmVzczoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dEYXJrbmVzcyBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwV2lkdGg6IHtcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcFdpZHRoIGlzIG5vdyAuc2hhZG93Lm1hcFNpemUud2lkdGguJyApO1xuXHRcdFx0XHR0aGlzLnNoYWRvdy5tYXBTaXplLndpZHRoID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNoYWRvd01hcEhlaWdodDoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwSGVpZ2h0IGlzIG5vdyAuc2hhZG93Lm1hcFNpemUuaGVpZ2h0LicgKTtcblx0XHRcdFx0dGhpcy5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdC8vXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcblxuXHRcdGxlbmd0aDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuY291bnQgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XG5cblx0XHRhZGRJbmRleDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRJbmRleCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEluZGV4KCkuJyApO1xuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXggKTtcblxuXHRcdH0sXG5cdFx0YWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcblxuXHRcdFx0aWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xuXG5cdFx0XHR9XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicgKTtcblx0XHRcdHRoaXMuYWRkR3JvdXAoIHN0YXJ0LCBjb3VudCApO1xuXG5cdFx0fSxcblx0XHRjbGVhckRyYXdDYWxsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcblx0XHRcdHRoaXMuY2xlYXJHcm91cHMoKTtcblxuXHRcdH0sXG5cdFx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSwge1xuXG5cdFx0ZHJhd2NhbGxzOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvZmZzZXRzOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvL1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBVbmlmb3JtLnByb3RvdHlwZSwge1xuXG5cdFx0ZHluYW1pYzoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogLmR5bmFtaWMgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG9iamVjdC5vbkJlZm9yZVJlbmRlcigpIGluc3RlYWQuJyApO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvblVwZGF0ZToge1xuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Vbmlmb3JtOiAub25VcGRhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugb2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCkgaW5zdGVhZC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvL1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNYXRlcmlhbC5wcm90b3R5cGUsIHtcblxuXHRcdHdyYXBBcm91bmQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0d3JhcFJHQjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWw6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKCk7XG5cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2hhZGluZzoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyApO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyApO1xuXHRcdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gKCB2YWx1ZSA9PT0gRmxhdFNoYWRpbmcgKTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9ICk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSwge1xuXG5cdFx0bWV0YWw6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsOiAubWV0YWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkJyApO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLCB7XG5cblx0XHRkZXJpdmF0aXZlczoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXM7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuIFNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xuXHRcdFx0XHR0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9ICk7XG5cblx0Ly9cblxuXHRPYmplY3QuYXNzaWduKCBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZSwge1xuXG5cdFx0Z2V0Q3VycmVudFJlbmRlclRhcmdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0Q3VycmVudFJlbmRlclRhcmdldCgpIGlzIG5vdyAuZ2V0UmVuZGVyVGFyZ2V0KCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cblx0XHR9LFxuXG5cdFx0Z2V0TWF4QW5pc290cm9weTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0TWF4QW5pc290cm9weSgpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpO1xuXG5cdFx0fSxcblxuXHRcdGdldFByZWNpc2lvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0UHJlY2lzaW9uKCkgaXMgbm93IC5jYXBhYmlsaXRpZXMucHJlY2lzaW9uLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy5wcmVjaXNpb247XG5cblx0XHR9LFxuXG5cdFx0cmVzZXRHTFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5yZXNldEdMU3RhdGUoKSBpcyBub3cgLnN0YXRlLnJlc2V0KCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGUucmVzZXQoKTtcblxuXHRcdH0sXG5cblx0XHRzdXBwb3J0c0Zsb2F0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2Zsb2F0XFwnICkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcblxuXHRcdH0sXG5cdFx0c3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cblx0XHR9LFxuXHRcdHN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnICkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XG5cblx0XHR9LFxuXHRcdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFwnICkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuXHRcdH0sXG5cdFx0c3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuXHRcdH0sXG5cdFx0c3VwcG9ydHNCbGVuZE1pbk1heDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0VYVF9ibGVuZF9taW5tYXhcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cblx0XHR9LFxuXHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMoKSBpcyBub3cgLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcy4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXM7XG5cblx0XHR9LFxuXHRcdHN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0luc3RhbmNlZEFycmF5cygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0FOR0xFX2luc3RhbmNlZF9hcnJheXNcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cblx0XHR9LFxuXHRcdGVuYWJsZVNjaXNzb3JUZXN0OiBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5lbmFibGVTY2lzc29yVGVzdCgpIGlzIG5vdyAuc2V0U2Npc3NvclRlc3QoKS4nICk7XG5cdFx0XHR0aGlzLnNldFNjaXNzb3JUZXN0KCBib29sZWFuICk7XG5cblx0XHR9LFxuXHRcdGluaXRNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdGFkZFByZVBsdWdpbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9LFxuXHRcdGFkZFBvc3RQbHVnaW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFBvc3RQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH0sXG5cdFx0dXBkYXRlU2hhZG93TWFwOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuXHRcdH0sXG5cdFx0c2V0RmFjZUN1bGxpbmc6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNldEZhY2VDdWxsaW5nKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZSwge1xuXG5cdFx0c2hhZG93TWFwRW5hYmxlZDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLmVuYWJsZWQ7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nICk7XG5cdFx0XHRcdHRoaXMuc2hhZG93TWFwLmVuYWJsZWQgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwVHlwZToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLnR5cGU7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcFR5cGUgaXMgbm93IC5zaGFkb3dNYXAudHlwZS4nICk7XG5cdFx0XHRcdHRoaXMuc2hhZG93TWFwLnR5cGUgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCAvKiB2YWx1ZSAqLyApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwQ3VsbEZhY2UgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC4nICk7XG5cblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xTaGFkb3dNYXAucHJvdG90eXBlLCB7XG5cblx0XHRjdWxsRmFjZToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5jdWxsRmFjZSBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLicgKTtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCAvKiBjdWxsRmFjZSAqLyApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLmN1bGxGYWNlIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyApO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZW5kZXJSZXZlcnNlU2lkZWQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5yZW5kZXJSZXZlcnNlU2lkZWQgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IE1hdGVyaWFsLnNoYWRvd1NpZGUgaW5zdGVhZC4nICk7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbmRlclNpbmdsZVNpZGVkOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLnJlbmRlclNpbmdsZVNpZGVkIGhhcyBiZWVuIHJlbW92ZWQuIFNldCBNYXRlcmlhbC5zaGFkb3dTaWRlIGluc3RlYWQuJyApO1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5yZW5kZXJTaW5nbGVTaWRlZCBoYXMgYmVlbiByZW1vdmVkLiBTZXQgTWF0ZXJpYWwuc2hhZG93U2lkZSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHR9ICk7XG5cblx0Ly9cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XG5cblx0XHR3cmFwUzoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcblx0XHRcdFx0dGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHdyYXBUOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUud3JhcFQ7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyApO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUud3JhcFQgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWFnRmlsdGVyOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXI7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5tYWdGaWx0ZXIgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bWluRmlsdGVyOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XG5cblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB2YWx1ZTtcblxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pc290cm9weToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5O1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XG5cdFx0XHRcdHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5ID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdG9mZnNldDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUub2Zmc2V0ID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlcGVhdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdGZvcm1hdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuZm9ybWF0O1xuXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyApO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUuZm9ybWF0ID0gdmFsdWU7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdHR5cGU6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcblxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xuXHRcdFx0XHR0aGlzLnRleHR1cmUudHlwZSA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnZW5lcmF0ZU1pcG1hcHM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcblx0XHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvL1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJWUk1hbmFnZXIucHJvdG90eXBlLCB7XG5cblx0XHRzdGFuZGluZzoge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIC8qIHZhbHVlICovICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlZSTWFuYWdlcjogLnN0YW5kaW5nIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvL1xuXG5cdEF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IC5sb2FkIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5BdWRpb0xvYWRlciBpbnN0ZWFkLicgKTtcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdHZhciBhdWRpb0xvYWRlciA9IG5ldyBBdWRpb0xvYWRlcigpO1xuXHRcdGF1ZGlvTG9hZGVyLmxvYWQoIGZpbGUsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRzY29wZS5zZXRCdWZmZXIoIGJ1ZmZlciApO1xuXG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0QXVkaW9BbmFseXNlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvQW5hbHlzZXI6IC5nZXREYXRhKCkgaXMgbm93IC5nZXRGcmVxdWVuY3lEYXRhKCkuJyApO1xuXHRcdHJldHVybiB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblxuXHR9O1xuXG5cdC8vXG5cblx0Q3ViZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3ViZUNhbWVyYTogLnVwZGF0ZUN1YmVNYXAoKSBpcyBub3cgLnVwZGF0ZSgpLicgKTtcblx0XHRyZXR1cm4gdGhpcy51cGRhdGUoIHJlbmRlcmVyLCBzY2VuZSApO1xuXG5cdH07XG5cblx0Ly9cblxuXHR2YXIgR2VvbWV0cnlVdGlscyA9IHtcblxuXHRcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuJyApO1xuXHRcdFx0dmFyIG1hdHJpeDtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeTIuaXNNZXNoICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5Mi5tYXRyaXhBdXRvVXBkYXRlICYmIGdlb21ldHJ5Mi51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0XHRtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xuXHRcdFx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkxLm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApO1xuXG5cdFx0fSxcblxuXHRcdGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLmNlbnRlcigpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkuY2VudGVyKCkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR2YXIgSW1hZ2VVdGlscyA9IHtcblxuXHRcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cblx0XHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmwsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XG5cblx0XHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEN1YmVUZXh0dXJlTG9hZGVyKCk7XG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuXHRcdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcblxuXHRcdFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9LFxuXG5cdFx0bG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApO1xuXG5cdFx0fSxcblxuXHRcdGxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBQcm9qZWN0b3IoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLicgKTtcblxuXHRcdHRoaXMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG5cdFx0XHR2ZWN0b3IucHJvamVjdCggY2FtZXJhICk7XG5cblx0XHR9O1xuXG5cdFx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLicgKTtcblx0XHRcdHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xuXG5cdFx0fTtcblxuXHRcdHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvcjogLnBpY2tpbmdSYXkoKSBpcyBub3cgcmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoKS4nICk7XG5cblx0XHR9O1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XG5cblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge307XG5cdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7fTtcblxuXHR9XG5cblx0Ly9cblxuXHR2YXIgU2NlbmVVdGlscyA9IHtcblxuXHRcdGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uICggLyogZ2VvbWV0cnksIG1hdGVyaWFscyAqLyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNjZW5lVXRpbHMgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3V0aWxzL1NjZW5lVXRpbHMuanMnICk7XG5cblx0XHR9LFxuXG5cdFx0ZGV0YWNoOiBmdW5jdGlvbiAoIC8qIGNoaWxkLCBwYXJlbnQsIHNjZW5lICovICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU2NlbmVVdGlscyBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvdXRpbHMvU2NlbmVVdGlscy5qcycgKTtcblxuXHRcdH0sXG5cblx0XHRhdHRhY2g6IGZ1bmN0aW9uICggLyogY2hpbGQsIHNjZW5lLCBwYXJlbnQgKi8gKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TY2VuZVV0aWxzIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy91dGlscy9TY2VuZVV0aWxzLmpzJyApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBMZW5zRmxhcmUoKSB7XG5cblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTGVuc0ZsYXJlIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9vYmplY3RzL0xlbnNmbGFyZS5qcycgKTtcblxuXHR9XG5cblx0ZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBXZWJHTFJlbmRlclRhcmdldEN1YmU7XG5cdGV4cG9ydHMuV2ViR0xSZW5kZXJUYXJnZXQgPSBXZWJHTFJlbmRlclRhcmdldDtcblx0ZXhwb3J0cy5XZWJHTFJlbmRlcmVyID0gV2ViR0xSZW5kZXJlcjtcblx0ZXhwb3J0cy5TaGFkZXJMaWIgPSBTaGFkZXJMaWI7XG5cdGV4cG9ydHMuVW5pZm9ybXNMaWIgPSBVbmlmb3Jtc0xpYjtcblx0ZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzID0gVW5pZm9ybXNVdGlscztcblx0ZXhwb3J0cy5TaGFkZXJDaHVuayA9IFNoYWRlckNodW5rO1xuXHRleHBvcnRzLkZvZ0V4cDIgPSBGb2dFeHAyO1xuXHRleHBvcnRzLkZvZyA9IEZvZztcblx0ZXhwb3J0cy5TY2VuZSA9IFNjZW5lO1xuXHRleHBvcnRzLlNwcml0ZSA9IFNwcml0ZTtcblx0ZXhwb3J0cy5MT0QgPSBMT0Q7XG5cdGV4cG9ydHMuU2tpbm5lZE1lc2ggPSBTa2lubmVkTWVzaDtcblx0ZXhwb3J0cy5Ta2VsZXRvbiA9IFNrZWxldG9uO1xuXHRleHBvcnRzLkJvbmUgPSBCb25lO1xuXHRleHBvcnRzLk1lc2ggPSBNZXNoO1xuXHRleHBvcnRzLkxpbmVTZWdtZW50cyA9IExpbmVTZWdtZW50cztcblx0ZXhwb3J0cy5MaW5lTG9vcCA9IExpbmVMb29wO1xuXHRleHBvcnRzLkxpbmUgPSBMaW5lO1xuXHRleHBvcnRzLlBvaW50cyA9IFBvaW50cztcblx0ZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xuXHRleHBvcnRzLlZpZGVvVGV4dHVyZSA9IFZpZGVvVGV4dHVyZTtcblx0ZXhwb3J0cy5EYXRhVGV4dHVyZSA9IERhdGFUZXh0dXJlO1xuXHRleHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlID0gQ29tcHJlc3NlZFRleHR1cmU7XG5cdGV4cG9ydHMuQ3ViZVRleHR1cmUgPSBDdWJlVGV4dHVyZTtcblx0ZXhwb3J0cy5DYW52YXNUZXh0dXJlID0gQ2FudmFzVGV4dHVyZTtcblx0ZXhwb3J0cy5EZXB0aFRleHR1cmUgPSBEZXB0aFRleHR1cmU7XG5cdGV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmU7XG5cdGV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgPSBDb21wcmVzc2VkVGV4dHVyZUxvYWRlcjtcblx0ZXhwb3J0cy5EYXRhVGV4dHVyZUxvYWRlciA9IERhdGFUZXh0dXJlTG9hZGVyO1xuXHRleHBvcnRzLkN1YmVUZXh0dXJlTG9hZGVyID0gQ3ViZVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuVGV4dHVyZUxvYWRlciA9IFRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuT2JqZWN0TG9hZGVyID0gT2JqZWN0TG9hZGVyO1xuXHRleHBvcnRzLk1hdGVyaWFsTG9hZGVyID0gTWF0ZXJpYWxMb2FkZXI7XG5cdGV4cG9ydHMuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBCdWZmZXJHZW9tZXRyeUxvYWRlcjtcblx0ZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdGV4cG9ydHMuTG9hZGluZ01hbmFnZXIgPSBMb2FkaW5nTWFuYWdlcjtcblx0ZXhwb3J0cy5KU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcblx0ZXhwb3J0cy5JbWFnZUxvYWRlciA9IEltYWdlTG9hZGVyO1xuXHRleHBvcnRzLkltYWdlQml0bWFwTG9hZGVyID0gSW1hZ2VCaXRtYXBMb2FkZXI7XG5cdGV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XG5cdGV4cG9ydHMuRmlsZUxvYWRlciA9IEZpbGVMb2FkZXI7XG5cdGV4cG9ydHMuTG9hZGVyID0gTG9hZGVyO1xuXHRleHBvcnRzLkxvYWRlclV0aWxzID0gTG9hZGVyVXRpbHM7XG5cdGV4cG9ydHMuQ2FjaGUgPSBDYWNoZTtcblx0ZXhwb3J0cy5BdWRpb0xvYWRlciA9IEF1ZGlvTG9hZGVyO1xuXHRleHBvcnRzLlNwb3RMaWdodFNoYWRvdyA9IFNwb3RMaWdodFNoYWRvdztcblx0ZXhwb3J0cy5TcG90TGlnaHQgPSBTcG90TGlnaHQ7XG5cdGV4cG9ydHMuUG9pbnRMaWdodCA9IFBvaW50TGlnaHQ7XG5cdGV4cG9ydHMuUmVjdEFyZWFMaWdodCA9IFJlY3RBcmVhTGlnaHQ7XG5cdGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0ID0gSGVtaXNwaGVyZUxpZ2h0O1xuXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93O1xuXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHQgPSBEaXJlY3Rpb25hbExpZ2h0O1xuXHRleHBvcnRzLkFtYmllbnRMaWdodCA9IEFtYmllbnRMaWdodDtcblx0ZXhwb3J0cy5MaWdodFNoYWRvdyA9IExpZ2h0U2hhZG93O1xuXHRleHBvcnRzLkxpZ2h0ID0gTGlnaHQ7XG5cdGV4cG9ydHMuU3RlcmVvQ2FtZXJhID0gU3RlcmVvQ2FtZXJhO1xuXHRleHBvcnRzLlBlcnNwZWN0aXZlQ2FtZXJhID0gUGVyc3BlY3RpdmVDYW1lcmE7XG5cdGV4cG9ydHMuT3J0aG9ncmFwaGljQ2FtZXJhID0gT3J0aG9ncmFwaGljQ2FtZXJhO1xuXHRleHBvcnRzLkN1YmVDYW1lcmEgPSBDdWJlQ2FtZXJhO1xuXHRleHBvcnRzLkFycmF5Q2FtZXJhID0gQXJyYXlDYW1lcmE7XG5cdGV4cG9ydHMuQ2FtZXJhID0gQ2FtZXJhO1xuXHRleHBvcnRzLkF1ZGlvTGlzdGVuZXIgPSBBdWRpb0xpc3RlbmVyO1xuXHRleHBvcnRzLlBvc2l0aW9uYWxBdWRpbyA9IFBvc2l0aW9uYWxBdWRpbztcblx0ZXhwb3J0cy5BdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHQ7XG5cdGV4cG9ydHMuQXVkaW9BbmFseXNlciA9IEF1ZGlvQW5hbHlzZXI7XG5cdGV4cG9ydHMuQXVkaW8gPSBBdWRpbztcblx0ZXhwb3J0cy5WZWN0b3JLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5TdHJpbmdLZXlmcmFtZVRyYWNrID0gU3RyaW5nS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuXHRleHBvcnRzLk51bWJlcktleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXHRleHBvcnRzLkNvbG9yS2V5ZnJhbWVUcmFjayA9IENvbG9yS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5Cb29sZWFuS2V5ZnJhbWVUcmFjayA9IEJvb2xlYW5LZXlmcmFtZVRyYWNrO1xuXHRleHBvcnRzLlByb3BlcnR5TWl4ZXIgPSBQcm9wZXJ0eU1peGVyO1xuXHRleHBvcnRzLlByb3BlcnR5QmluZGluZyA9IFByb3BlcnR5QmluZGluZztcblx0ZXhwb3J0cy5LZXlmcmFtZVRyYWNrID0gS2V5ZnJhbWVUcmFjaztcblx0ZXhwb3J0cy5BbmltYXRpb25VdGlscyA9IEFuaW1hdGlvblV0aWxzO1xuXHRleHBvcnRzLkFuaW1hdGlvbk9iamVjdEdyb3VwID0gQW5pbWF0aW9uT2JqZWN0R3JvdXA7XG5cdGV4cG9ydHMuQW5pbWF0aW9uTWl4ZXIgPSBBbmltYXRpb25NaXhlcjtcblx0ZXhwb3J0cy5BbmltYXRpb25DbGlwID0gQW5pbWF0aW9uQ2xpcDtcblx0ZXhwb3J0cy5Vbmlmb3JtID0gVW5pZm9ybTtcblx0ZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLkJ1ZmZlckdlb21ldHJ5ID0gQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeTtcblx0ZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlO1xuXHRleHBvcnRzLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI7XG5cdGV4cG9ydHMuSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnRlcmxlYXZlZEJ1ZmZlcjtcblx0ZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuRmFjZTMgPSBGYWNlMztcblx0ZXhwb3J0cy5PYmplY3QzRCA9IE9iamVjdDNEO1xuXHRleHBvcnRzLlJheWNhc3RlciA9IFJheWNhc3Rlcjtcblx0ZXhwb3J0cy5MYXllcnMgPSBMYXllcnM7XG5cdGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xuXHRleHBvcnRzLkNsb2NrID0gQ2xvY2s7XG5cdGV4cG9ydHMuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50O1xuXHRleHBvcnRzLkxpbmVhckludGVycG9sYW50ID0gTGluZWFySW50ZXJwb2xhbnQ7XG5cdGV4cG9ydHMuRGlzY3JldGVJbnRlcnBvbGFudCA9IERpc2NyZXRlSW50ZXJwb2xhbnQ7XG5cdGV4cG9ydHMuQ3ViaWNJbnRlcnBvbGFudCA9IEN1YmljSW50ZXJwb2xhbnQ7XG5cdGV4cG9ydHMuSW50ZXJwb2xhbnQgPSBJbnRlcnBvbGFudDtcblx0ZXhwb3J0cy5UcmlhbmdsZSA9IFRyaWFuZ2xlO1xuXHRleHBvcnRzLk1hdGggPSBfTWF0aDtcblx0ZXhwb3J0cy5TcGhlcmljYWwgPSBTcGhlcmljYWw7XG5cdGV4cG9ydHMuQ3lsaW5kcmljYWwgPSBDeWxpbmRyaWNhbDtcblx0ZXhwb3J0cy5QbGFuZSA9IFBsYW5lO1xuXHRleHBvcnRzLkZydXN0dW0gPSBGcnVzdHVtO1xuXHRleHBvcnRzLlNwaGVyZSA9IFNwaGVyZTtcblx0ZXhwb3J0cy5SYXkgPSBSYXk7XG5cdGV4cG9ydHMuTWF0cml4NCA9IE1hdHJpeDQ7XG5cdGV4cG9ydHMuTWF0cml4MyA9IE1hdHJpeDM7XG5cdGV4cG9ydHMuQm94MyA9IEJveDM7XG5cdGV4cG9ydHMuQm94MiA9IEJveDI7XG5cdGV4cG9ydHMuTGluZTMgPSBMaW5lMztcblx0ZXhwb3J0cy5FdWxlciA9IEV1bGVyO1xuXHRleHBvcnRzLlZlY3RvcjQgPSBWZWN0b3I0O1xuXHRleHBvcnRzLlZlY3RvcjMgPSBWZWN0b3IzO1xuXHRleHBvcnRzLlZlY3RvcjIgPSBWZWN0b3IyO1xuXHRleHBvcnRzLlF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uO1xuXHRleHBvcnRzLkNvbG9yID0gQ29sb3I7XG5cdGV4cG9ydHMuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuXHRleHBvcnRzLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBWZXJ0ZXhOb3JtYWxzSGVscGVyO1xuXHRleHBvcnRzLlNwb3RMaWdodEhlbHBlciA9IFNwb3RMaWdodEhlbHBlcjtcblx0ZXhwb3J0cy5Ta2VsZXRvbkhlbHBlciA9IFNrZWxldG9uSGVscGVyO1xuXHRleHBvcnRzLlBvaW50TGlnaHRIZWxwZXIgPSBQb2ludExpZ2h0SGVscGVyO1xuXHRleHBvcnRzLlJlY3RBcmVhTGlnaHRIZWxwZXIgPSBSZWN0QXJlYUxpZ2h0SGVscGVyO1xuXHRleHBvcnRzLkhlbWlzcGhlcmVMaWdodEhlbHBlciA9IEhlbWlzcGhlcmVMaWdodEhlbHBlcjtcblx0ZXhwb3J0cy5HcmlkSGVscGVyID0gR3JpZEhlbHBlcjtcblx0ZXhwb3J0cy5Qb2xhckdyaWRIZWxwZXIgPSBQb2xhckdyaWRIZWxwZXI7XG5cdGV4cG9ydHMuRmFjZU5vcm1hbHNIZWxwZXIgPSBGYWNlTm9ybWFsc0hlbHBlcjtcblx0ZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcblx0ZXhwb3J0cy5DYW1lcmFIZWxwZXIgPSBDYW1lcmFIZWxwZXI7XG5cdGV4cG9ydHMuQm94SGVscGVyID0gQm94SGVscGVyO1xuXHRleHBvcnRzLkJveDNIZWxwZXIgPSBCb3gzSGVscGVyO1xuXHRleHBvcnRzLlBsYW5lSGVscGVyID0gUGxhbmVIZWxwZXI7XG5cdGV4cG9ydHMuQXJyb3dIZWxwZXIgPSBBcnJvd0hlbHBlcjtcblx0ZXhwb3J0cy5BeGVzSGVscGVyID0gQXhlc0hlbHBlcjtcblx0ZXhwb3J0cy5TaGFwZSA9IFNoYXBlO1xuXHRleHBvcnRzLlBhdGggPSBQYXRoO1xuXHRleHBvcnRzLlNoYXBlUGF0aCA9IFNoYXBlUGF0aDtcblx0ZXhwb3J0cy5Gb250ID0gRm9udDtcblx0ZXhwb3J0cy5DdXJ2ZVBhdGggPSBDdXJ2ZVBhdGg7XG5cdGV4cG9ydHMuQ3VydmUgPSBDdXJ2ZTtcblx0ZXhwb3J0cy5TaGFwZVV0aWxzID0gU2hhcGVVdGlscztcblx0ZXhwb3J0cy5XZWJHTFV0aWxzID0gV2ViR0xVdGlscztcblx0ZXhwb3J0cy5XaXJlZnJhbWVHZW9tZXRyeSA9IFdpcmVmcmFtZUdlb21ldHJ5O1xuXHRleHBvcnRzLlBhcmFtZXRyaWNHZW9tZXRyeSA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcblx0ZXhwb3J0cy5QYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkgPSBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuVGV0cmFoZWRyb25HZW9tZXRyeSA9IFRldHJhaGVkcm9uR2VvbWV0cnk7XG5cdGV4cG9ydHMuVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSA9IFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuT2N0YWhlZHJvbkdlb21ldHJ5ID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xuXHRleHBvcnRzLk9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSA9IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5JY29zYWhlZHJvbkdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcblx0ZXhwb3J0cy5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5Eb2RlY2FoZWRyb25HZW9tZXRyeSA9IERvZGVjYWhlZHJvbkdlb21ldHJ5O1xuXHRleHBvcnRzLkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuUG9seWhlZHJvbkdlb21ldHJ5ID0gUG9seWhlZHJvbkdlb21ldHJ5O1xuXHRleHBvcnRzLlBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSA9IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5UdWJlR2VvbWV0cnkgPSBUdWJlR2VvbWV0cnk7XG5cdGV4cG9ydHMuVHViZUJ1ZmZlckdlb21ldHJ5ID0gVHViZUJ1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLlRvcnVzS25vdEdlb21ldHJ5ID0gVG9ydXNLbm90R2VvbWV0cnk7XG5cdGV4cG9ydHMuVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkgPSBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5Ub3J1c0dlb21ldHJ5ID0gVG9ydXNHZW9tZXRyeTtcblx0ZXhwb3J0cy5Ub3J1c0J1ZmZlckdlb21ldHJ5ID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5UZXh0R2VvbWV0cnkgPSBUZXh0R2VvbWV0cnk7XG5cdGV4cG9ydHMuVGV4dEJ1ZmZlckdlb21ldHJ5ID0gVGV4dEJ1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLlNwaGVyZUdlb21ldHJ5ID0gU3BoZXJlR2VvbWV0cnk7XG5cdGV4cG9ydHMuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBTcGhlcmVCdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5SaW5nR2VvbWV0cnkgPSBSaW5nR2VvbWV0cnk7XG5cdGV4cG9ydHMuUmluZ0J1ZmZlckdlb21ldHJ5ID0gUmluZ0J1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLlBsYW5lR2VvbWV0cnkgPSBQbGFuZUdlb21ldHJ5O1xuXHRleHBvcnRzLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBQbGFuZUJ1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLkxhdGhlR2VvbWV0cnkgPSBMYXRoZUdlb21ldHJ5O1xuXHRleHBvcnRzLkxhdGhlQnVmZmVyR2VvbWV0cnkgPSBMYXRoZUJ1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLlNoYXBlR2VvbWV0cnkgPSBTaGFwZUdlb21ldHJ5O1xuXHRleHBvcnRzLlNoYXBlQnVmZmVyR2VvbWV0cnkgPSBTaGFwZUJ1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLkV4dHJ1ZGVHZW9tZXRyeSA9IEV4dHJ1ZGVHZW9tZXRyeTtcblx0ZXhwb3J0cy5FeHRydWRlQnVmZmVyR2VvbWV0cnkgPSBFeHRydWRlQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuRWRnZXNHZW9tZXRyeSA9IEVkZ2VzR2VvbWV0cnk7XG5cdGV4cG9ydHMuQ29uZUdlb21ldHJ5ID0gQ29uZUdlb21ldHJ5O1xuXHRleHBvcnRzLkNvbmVCdWZmZXJHZW9tZXRyeSA9IENvbmVCdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5DeWxpbmRlckdlb21ldHJ5ID0gQ3lsaW5kZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5DeWxpbmRlckJ1ZmZlckdlb21ldHJ5ID0gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeTtcblx0ZXhwb3J0cy5DaXJjbGVHZW9tZXRyeSA9IENpcmNsZUdlb21ldHJ5O1xuXHRleHBvcnRzLkNpcmNsZUJ1ZmZlckdlb21ldHJ5ID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG5cdGV4cG9ydHMuQm94R2VvbWV0cnkgPSBCb3hHZW9tZXRyeTtcblx0ZXhwb3J0cy5Cb3hCdWZmZXJHZW9tZXRyeSA9IEJveEJ1ZmZlckdlb21ldHJ5O1xuXHRleHBvcnRzLlNoYWRvd01hdGVyaWFsID0gU2hhZG93TWF0ZXJpYWw7XG5cdGV4cG9ydHMuU3ByaXRlTWF0ZXJpYWwgPSBTcHJpdGVNYXRlcmlhbDtcblx0ZXhwb3J0cy5SYXdTaGFkZXJNYXRlcmlhbCA9IFJhd1NoYWRlck1hdGVyaWFsO1xuXHRleHBvcnRzLlNoYWRlck1hdGVyaWFsID0gU2hhZGVyTWF0ZXJpYWw7XG5cdGV4cG9ydHMuUG9pbnRzTWF0ZXJpYWwgPSBQb2ludHNNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoUGh5c2ljYWxNYXRlcmlhbCA9IE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hTdGFuZGFyZE1hdGVyaWFsID0gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaFBob25nTWF0ZXJpYWwgPSBNZXNoUGhvbmdNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoVG9vbk1hdGVyaWFsID0gTWVzaFRvb25NYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBNZXNoTm9ybWFsTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaExhbWJlcnRNYXRlcmlhbCA9IE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWVzaERlcHRoTWF0ZXJpYWwgPSBNZXNoRGVwdGhNYXRlcmlhbDtcblx0ZXhwb3J0cy5NZXNoRGlzdGFuY2VNYXRlcmlhbCA9IE1lc2hEaXN0YW5jZU1hdGVyaWFsO1xuXHRleHBvcnRzLk1lc2hCYXNpY01hdGVyaWFsID0gTWVzaEJhc2ljTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTGluZURhc2hlZE1hdGVyaWFsID0gTGluZURhc2hlZE1hdGVyaWFsO1xuXHRleHBvcnRzLkxpbmVCYXNpY01hdGVyaWFsID0gTGluZUJhc2ljTWF0ZXJpYWw7XG5cdGV4cG9ydHMuTWF0ZXJpYWwgPSBNYXRlcmlhbDtcblx0ZXhwb3J0cy5GbG9hdDY0QnVmZmVyQXR0cmlidXRlID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5GbG9hdDMyQnVmZmVyQXR0cmlidXRlID0gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50MzJCdWZmZXJBdHRyaWJ1dGUgPSBVaW50MzJCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50MzJCdWZmZXJBdHRyaWJ1dGUgPSBJbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBVaW50MTZCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuVWludDhCdWZmZXJBdHRyaWJ1dGUgPSBVaW50OEJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5JbnQ4QnVmZmVyQXR0cmlidXRlID0gSW50OEJ1ZmZlckF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5CdWZmZXJBdHRyaWJ1dGUgPSBCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuQXJjQ3VydmUgPSBBcmNDdXJ2ZTtcblx0ZXhwb3J0cy5DYXRtdWxsUm9tQ3VydmUzID0gQ2F0bXVsbFJvbUN1cnZlMztcblx0ZXhwb3J0cy5DdWJpY0JlemllckN1cnZlID0gQ3ViaWNCZXppZXJDdXJ2ZTtcblx0ZXhwb3J0cy5DdWJpY0JlemllckN1cnZlMyA9IEN1YmljQmV6aWVyQ3VydmUzO1xuXHRleHBvcnRzLkVsbGlwc2VDdXJ2ZSA9IEVsbGlwc2VDdXJ2ZTtcblx0ZXhwb3J0cy5MaW5lQ3VydmUgPSBMaW5lQ3VydmU7XG5cdGV4cG9ydHMuTGluZUN1cnZlMyA9IExpbmVDdXJ2ZTM7XG5cdGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcblx0ZXhwb3J0cy5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM7XG5cdGV4cG9ydHMuU3BsaW5lQ3VydmUgPSBTcGxpbmVDdXJ2ZTtcblx0ZXhwb3J0cy5SRVZJU0lPTiA9IFJFVklTSU9OO1xuXHRleHBvcnRzLk1PVVNFID0gTU9VU0U7XG5cdGV4cG9ydHMuQ3VsbEZhY2VOb25lID0gQ3VsbEZhY2VOb25lO1xuXHRleHBvcnRzLkN1bGxGYWNlQmFjayA9IEN1bGxGYWNlQmFjaztcblx0ZXhwb3J0cy5DdWxsRmFjZUZyb250ID0gQ3VsbEZhY2VGcm9udDtcblx0ZXhwb3J0cy5DdWxsRmFjZUZyb250QmFjayA9IEN1bGxGYWNlRnJvbnRCYWNrO1xuXHRleHBvcnRzLkZyb250RmFjZURpcmVjdGlvbkNXID0gRnJvbnRGYWNlRGlyZWN0aW9uQ1c7XG5cdGV4cG9ydHMuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gRnJvbnRGYWNlRGlyZWN0aW9uQ0NXO1xuXHRleHBvcnRzLkJhc2ljU2hhZG93TWFwID0gQmFzaWNTaGFkb3dNYXA7XG5cdGV4cG9ydHMuUENGU2hhZG93TWFwID0gUENGU2hhZG93TWFwO1xuXHRleHBvcnRzLlBDRlNvZnRTaGFkb3dNYXAgPSBQQ0ZTb2Z0U2hhZG93TWFwO1xuXHRleHBvcnRzLkZyb250U2lkZSA9IEZyb250U2lkZTtcblx0ZXhwb3J0cy5CYWNrU2lkZSA9IEJhY2tTaWRlO1xuXHRleHBvcnRzLkRvdWJsZVNpZGUgPSBEb3VibGVTaWRlO1xuXHRleHBvcnRzLkZsYXRTaGFkaW5nID0gRmxhdFNoYWRpbmc7XG5cdGV4cG9ydHMuU21vb3RoU2hhZGluZyA9IFNtb290aFNoYWRpbmc7XG5cdGV4cG9ydHMuTm9Db2xvcnMgPSBOb0NvbG9ycztcblx0ZXhwb3J0cy5GYWNlQ29sb3JzID0gRmFjZUNvbG9ycztcblx0ZXhwb3J0cy5WZXJ0ZXhDb2xvcnMgPSBWZXJ0ZXhDb2xvcnM7XG5cdGV4cG9ydHMuTm9CbGVuZGluZyA9IE5vQmxlbmRpbmc7XG5cdGV4cG9ydHMuTm9ybWFsQmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcblx0ZXhwb3J0cy5BZGRpdGl2ZUJsZW5kaW5nID0gQWRkaXRpdmVCbGVuZGluZztcblx0ZXhwb3J0cy5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gU3VidHJhY3RpdmVCbGVuZGluZztcblx0ZXhwb3J0cy5NdWx0aXBseUJsZW5kaW5nID0gTXVsdGlwbHlCbGVuZGluZztcblx0ZXhwb3J0cy5DdXN0b21CbGVuZGluZyA9IEN1c3RvbUJsZW5kaW5nO1xuXHRleHBvcnRzLkFkZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG5cdGV4cG9ydHMuU3VidHJhY3RFcXVhdGlvbiA9IFN1YnRyYWN0RXF1YXRpb247XG5cdGV4cG9ydHMuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbjtcblx0ZXhwb3J0cy5NaW5FcXVhdGlvbiA9IE1pbkVxdWF0aW9uO1xuXHRleHBvcnRzLk1heEVxdWF0aW9uID0gTWF4RXF1YXRpb247XG5cdGV4cG9ydHMuWmVyb0ZhY3RvciA9IFplcm9GYWN0b3I7XG5cdGV4cG9ydHMuT25lRmFjdG9yID0gT25lRmFjdG9yO1xuXHRleHBvcnRzLlNyY0NvbG9yRmFjdG9yID0gU3JjQ29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuT25lTWludXNTcmNDb2xvckZhY3RvciA9IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuU3JjQWxwaGFGYWN0b3IgPSBTcmNBbHBoYUZhY3Rvcjtcblx0ZXhwb3J0cy5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gT25lTWludXNTcmNBbHBoYUZhY3Rvcjtcblx0ZXhwb3J0cy5Ec3RBbHBoYUZhY3RvciA9IERzdEFscGhhRmFjdG9yO1xuXHRleHBvcnRzLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSBPbmVNaW51c0RzdEFscGhhRmFjdG9yO1xuXHRleHBvcnRzLkRzdENvbG9yRmFjdG9yID0gRHN0Q29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuT25lTWludXNEc3RDb2xvckZhY3RvciA9IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3I7XG5cdGV4cG9ydHMuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IFNyY0FscGhhU2F0dXJhdGVGYWN0b3I7XG5cdGV4cG9ydHMuTmV2ZXJEZXB0aCA9IE5ldmVyRGVwdGg7XG5cdGV4cG9ydHMuQWx3YXlzRGVwdGggPSBBbHdheXNEZXB0aDtcblx0ZXhwb3J0cy5MZXNzRGVwdGggPSBMZXNzRGVwdGg7XG5cdGV4cG9ydHMuTGVzc0VxdWFsRGVwdGggPSBMZXNzRXF1YWxEZXB0aDtcblx0ZXhwb3J0cy5FcXVhbERlcHRoID0gRXF1YWxEZXB0aDtcblx0ZXhwb3J0cy5HcmVhdGVyRXF1YWxEZXB0aCA9IEdyZWF0ZXJFcXVhbERlcHRoO1xuXHRleHBvcnRzLkdyZWF0ZXJEZXB0aCA9IEdyZWF0ZXJEZXB0aDtcblx0ZXhwb3J0cy5Ob3RFcXVhbERlcHRoID0gTm90RXF1YWxEZXB0aDtcblx0ZXhwb3J0cy5NdWx0aXBseU9wZXJhdGlvbiA9IE11bHRpcGx5T3BlcmF0aW9uO1xuXHRleHBvcnRzLk1peE9wZXJhdGlvbiA9IE1peE9wZXJhdGlvbjtcblx0ZXhwb3J0cy5BZGRPcGVyYXRpb24gPSBBZGRPcGVyYXRpb247XG5cdGV4cG9ydHMuTm9Ub25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG5cdGV4cG9ydHMuTGluZWFyVG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZztcblx0ZXhwb3J0cy5SZWluaGFyZFRvbmVNYXBwaW5nID0gUmVpbmhhcmRUb25lTWFwcGluZztcblx0ZXhwb3J0cy5VbmNoYXJ0ZWQyVG9uZU1hcHBpbmcgPSBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmc7XG5cdGV4cG9ydHMuQ2luZW9uVG9uZU1hcHBpbmcgPSBDaW5lb25Ub25lTWFwcGluZztcblx0ZXhwb3J0cy5VVk1hcHBpbmcgPSBVVk1hcHBpbmc7XG5cdGV4cG9ydHMuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc7XG5cdGV4cG9ydHMuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZztcblx0ZXhwb3J0cy5DdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nO1xuXHRleHBvcnRzLkN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc7XG5cdGV4cG9ydHMuUmVwZWF0V3JhcHBpbmcgPSBSZXBlYXRXcmFwcGluZztcblx0ZXhwb3J0cy5DbGFtcFRvRWRnZVdyYXBwaW5nID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0ZXhwb3J0cy5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gTWlycm9yZWRSZXBlYXRXcmFwcGluZztcblx0ZXhwb3J0cy5OZWFyZXN0RmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcblx0ZXhwb3J0cy5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyO1xuXHRleHBvcnRzLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyO1xuXHRleHBvcnRzLkxpbmVhckZpbHRlciA9IExpbmVhckZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjtcblx0ZXhwb3J0cy5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cdGV4cG9ydHMuVW5zaWduZWRCeXRlVHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGU7XG5cdGV4cG9ydHMuQnl0ZVR5cGUgPSBCeXRlVHlwZTtcblx0ZXhwb3J0cy5TaG9ydFR5cGUgPSBTaG9ydFR5cGU7XG5cdGV4cG9ydHMuVW5zaWduZWRTaG9ydFR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcblx0ZXhwb3J0cy5JbnRUeXBlID0gSW50VHlwZTtcblx0ZXhwb3J0cy5VbnNpZ25lZEludFR5cGUgPSBVbnNpZ25lZEludFR5cGU7XG5cdGV4cG9ydHMuRmxvYXRUeXBlID0gRmxvYXRUeXBlO1xuXHRleHBvcnRzLkhhbGZGbG9hdFR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZTtcblx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSBVbnNpZ25lZFNob3J0NTU1MVR5cGU7XG5cdGV4cG9ydHMuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSBVbnNpZ25lZFNob3J0NTY1VHlwZTtcblx0ZXhwb3J0cy5VbnNpZ25lZEludDI0OFR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XG5cdGV4cG9ydHMuQWxwaGFGb3JtYXQgPSBBbHBoYUZvcm1hdDtcblx0ZXhwb3J0cy5SR0JGb3JtYXQgPSBSR0JGb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQUZvcm1hdCA9IFJHQkFGb3JtYXQ7XG5cdGV4cG9ydHMuTHVtaW5hbmNlRm9ybWF0ID0gTHVtaW5hbmNlRm9ybWF0O1xuXHRleHBvcnRzLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gTHVtaW5hbmNlQWxwaGFGb3JtYXQ7XG5cdGV4cG9ydHMuUkdCRUZvcm1hdCA9IFJHQkVGb3JtYXQ7XG5cdGV4cG9ydHMuRGVwdGhGb3JtYXQgPSBEZXB0aEZvcm1hdDtcblx0ZXhwb3J0cy5EZXB0aFN0ZW5jaWxGb3JtYXQgPSBEZXB0aFN0ZW5jaWxGb3JtYXQ7XG5cdGV4cG9ydHMuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JfUzNUQ19EWFQxX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JfRVRDMV9Gb3JtYXQgPSBSR0JfRVRDMV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzR4NF9Gb3JtYXQgPSBSR0JBX0FTVENfNHg0X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfNXg0X0Zvcm1hdCA9IFJHQkFfQVNUQ181eDRfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ181eDVfRm9ybWF0ID0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgPSBSR0JBX0FTVENfNng1X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfNng2X0Zvcm1hdCA9IFJHQkFfQVNUQ182eDZfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ184eDVfRm9ybWF0ID0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgPSBSR0JBX0FTVENfOHg2X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfOHg4X0Zvcm1hdCA9IFJHQkFfQVNUQ184eDhfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ18xMHg1X0Zvcm1hdCA9IFJHQkFfQVNUQ18xMHg1X0Zvcm1hdDtcblx0ZXhwb3J0cy5SR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQ7XG5cdGV4cG9ydHMuUkdCQV9BU1RDXzEweDhfRm9ybWF0ID0gUkdCQV9BU1RDXzEweDhfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgPSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgPSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0O1xuXHRleHBvcnRzLlJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgPSBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0O1xuXHRleHBvcnRzLkxvb3BPbmNlID0gTG9vcE9uY2U7XG5cdGV4cG9ydHMuTG9vcFJlcGVhdCA9IExvb3BSZXBlYXQ7XG5cdGV4cG9ydHMuTG9vcFBpbmdQb25nID0gTG9vcFBpbmdQb25nO1xuXHRleHBvcnRzLkludGVycG9sYXRlRGlzY3JldGUgPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuXHRleHBvcnRzLkludGVycG9sYXRlTGluZWFyID0gSW50ZXJwb2xhdGVMaW5lYXI7XG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVTbW9vdGggPSBJbnRlcnBvbGF0ZVNtb290aDtcblx0ZXhwb3J0cy5aZXJvQ3VydmF0dXJlRW5kaW5nID0gWmVyb0N1cnZhdHVyZUVuZGluZztcblx0ZXhwb3J0cy5aZXJvU2xvcGVFbmRpbmcgPSBaZXJvU2xvcGVFbmRpbmc7XG5cdGV4cG9ydHMuV3JhcEFyb3VuZEVuZGluZyA9IFdyYXBBcm91bmRFbmRpbmc7XG5cdGV4cG9ydHMuVHJpYW5nbGVzRHJhd01vZGUgPSBUcmlhbmdsZXNEcmF3TW9kZTtcblx0ZXhwb3J0cy5UcmlhbmdsZVN0cmlwRHJhd01vZGUgPSBUcmlhbmdsZVN0cmlwRHJhd01vZGU7XG5cdGV4cG9ydHMuVHJpYW5nbGVGYW5EcmF3TW9kZSA9IFRyaWFuZ2xlRmFuRHJhd01vZGU7XG5cdGV4cG9ydHMuTGluZWFyRW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcblx0ZXhwb3J0cy5zUkdCRW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdGV4cG9ydHMuR2FtbWFFbmNvZGluZyA9IEdhbW1hRW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCRUVuY29kaW5nID0gUkdCRUVuY29kaW5nO1xuXHRleHBvcnRzLkxvZ0x1dkVuY29kaW5nID0gTG9nTHV2RW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCTTdFbmNvZGluZyA9IFJHQk03RW5jb2Rpbmc7XG5cdGV4cG9ydHMuUkdCTTE2RW5jb2RpbmcgPSBSR0JNMTZFbmNvZGluZztcblx0ZXhwb3J0cy5SR0JERW5jb2RpbmcgPSBSR0JERW5jb2Rpbmc7XG5cdGV4cG9ydHMuQmFzaWNEZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcblx0ZXhwb3J0cy5SR0JBRGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZztcblx0ZXhwb3J0cy5DdWJlR2VvbWV0cnkgPSBCb3hHZW9tZXRyeTtcblx0ZXhwb3J0cy5GYWNlNCA9IEZhY2U0O1xuXHRleHBvcnRzLkxpbmVTdHJpcCA9IExpbmVTdHJpcDtcblx0ZXhwb3J0cy5MaW5lUGllY2VzID0gTGluZVBpZWNlcztcblx0ZXhwb3J0cy5NZXNoRmFjZU1hdGVyaWFsID0gTWVzaEZhY2VNYXRlcmlhbDtcblx0ZXhwb3J0cy5NdWx0aU1hdGVyaWFsID0gTXVsdGlNYXRlcmlhbDtcblx0ZXhwb3J0cy5Qb2ludENsb3VkID0gUG9pbnRDbG91ZDtcblx0ZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xuXHRleHBvcnRzLlBhcnRpY2xlU3lzdGVtID0gUGFydGljbGVTeXN0ZW07XG5cdGV4cG9ydHMuUG9pbnRDbG91ZE1hdGVyaWFsID0gUG9pbnRDbG91ZE1hdGVyaWFsO1xuXHRleHBvcnRzLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IFBhcnRpY2xlQmFzaWNNYXRlcmlhbDtcblx0ZXhwb3J0cy5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsID0gUGFydGljbGVTeXN0ZW1NYXRlcmlhbDtcblx0ZXhwb3J0cy5WZXJ0ZXggPSBWZXJ0ZXg7XG5cdGV4cG9ydHMuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IER5bmFtaWNCdWZmZXJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50OEF0dHJpYnV0ZSA9IEludDhBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuVWludDhBdHRyaWJ1dGUgPSBVaW50OEF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50MTZBdHRyaWJ1dGUgPSBJbnQxNkF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50MTZBdHRyaWJ1dGUgPSBVaW50MTZBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuSW50MzJBdHRyaWJ1dGUgPSBJbnQzMkF0dHJpYnV0ZTtcblx0ZXhwb3J0cy5VaW50MzJBdHRyaWJ1dGUgPSBVaW50MzJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuRmxvYXQzMkF0dHJpYnV0ZSA9IEZsb2F0MzJBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuRmxvYXQ2NEF0dHJpYnV0ZSA9IEZsb2F0NjRBdHRyaWJ1dGU7XG5cdGV4cG9ydHMuQ2xvc2VkU3BsaW5lQ3VydmUzID0gQ2xvc2VkU3BsaW5lQ3VydmUzO1xuXHRleHBvcnRzLlNwbGluZUN1cnZlMyA9IFNwbGluZUN1cnZlMztcblx0ZXhwb3J0cy5TcGxpbmUgPSBTcGxpbmU7XG5cdGV4cG9ydHMuQXhpc0hlbHBlciA9IEF4aXNIZWxwZXI7XG5cdGV4cG9ydHMuQm91bmRpbmdCb3hIZWxwZXIgPSBCb3VuZGluZ0JveEhlbHBlcjtcblx0ZXhwb3J0cy5FZGdlc0hlbHBlciA9IEVkZ2VzSGVscGVyO1xuXHRleHBvcnRzLldpcmVmcmFtZUhlbHBlciA9IFdpcmVmcmFtZUhlbHBlcjtcblx0ZXhwb3J0cy5YSFJMb2FkZXIgPSBYSFJMb2FkZXI7XG5cdGV4cG9ydHMuQmluYXJ5VGV4dHVyZUxvYWRlciA9IEJpbmFyeVRleHR1cmVMb2FkZXI7XG5cdGV4cG9ydHMuR2VvbWV0cnlVdGlscyA9IEdlb21ldHJ5VXRpbHM7XG5cdGV4cG9ydHMuSW1hZ2VVdGlscyA9IEltYWdlVXRpbHM7XG5cdGV4cG9ydHMuUHJvamVjdG9yID0gUHJvamVjdG9yO1xuXHRleHBvcnRzLkNhbnZhc1JlbmRlcmVyID0gQ2FudmFzUmVuZGVyZXI7XG5cdGV4cG9ydHMuU2NlbmVVdGlscyA9IFNjZW5lVXRpbHM7XG5cdGV4cG9ydHMuTGVuc0ZsYXJlID0gTGVuc0ZsYXJlO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXX0=
