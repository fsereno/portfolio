<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Portfolio</title>
    <meta charset="utf-8">
    <meta name="description" content="Portfolio website for Fabio Sereno - Software Developer.">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui, user-scalable=no">
    <meta name="author" content="Fabio Sereno">
    <meta property="og:image" content="../images/PortfolioThumbnail.png">
    <link rel="icon" href="../favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="../css/vendor.css">
    <link rel="stylesheet" href="css/styles.css">
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="navBar"><a class="navbar-brand" href="../index.html"><img class="pull-left" id="navbarImage" src="../images/FSLogo.png" alt="Fabio Sereno logo image">
        <h2 class="display-4 m-0 p-0 d-flex" id="titleHeading">Fabio Sereno</h2>
        <p class="lead m-0 p-0 sub-heading d-flex text-white" id="titleSubHeading">Software developer</p></a>
      <button class="navbar-toggler" id="navbarNavDropdownBtn" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon">
          <hr>
          <hr>
          <hr></span></button>
      <div class="collapse navbar-collapse flex-row-reverse" id="navbarNavDropdown">
        <ul class="navbar-nav">
          <li class="nav-item"><a class="nav-link" href="../index.html">Home<i class="fa fa-home ml-2"></i></a></li>
          <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" id="navbarDropdownMenuLink" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Applications</a>
            <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdownMenuLink"><a class=" dropdown-item" href="../app_babelTs/index.html">To-Do List (Basic)</a><a class=" dropdown-item" href="../app_toDoReact/index.html">To-Do List (React)</a><a class=" dropdown-item" href="../app_reactRedux/index.html">To-Do List (React Redux)</a><a class=" dropdown-item" href="../app_toDoVue/index.html">To-Do List (Vue)</a><a class=" dropdown-item" href="../app_ticTacToeReact/index.html">Tic-Tac-Toe (React)</a><a class=" dropdown-item" href="../app_findReplace/index.html">TypeScript Find and Replace</a><a class=" dropdown-item" href="../app_AzureDotNetCoreUniqueDataEntryApi/index.html">Azure Functions .NET Core Unique Data Entry Api</a><a class=" dropdown-item" href="../app_AzureDotNetCoreDataStructuresApi/index.html">Azure Functions .NET Core Data Structures Api</a><a class=" dropdown-item" href="../app_awsDotNetCoreEntitySortApi/index.html">AWS .NET Core Entity Sorting API</a><a class=" dropdown-item" href="../app_awsDotNetCoreStringSortApi/index.html">AWS .NET Core Natural Sort API</a><a class=" dropdown-item" href="../app_awsDotNetCoreShoppingCart/index.html">AWS .NET Core Shopping Cart API</a><a class=" dropdown-item" href="../app_awsDotNetCoreAsyncCoffeeMachine/index.html">AWS .NET Core Asynchronous Coffee Maker API</a><a class=" dropdown-item" href="../app_threeJSScene/index.html">Three JS Scene (Basic)</a><a class=" dropdown-item" href="../app_aframe/index.html">AFrame React (Basic)</a><a class=" dropdown-item" href="../app_aframeComplex/index.html">AFrame React (Complex)</a><a class=" dropdown-item" href="../app_percentageCalculator/index.html">TypeScript Percentage Calculator</a><a class=" dropdown-item" href="../app_unscrabbler/index.html">TypeScript Un-Scrabbler Word Game</a><a class=" dropdown-item" href="../app_randomGenerator/index.html">TypeScript Random String Generator</a><a class=" dropdown-item" href="../app_dictionaryFinder/index.html">TypeScript Dictionary Word Finder</a><a class=" dropdown-item" href="../app_koTypeScript/index.html">Knockout + TypeScript</a>
              <div class="dropdown-divider"></div><a class=" dropdown-item" href="../index.html">Home<i class="fa fa-home ml-2"></i></a>
            </div>
          </li>
          <li class="nav-item"><a class="nav-link" href="https://github.com/fsereno/portfolio/tree/master/app/app_jsCodingStandards" target="_blank">View on Github<i class="fa fa-github ml-2"></i></a></li>
          <li class="nav-item"><a class="nav-link" href="https://www.linkedin.com/in/fabio-sereno-6a97b986/" target="_blank">Linkedin<i class="fa fa-linkedin ml-2"></i></a></li>
        </ul>
      </div>
    </nav>
    <div class="container-fluid pt-4 mt-5" id="mainContainer">
      <div class="row">
        <div class="col-lg-12">
          <h2 class="display-4" id="pageHeading">JS Coding Standards</h2>
        </div>
      </div>
      <div class="row">
        <div class="col-lg-12">
          <p id="pageSubHeading">A JavaScript Code Style Guide</p>
          <p class="text-muted" id="pageDescription">By Fabio Sereno</p>
          <hr>
        </div>
      </div>
      <h2>Objective </h2>
      <p>The purpose of these standards is to promote maintainable, readable and scalable JavaScript code.</p>
      <p>
        Whilst these standards will adhere to the behaviours, limitations and conventions of JavaScript, some of the core
        principles mentioned are proven software design principles, which may be applied across the board, such as the
        SOLID, YAGNI, KISS and DRY principles.
      </p>
      <p>
        In order to understand the reasoning for some of these standards, it is important to first understand the dynamic
        nature of JavaScript and some key characteristics, along with the available tools that are native to the
        language. With this in mind, this document will attempt to offer clear explanations to justify suggestions.
      </p>
      <p>
        This document will also include examples using the latest ES6 JavaScript standards. Apply these with caution.
        Ensure browser compatibility and use a transpiler such as <a href="https://babeljs.io/">Babel</a> if you wish to
            use ES6 syntax.
      </p>
      <p>There is a full repository of all code examples used in this document: <a href="https://github.com/fsereno/portfolio//tree/master/app/app_jsCodingStandards/accompanying_code/" target="_blank">Accompanying Code Snippets</a></p>
      <h2>1. Being <em>Strict </em>in JavaScript</h2>
      <p>
        All JavaScript should be written in strict mode. This will highlight possible issues with the script either
        during compilation, with a tool such a Babel, or in the developer console in the browser.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">name = "Adam";
console.log(`Hello ${name}`);  </pre>
      <p>
        This will not error, but there is a problem with this code. The name variable is global and it has no protection.
        Declarations such as this should not happen for a number of reasons, mainly around scoping and shadowing,
        explained later in more detail.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">"use strict";

name = "Adam";
console.log(`Hello ${name}`);  </pre>
      <p>
        Now in strict mode, this will error and so it should! Strict mode has highlighted for us that this is bad code
        and we should correct it. We should see strict mode as a useful tool when writing quality JavaScript and we
        should always use it.
      </p>
      <h2>2. Naming</h2>
      <p>Naming can be split into the following categories:</p>
      <ul>
        <li>
          <p>General naming conventions</p>
        </li>
        <li>
          <p>Variable names</p>
        </li>
        <li>
          <p>Constant names</p>
        </li>
        <li>
          <p>Function names</p>
        </li>
      </ul>
      <h3>2.1 General naming conventions</h3>
      <p><strong>Function</strong> and <strong>variable</strong> naming should be in <strong>camelCase</strong>.</p>
      <p><strong>Class</strong> and <strong>constructor functions</strong> should be in <strong>PascalCase</strong>.</p>
      <p><strong>Constants</strong> should be identified by using <strong>CAPITAL_CASE</strong>.</p>
      <h3>2.2 Variable names</h3>
      <p>
        Variable names should be meaningful, searchable and pronounceable. Variable names should reveal intention of use
        and avoid disinformation.
      </p>
      <p>
        Think about why the variable name exists, we should be able to tell what the variable holds in memory just by
        reading it.
      </p>
      <p>
        Comments should not be required in order to explain a variable name. The name itself should be meaningful and
        sufficient that comments are not required.
      </p>
      <p>
        We should not use mental mapping of variable names with the use of abbreviations such as &ldquo;i&rdquo;, or &ldquo;a&rdquo; or &ldquo;dd&rdquo; or
        &ldquo;crn&rdquo; etc:
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">var i = 0;  </pre>
      <p>
        What is &ldquo;i&rdquo; in this context ? This is disinformation. In this case a more meaningful variable name would be
        preferred: &ldquo;index&rdquo;, &ldquo;counter&rdquo; or &ldquo;position&rdquo;.
      </p>
      <p>Depending on the scope, Variable names should also not be unnecessarily too descriptive, such as: <em><span class="inline-comment-marker" data-ref="cbb12e7d-57f8-4548-90cb-b14870099791">indexOfTheItemIamIteratingThroughInMyCollection</span></em>    - In a local scope this can also be seen as disinformation by being overly descriptive. We are aware of the
            context in a local scope, so a shorter variable name would be preferred.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">var index = 0;  </pre>
      <p>The problem of abbreviation becomes more relevant in the case of nested <em>for </em>loops when working with
            multidimensional arrays:
      </p>
      <h4> Problem</h4>
      <pre class="card p-4">var categories = [[0,1],[2,3]];

for(var i = 0; i < categories.length; i++) {
    for(var j = 0; j < categories[i].length; j++) {
        console.log(categories[i][j]);
    }
}  </pre>
      <p>When there are nested <em>for </em>loops, there will be multiple index variables. Abbreviating them could cause
            ambiguity around what &ldquo;i&rdquo; or &ldquo;j&rdquo; are, you also cannot use &ldquo;i&rdquo; twice in the same block scope, as it already
            exists.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">var categories = [[0,1],[2,3]];

for(let category = 0; category < categories.length; category++) {
    for(let item = 0; item < categories[category].length; item++) {
        console.log(categories[category][item]);
    }
}  </pre>
      <p>Here using, short but descriptive variable names allows us to clearly read what we are iterating over.</p>
      <p><strong>However</strong>, <span class="inline-comment-marker" data-ref="89243c9d-0fd2-46d2-8e93-bfd80286a9ab">
          using
          &ldquo;i&rdquo; for the index variable in the context of a single
          level</span><em><span class="inline-comment-marker" data-ref="89243c9d-0fd2-46d2-8e93-bfd80286a9ab">for</span></em><span class="inline-comment-marker" data-ref="89243c9d-0fd2-46d2-8e93-bfd80286a9ab">
          loop is a
          common approach and is acceptable :</span></p>
      <pre class="card p-4">const items = [0, 1, 2, 3];

for(let i = 0; i < items.length; i++) {
    console.log(items[i]);   
}  </pre>
      <p>Variable names <strong>can </strong>however be longer, but their length should be <strong>relative </strong>to
            the scope they are in.
      </p>
      <p>
        A variable name in the outer scope (not necessarily global), might require some additional context or even a
        namespace for it to be meaningful enough, making it longer in length. This is the preferred approach, instead of
        the need to add comments in order to explain what a variable is doing, the name itself should be enough.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">//Outer scope
let entry = "index.js";
let root = "http://www.application.co.uk/";  

let getEntryUrl = function() {
  //Inner scope
  return `${root}${entry}`
}

console.log(getEntryUrl())  </pre>
      <p>
        The problem with these variable names is that they do not reflect the scope they are in, they have no context.
        Both<em> entry </em>or <em>root</em> are being declared in a much wider scope than where they are being used.
            They are being used at the block level, so for us to know where they have come from and what they are being used
            for, we should consider a more descriptive naming convention for them.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">//Outer scope
let globalApplicationConfigurationSettings = {
    entry: "index.js",
    root: "http://www.application.co.uk/"  
}

let getEntryUrl = function() {
  //Inner scope
  return `${globalApplicationConfigurationSettings.root}${globalApplicationConfigurationSettings.entry}`
}

console.log(getEntryUrl())  </pre>
      <p>
        Now our intention is clear with a much more descriptive naming convention. We are still declaring in the outer
        scope, but they are being encapsulated by an object literal, which means in order to access these properties we
        need to go via the objects namespace. This now gives <em>root </em>and <em>entry </em>a clear context and we
            know exactly where they are coming from and what they are going to be used for.
      </p>
      <p>We should be writing boolean variables as <strong>predicates</strong>, such as &ldquo;is&rdquo; or &ldquo;has&rdquo;. This would help
            denote state. For example, either something &ldquo;is&rdquo; or something &ldquo;is not&rdquo;.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let empty = true;
if(empty) {
  console.log("It is empty");
}  </pre>
      <p>
        We do not know initially from looking at this variable that it returns a boolean, we can only assume it is. For
        all we know, <em>empty </em>could contain an empty string, not a state. This variable also has no context, what
            is empty ? It is ambiguous.
      </p>
      <h4>Solution </h4>
      <pre class="card p-4">let input = {
  isEmpty: true
}
if(input.isEmpty) {
  console.log("It is empty");
}  </pre>
      <p>
        This variable now refers to something that &ldquo;is&rdquo; empty. We have also used an object literal to contain all of the
        properties sharing the same context. This also allows for a nice and clear <em>if</em> statement.
      </p>
      <h3>2.2.1 Avoiding Magic Numbers and Strings</h3>
      <p>We should avoid <strong>Magic Numbers and Strings </strong>where possible. We should always declare arbitrary numbers and strings as
            variables with a clear, meaningful name as per our naming conventions.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">var password = "Password1";
if (password.length > 8 && password.length < 31) {
  console.log("Password is valid");
}  </pre>
      <p>
        Initially from the above code we do not know the meaning of 8 or 31 without reading through the code first. We
        should know what they are being used for without need to read through the code.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">var password = "Password1";
const MIN_PASSWORD_LENGTH = 8;
const MAX_PASSWORD_LENGTH = 31;
if (password.length > MIN_PASSWORD_LENGTH && password.length < MAX_PASSWORD_LENGTH) {
  console.log("Password is valid");
}  </pre>
      <p>
        Now we have assigned these values as constants with meaningful names. We now know exactly what they are being
        used for. We can also change them without needing to amend the existing logic directly.
      </p>
      <h3>2.3 Constant Names</h3>
      <p>
        Constants should be identified as being &ldquo;constant&rdquo;, something that cannot be changed. We can visually do this
        with the use of <strong>CAPITAL_CASE</strong>. In JavaScript if you see a declaration using <strong>CAPITAL_CASE</strong>, it means the value should not be changed.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">var thresholdOfUsers = 10;
var thresholdOfUsers = 30;
thresholdOfUsers = 50;  </pre>
      <p>
        Visually there is nothing denoting the above variable should be treated as a constant. This is a problem when
        trying to ensure your code is to be used as intended by other developers.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">var THRESHOLD_OF_USERS = 10;

// or, even better:

const THRESHOLD_OF_USERS = 10;  </pre>
      <p>By using <strong>CAPITAL_CASE</strong> it helps identify the difference between a constant, which should not be
            changed and a variable declared using <strong>camelCase</strong> which may be changed. We can offer additional
            protection by using the <em><strong>const </strong></em>keyword. This is covered in section 5. Declarations in
            more detail.
      </p>
      <h3>2.4 Function names</h3>
      <p>
        With the same approach, function names should also be meaningful, searchable and pronounceable. Make them a verb,
        what is the function actually doing ? what is it returning ? is it an integer, a boolean, a string ?
      </p>
      <p>
        JavaScript by nature is a dynamic language, it is not strongly typed, which means it is very easy to return an
        unexpected data type, either intentionally or unintentionally. Making variable and function names descriptive is
        very important when making code readable and understandable, as this cannot always be denoted from a methods
        signature in JavaScript, unlike some statically types languages such as C#, Java etc.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">function error(input) {
  return input === 0;
};  </pre>
      <p>
        The problem here is the method name does not suggest it is doing anything, or that it is returning anything, when
        it is in fact evaluating an input and returning <em><strong>true</strong></em> or<em><strong> false</strong></em>.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">function validateInput(input) {
  return input === 0;
};  </pre>
      <p>
        Breaking this method name into parts. The &ldquo;validate&rdquo; is a verb and implies what this method is doing -
        validating. The &ldquo;Input&rdquo; is describing what we are actually acting on, or evaluating.
      </p>
      <p>
        Functions or members that exist inside a specific scope or class should not add unnecessary context to their
        names:
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">var user = function() {
    this.getUser = function() { 

    };
    this.deleteUser = function() { 

    };
}  </pre>
      <p><span class="inline-comment-marker" data-ref="82a5572d-fb9f-4397-97be-bdbe52578961">
          The additional context of
          &ldquo;user&rdquo; is not needed here:</span></p>
      <h4>Solution</h4>
      <pre class="card p-4">var user = function () {
    this.get = function () {

    };
    this.delete = function () {

    };
}  </pre>
      <h2>3. Constructor Functions, Object Literals and Classes</h2>
      <p>We should be using either <strong>Constructor functions, object literals</strong> or the <strong>class </strong>construct where possible for declaring patterns of variables that could be identified as objects. This
            is typically good in the sense of a more traditional object oriented approach to programming. This can really
            help with code reuse, reducing repetition and also improve reliability and readability.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let name = "James"
let age = 23;
console.log(`${name} ${age}`)

name = "Anna"
age = 30;
console.log(`${name} ${age}`)

name = "Tim"
age = 18;
console.log(`${name} ${age}`)  </pre>
      <p>
        With the example above the same two variables are being declared and reassigned with every instance before being
        used, in this case to simply log out to the console, but this could well be call updating a database, for
        example. There is a clear repetition of code here and a clear pattern. We should avoid such repetition as this.
        If we see this occurring in our code, we should refactor our code.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let persons = [];

persons.push({
  name: "James",
  age: 23
});

persons.push({
  name: "Anna",
  age: 30
});

persons.push({
  name: "Tim",
  age: 18
});

persons.forEach((person) => console.log(`${person.name} ${person.age}`));  </pre>
      <p>We could instead declare each instance of the repetition as an <strong>object literal</strong> representing each
            person and push them into a collection. Each person is now encapsulated by an object. We could have also
            declared each <strong>object literal</strong> directly into the array, either way would have helped create a
            more definitive pattern.
      </p>
      <p>We could also refactor this further to alternatively use either a <strong>constructor function</strong> or a<strong> class</strong>.</p>
      <h4>Solution</h4>
      <pre class="card p-4">let persons = [];

let Person = function(name, age) {
  this.name = name;
  this.age = age;
}

persons.push(new Person("James", 23));
persons.push(new Person("Anna", 30));
persons.push(new Person("Tim", 18));

persons.forEach((person) => console.log(`${person.name} ${person.age}`));  </pre>
      <p>Now we have even more reduced code repetition and we do not need to manually type the <strong>object literal </strong>every time, but this solution would be more performance intensive on a larger scale because we are
            creating an object by calling a function for every instance.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let persons = [];

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

persons.push(new Person("James", 23));
persons.push(new Person("Anna", 30));
persons.push(new Person("Tim", 18));

persons.forEach((person) => console.log(`${person.name} ${person.age}`));  </pre>
      <p>Now using a <strong>class</strong> this reads more like a traditional object oriented approach, but is
            effectively the same as the <strong>constructor function</strong> example.
      </p>
      <p><strong>Constructor functions</strong>, <strong>object literals</strong> and <strong>classes </strong>help<strong> </strong>save space, eliminate variable repetition and also have great benefits when it
            comes to inheritance and <strong>The SOLID Principles</strong>, covered later in this document.
      </p>
      <h2>4. Formatting, braces and spaces</h2>
      <p>
        The preferred pattern in JavaScript is to have the opening brace inline with the declaration, preceded with a
        space and the closing brace on the following line, unlike some languages such as C#.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">function myFunction() 
{

}

function myFunction() {  }  </pre>
      <h4>Solution</h4>
      <pre class="card p-4">function myFunction() {

}  </pre>
      <p>This applies to all usages of braces, whether that be JSON, object literals, <em>if</em> statements, function
            declarations, etc.
      </p>
      <p>
        All control structures should use braces even though they are not necessary. This makes the intended execution
        clear:
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">if (valid === true)
  doThis();  </pre>
      <p>
        An indentation is all that stands between semantic code and non-semantic code, which would not run as intended
        and also cause an error if the indentation was incorrect.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">if (valid === true) {
    doSomething();
}  </pre>
      <p>
        This is considered safer and clearer to read. Not only do we have the indentation identifying the code to be
        executed, we also have the braces offering safety and encapsulation.
      </p>
      <h2>5. Declarations</h2>
      <p>Variable declarations in JavaScript as of this writing can be made using three different keywords,<em><strong>var</strong></em>, <em><strong>let</strong></em> and <em><strong>const</strong></em>.</p>
      <p>Each have different behaviours and we should use them as required. It is not a case of simply using<em><strong> let</strong></em> instead of <em><strong>var</strong></em>. There is good reason to use<em><strong> let</strong></em> instead of <em><strong>var</strong></em> as long as the scoping behaviour meets
            your needs.
      </p>
      <p><em><strong>let</strong></em> and <em><strong>const</strong></em> protect against re-declaration, with<em><strong> let</strong></em> allowing re-assignment and <em><strong>const</strong></em> not allowing
            re-assignment. This makes using <em><strong>let</strong></em> and <em><strong>const</strong></em> safer than
            always using <em><strong>var</strong></em>, which can be re-declared and re-assigned.
      </p>
      <p>*Please note, currently <em><strong>let </strong></em>and <em><strong>const </strong></em>require transpilation
            to work in older browsers such as IE11. This process will also catch any attempts to try and re-declare with<em><strong> let</strong></em> and <em><strong>const </strong></em>and re-assignment of<em><strong> const.</strong></em>
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">var thresholdOfUsers = 10;
var thresholdOfUsers = 30;  </pre>
      <p>Drawing on a previous example. Here <em><strong>var</strong></em> is allowing us to re-declare a variable, there
            is nothing stopping this from happening, meaning context and value could be changed at any point during a
            program. Imagine a scenario where two developers are working on the same application, in the same scope but in
            separate scripts and they both declare variables with identical names in the global scope. This is a problem.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">const THRESHOLD_OF_USERS = 10;  </pre>
      <p>The keyword <em><strong>const</strong></em> protects against re-declaration and re-assignment.</p>
      <p>If the intention is to not re-declare, but to re-assign, we can use <em><strong>let</strong></em>. This means we
            cannot re-declare the same exact variable, but we can change its value.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">var THRESHOLD_OF_USERS = 10;
var numberOfUsers = 11;
var isThresholdMet = false;

var THRESHOLD_OF_USERS = 11; // Within the same global scope, there is nothing stopping this from happening.

if (numberOfUsers > THRESHOLD_OF_USERS) {
  isThresholdMet = true;
  numberOfUsers--;
}  </pre>
      <p>Here the re-declaration of <code>THRESHOLD_OF_USERS</code> means that our<em> if</em> statement will fail to
            catch the scenario.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">const THRESHOLD_OF_USERS = 10;
let numberOfUsers = 11;
let isThresholdMet = false;

if (numberOfUsers > THRESHOLD_OF_USERS) {
  isThresholdMet = true;
  numberOfUsers--;
}  </pre>
      <p><span class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">Here we make use of</span><em><strong><span class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">const</span></strong></em><span class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">
          for a value that will not
          change, and we can re-assign values where we have used</span><em><strong><span class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">let</span></strong></em><span class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">
          . The above code will not
          exceed the threshold and demonstrates a scenario where you may want to intentionally re-assign.</span></p>
      <p>
        We should not be delimiting variable declarations with a comma. This can make code tricky to read and hard to
        debug.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let make = "Ford",
    color = "Blue",
    isHybrid = false;  </pre>
      <p>
        We now cannot debug these declarations per line, it is also easy to miss read these declarations as global
        declarations without the use of <em><strong>var</strong></em>, <em><strong>let </strong></em>or<em><strong>const</strong></em>, when they are in fact, block level declarations in a local scope. This also
            makes it hard to make use of the various different keywords <em><strong>var</strong></em>, <em><strong>let </strong></em>and <em><strong>const</strong></em> as necessary, they do not all behave in the same way.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let make = "Ford";
let color = "Blue";
let isHybrid = false;  </pre>
      <p>
        We could now debug each of these declarations per line if needed, also it is very clear each line is being
        declared with the keyword - <em><strong>let</strong></em>.
      </p>
      <p>When declaring a complex string, we should be using template literals instead of using the<em><strong>+</strong></em> operator to concatenate multiple strings together. This will make for much clearer
            string declarations and are easier to read and code.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let name = "Anna";
let age = 40;
let description = name + " is " + age + " years old.";
console.log(description);  </pre>
      <p>We have to open and close each string and concatenate them together using the <em><strong>+</strong></em>    operator. This is a very manual way to code, especially at length, when considering full sentences for feedback
            in a UI, for example.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let name = "Anna";
let age = 40;
let description = `${name} is ${age} years old.`;
console.log(description);  </pre>
      <p>
        This now reads much clearer and is easier to code. We do not need to open and close each string, we use a single
        template literal and populate it with the declared variables above. We should use template literals where
        possible.
      </p>
      <h2>6. Scoping</h2>
      <p>Understanding scoping in JavaScript is incredibly important. There are two main scopes to consider:</p>
      <ul>
        <li>
          <p>The Global Scope</p>
        </li>
        <li>
          <p>The Local Scope (Block level scope)</p>
        </li>
      </ul>
      <p>In the instance of the web the <strong>Global Scope</strong> is the Window object. So if you are to declare a
            variable at <strong>Global Scope</strong> it will belong to the Window object. We should avoid setting Global
            variables at all costs. The reason for this is because in JavaScript it is very easy to re-declare a variable of
            the same name in the <strong>Global Scope</strong>, changing the context of the variable entirely. You may also
            alter a global declaration from any <strong>Local Scope</strong>. This is known as variable shadowing, we must
            protect our code against this scenario and we can do this by avoiding global declarations.
      </p>
      <p>The <strong>Local Scope</strong> is a more manageable scope and gives us protection against variable shadowing.
            Declarations within a <strong>Local Scope</strong> cannot be altered from outside of that scope, in effect they
            become &ldquo;private&rdquo;.
      </p>
      <p>This is similar to Access Modifiers in C#, but we achieve it in a different way with JavaScript:</p>
      <h4>Problem</h4>
      <pre class="card p-4">function myFunction() {
    console.log("myFunction in Global Scope 1");
}
myFunction();

function myFunction() {
    console.log("myFunction in Global Scope 2");
}
myFunction();  </pre>
      <p>The above code will output &ldquo;<code>myFunction in Global Scope 2</code>&rdquo; twice, because the method is declared
            twice within the same <strong>Global Scope</strong>. This results in &ldquo;shadowing&rdquo;. Imagine if these declarations
            existed in separate scripts, but are loaded onto the same <strong>Global Scope</strong>. They would clash, and
            the last declaration of the method would override the first.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">(function() {
  function myFunction() {
    console.log("Local Scope");
  }
  myFunction();
})();

function myFunction() {
  console.log("Global Scope");
}
myFunction();  </pre>
      <p>
        This would ensure we have two separate declarations of the method myFunction, resulting in both methods being run
        individually. The output in this case is &ldquo;<code>Local Scope</code>&rdquo; &ldquo;<code>Global Scope</code>&rdquo;.
      </p>
      <h2>7. Closures</h2>
      <p>A <em><strong>Closure </strong></em>is the encasing of a function together with references to its outer state,
            created at the point of definition. A closure gives you access to an outer functions scope and state (the
            Lexical environment) from the inner function.
      </p>
      <p><em>
          &ldquo;A closure is the combination of a function and the lexical environment within which that function was
          declared. This environment consists of any local variables that were in-scope at the time the closure was
          created&rdquo;</em><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"><em>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</em></a></p>
      <p>You should use <em><strong>Closures </strong></em>to emulate private variables where necessary. In a scenario
            where you want to protect a state a function will run against, we should use <em><strong>Closures</strong></em>.
      </p>
      <p><em><strong>Closures </strong></em>are also key for managing the global namespace, and again we should consider
            them where possible.
      </p>
      <h4>Problem</h4>
      <tbody>
        <tr>
          <td class="wysiwyg-macro-body">
            <pre class="card p-4">var increment = function(prop) {
    return !isNaN(prop) ? prop + 1 : 0;
}

var increment = function(prop) {
    return !isNaN(prop) ? prop + 2 : 0;
}

// Imagine the above methods are declared in seperate scripts, but in the same global scope.
// The context of the add method has changed. We may not be aware of the new definition.

// Now when we use the method, we are using the latter definition. 
// Not our intention.

increment(0); // This will return 2        </pre>
          </td>
        </tr>
      </tbody>
      <p>This will return 2, as we have been able to change the definition of the method. This highlights the need for<em><strong>Closures </strong></em>and why they are necessary to help us manage the global namespace.</p>
      <h4>Solution</h4>
      <pre class="card p-4">const methodFactory = function() {
    return function(prop) {
        return !isNaN(prop) ? prop + 1 : 0;
    }
}

let increment = methodFactory();

increment(0); // This will return 1  </pre>
      <p>
        This will return 1 as intended. We cannot, in anyway change the definition of the nested &ldquo;private&rdquo; method. We
        also use the <em><strong>const</strong></em> keyword to protect our namespace definition.
      </p>
      <h3>7.1 The Module Pattern</h3>
      <p>A common type of closure is the <em><strong>Module Pattern</strong></em>. This offers encapsulation, a closed
            scope, cohesion and the ability to expose only the methods we wish to via an interface, we do this in the form
            of an object literal. Methods which are not exposed remain private.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">var module = {

    privateMethod: function() {

    },

    publicMethod: function() {

    }

};  </pre>
      <p>
        The above would offer a namespace, but expose all methods. We also could not capture state, as it is not a
        closure.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">const module = (function() {

    const privateMethod = function() {

    }

    const publicMethod = function() {

    }

    return {
        publicMethod: publicMethod
    }

})();  </pre>
      <p>The same code written using the <em><strong>Module Pattern</strong></em>. The anonymous function encapsulates the
            scope of the module and returns an object literal, exposing only the methods we would like to expose.
      </p>
      <h3>7.2 What is an AMD Module ?</h3>
      <p>An <strong>AMD</strong> module extends the standard <em><strong>Module Pattern</strong></em>, and is wrapped
            using the <em><strong>define() </strong></em>function in conjunction with a loader such as<strong> Require.js</strong>, <strong>Browserify</strong><em><strong> </strong></em>or <strong>Webpack</strong>,
            among others,<em><strong> </strong></em>in order to load the module and any dependencies. <a href="https://requirejs.org/docs/whyamd.html">https://requirejs.org/docs/whyamd.html</a>
      </p>
      <h4>Example</h4>
      <pre class="card p-4">//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    const base = 0;

    const myMethod = function(prop) {
        return base + prop;
    }

    return {
        myMethod: myMethod
    };
});  </pre>
      <p>
        We can now load this module via a module loader, meaning we can utilise dependency injection, allowing us to
        manage our dependencies more economically, instead of loading them all at once.
      </p>
      <h2>8. What is <em>this</em> in JavaScript ?</h2>
      <p>In JavaScript when we need to refer to the current context we will use the <em><strong>this</strong></em>keyword. It is common in a number of programming languages to use<em><strong> this </strong></em> for when you would like to refer to a property or method within the current
            context. Not so straightforward in JavaScript however, because the context is always changing depending on where
            and how the code has been executed.
      </p>
      <p>The key thing to remember with <em><strong> this  </strong></em>and JavaScript is that it is <strong>
          relative to
          the current scope</strong>, whether that be <strong>Local Scope</strong> or <strong>Global Scope</strong>.
            Because there are multiple scopes in JavaScript, it is important we understand which<em><strong> this </strong></em> we are referring to.
      </p>
      <p>For example in terms of the web browser environment, using <em><strong> this </strong></em> in the <strong>
          Global
          Scope</strong> will refer to the Window object. But if we are to use <em><strong> this </strong></em> from
            within an event callback method, <em><strong> this </strong></em> will refer to the context of the event and not
            beyond.
      </p>
      <h3>8.1 Arrow functions and Lexical <em>this</em></h3>
      <p><strong>Arrow functions</strong>, Introduced with ES6, allow us to write shorter and cleaner code. But beyond
            their abbreviated syntax, the real power of arrow functions lies in their handling of<em><strong> this </strong></em>.
      </p>
      <p>&ldquo;Before arrow functions, every new function defined its own <code>this</code> value based on how the function was
            called&rdquo; <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>
      </p>
      <p>It is possible to have access to the defining context from within a <strong>Local Scope</strong>, the defining
            context being that which defined the method and not the context of the method itself. This is known as<strong> Lexical</strong><em><strong> this </strong></em>, and can be achieved with the use of <strong>
          arrow
          functions</strong>.
      </p>
      <p>Arrow functions allow access to the defining context, because there is no binding of <em><strong>this </strong></em>in <strong>arrow functions</strong>, unlike regular functions, which bind<em><strong> this </strong></em> to the context that called the function, whether that be Window, Document, Event
            etc.
      </p>
      <p>See the below example taken from the Mozilla JavaScript reference:</p>
      <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p>
      <h4>Problem</h4>
      <pre class="card p-4">function Person() {
    var that = this;
    that.age = 0;

    setInterval(function growUp() {
        // The callback refers to the `that` variable of which
        // the value is the expected object.
        that.age++;
    }, 1000);
}

var person = new Person();  </pre>
      <p>In order to get hold of <em><strong> this </strong></em> in the defining scope from the calling scope, we need to
            first declare <em><strong> this </strong></em> as a local variable within the defining scope. We can later then
            refer to <em><strong> this  </strong></em>as <em><strong>that</strong></em> and be confident we know which<em><strong> this  </strong></em>we are referring to. But this means mapping <em><strong> this  </strong></em>to a
            new variable before the context changes. Imagine if you had many nested scopes, each with their own<em><strong> this </strong></em>.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">function Person() {
    this.age = 0;

    setInterval(() => {
        this.age++; // |this| properly refers to the Person object
    }, 1000);
}

var person = new Person();  </pre>
      <p>Now that we are using an arrow function we are able to use plain old <em><strong> this </strong></em> in order to
            refer to the defining scope. This is because the arrow function has no <em><strong> this </strong></em> bound to
            it.
      </p>
      <p>It is very important to only use arrow functions if you intend the use of <em><strong> this </strong></em> to be
            handled in this way. Using arrow functions may not always result in the intended outcome, it might be that the
            handling of <em><strong> this  </strong></em>in a more traditional method is better for your needs. Use arrow
            functions with caution, they are great but they have their purpose and are not always necessary, despite their
            nice syntax. We should use arrow methods when we require access to the defining scope.
      </p>
      <h2>9. Equality</h2>
      <p>
        Equality is very important due to the dynamic nature of JavaScript. We need to be confident when making
        comparisons that a value is what we expect it to be.
      </p>
      <p>When comparing a value against another using only a <strong>Reference Equality Operator (==/!=)</strong>,
            JavaScript will attempt to match the types of two values.<strong> </strong>But in doing this the value itself
            can change, meaning you are no longer comparing the original values. The values are coerced into something they
            are not.
      </p>
      <p>In other words, 0 is equal to &ldquo;&ldquo; in JavaScript when comparing an integer to a string and only using a<strong>Reference Equality Operator (==/!=) </strong>because the empty string gets converted into a number, that
            number being a 0 by best match according to JavaScript. But a zero is not equal to an empty string!
      </p>
      <p>For this reason, <strong>we should always</strong> be using the <strong>Identity Equality Operator</strong><strong>(===/!==)</strong> when comparing values in JavaScript. When using the <strong>
          Identity Equality
          Operator</strong> there is no type conversion and both values must be of the same type in order to be
            considered &ldquo;equal&rdquo;, so we can be confident they are indeed the same.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">"" == 0; // this equals true.  </pre>
      <p>This returns <em>true, </em>which is a real problem when trying to compare types. Imagine if we were to now
            perform a sum on a variable that is in fact equal to &ldquo;&rdquo; because we assume it to be a number after the above
            equation returns true ? We would get a NaN error!
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">"" === 0; // this equals false, and so it should!  </pre>
      <p>Now using the <strong>Identity Equality Operator</strong> we are able to not only be confident that these values
            do not match, but also their types are not the same either, so this will now return false. An equation such as 0
            === 0 would return true, this is what we are checking for.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">"" != 0; // this would return false, meaning these are equal when they are not.  </pre>
      <p>We can clearly see these values are not equal but the <strong>Reference Equality Operator</strong> is distorting
            our perception of what is true or false.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">"" !== 0; // this would return true, as it should because they are not equal.  </pre>
      <p>We can now be confident that these values do not match by using the <strong>Identity Equality Operator</strong>.</p>
      <h3>9.1 Type Checking - Checking numbers with isNaN();</h3>
      <p>JavaScript has a great tool for checking if a value is a number - <em><strong>isNaN()</strong></em>. We should
            always use <em><strong>isNaN() </strong></em>where possible before attempting number equations. This will
            prevent us from getting <em><strong>NaN</strong></em><strong> </strong>errors when dealing with numbers.
      </p>
      <p>
        This is useful for when we are not checking for a particular numerical value but specifically the type and do not
        want to perform a <strong>typeof </strong>check, which we could do in order to check a value is a &ldquo;number&rdquo; but
            we would need to check this specifically ( <em>=== &ldquo;number&rdquo;</em>), <em><strong>isNaN();</strong></em> handles
            the type checking for us in an easy to use function.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let valueA = "abc";
let valueB = 1;
let result = 0;

// First problem
result = valueA + valueB;
console.log(result);

// Second problem
result = valueA * valueB;
console.log(result);  </pre>
      <p>There are a couple of things you will notice here. <strong>The first</strong><strong>problem</strong> being that
            instead of attempting a sum of two values, which was our intention, we have performed a string concatenation
            instead. JavaScript has coerced <em><strong>valueB </strong></em>into being a string. <strong>
          The second
          problem</strong> is when we attempt to perform a more advanced equation, in this case with multiplication.
            This causes a <em><strong>NaN</strong></em><strong> </strong>error. This is because the types do not match and,
            we could have prevented this from occurring:
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let valueA = "abc";
let valueB = 1;
let result = 0;
if(!isNaN(valueA) && !isNaN(valueB)) {
  result = valueA * valueB;
}
console.log(result);

valueA = 2;
valueB = 2;
if(!isNaN(valueA) && !isNaN(valueB)) {
  result = valueA * valueB;
}
console.log(result);  </pre>
      <p>Notice how <em><strong>result </strong></em>is still just 0 for the first output. This is because we will only
            attempt to multiply these two values if they are both numbers.
      </p>
      <p>With our second pass, we have re-assigned <em><strong>valueA</strong></em> and <em><strong>valueB</strong></em>    to indeed be numbers. Now running the same code, <em><strong>result </strong></em>returns 4 because <em><strong>isNaN()</strong></em><strong>;</strong> returned false.</p>
      <p>There is one important thing to always remember with <strong>isNaN(); </strong>It is checking if a<em><strong>NaN</strong></em><strong> </strong>error is returned from type checking a value. So in the above
            snippet we are checking that a <em><strong>NaN</strong></em><strong> </strong>error has <strong>
          <u>NOT</u></strong> occurred by using the <em><strong>!</strong></em>operator (exclamation mark) to check the result is
            false. Keep this in mind when using <em><strong>isNaN();</strong></em>
      </p>
      <h3>9.2 Type Checking - Checking for specific types with <em><strong>typeof</strong></em></h3>
      <p>Another very important tool when it comes to checking for types is the <em><strong>typeof</strong></em><strong></strong>keyword. JavaScript is not strongly typed, we need to manually check for types if we want to be sure.</p>
      <p>We should be using <em><strong>typeof</strong></em> even if we are sure of a type, incase the context has been
            altered for example, or a value is <em><strong>undefined</strong></em>. This way our code will only run if the
            value is of the correct type. This offers protection against incorrect use.
      </p>
      <p><em><strong>typeof</strong></em> is best used in conjunction with an <em><strong>if</strong></em> statement and
            an <strong>Identity Equality Operator</strong>.
      </p>
      <p><em><strong>typeof </strong></em>will return a string representation of the type, so when testing for a type, it
            is important to know the string definition for each type:
      </p>
      <p>&ldquo;undefined&rdquo;</p>
      <p>&ldquo;object&rdquo;</p>
      <p>&ldquo;boolean&rdquo;</p>
      <p>&ldquo;bigint&rdquo;</p>
      <p>&ldquo;string&rdquo;</p>
      <p>&ldquo;symbol&rdquo;</p>
      <p>&ldquo;function&rdquo;</p>
      <h4>Problem</h4>
      <pre class="card p-4">let callback = true;

let get = (callback) => {

    if (callback) {
        callback();
    }
}

get(callback);    </pre>
      <p>This will give an error &ldquo;<em><strong>callback is not a function</strong></em>&rdquo;. This is because we loosely
            checked the callback parameter and assumed that whatever is being passed in is always going to be a function and
            something that we can run. But in this case, it is not a function, so we have a problem. What we need to do, is
            check specifically if the parameter is a function before attempting to handle it as a function.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let callback = true;

let get = (callback) => {

    if (typeof callback === "function") {
        callback();
    }
}

get(callback);  </pre>
      <p>
        This will now not error, as we are checking what type the callback parameter is first. If we were to pass in a
        callback function, then the function would run. This is also known as a <strong>higher order function</strong>    or <strong>delegate function</strong>.
      </p>
      <h4>Example</h4>
      <pre class="card p-4">let callback = () => console.log("This is our callback");

let get = (callback) => {

    if (typeof callback === "function") {
        callback();
    }
}

get(callback);  </pre>
      <p>This will now run and we will also see an output in our developer console &ldquo;<em>This is our callback</em>&rdquo;.</p>
      <h2>10. What is <em>undefined</em> ? How to reliably test for it ?</h2>
      <p><em><strong>Undefined</strong></em> is a primitive type in JavaScript, along with Boolean, Number, String,
            Symbol, Null etc.
      </p>
      <p>We can think of <em><strong>undefined</strong></em> as the default return type in JavaScript for an object or
            variable that has not yet been initialised. If something is not defined, it is therefore undefined.
      </p>
      <p>It is common, when viewing an <em><strong>undefined</strong></em> JavaScript error in the console to see one of
            the following:
      </p>
      <pre class="card p-4">TypeError: 'undefined' is not a function
TypeError: Cannot read property '<prop-name>' of undefined  </pre>
      <p>
        Whilst it is best practice to always initialise a variable or object first with a default value of the correct
        type, sometimes this is out of our control. This is when we need to defend against<em><strong> undefined</strong></em>.
      </p>
      <p>We can reliably test for <em><strong>undefined</strong></em> by using <em><strong>typeof</strong></em>.</p>
      <h4>Problem</h4>
      <pre class="card p-4">let myVariable;
console.log(myVariable);  </pre>
      <p>This variable is not initialised with any value. So when we try and use it, we see that it is<em><strong> undefined</strong></em>.</p>
      <h4>Solution</h4>
      <pre class="card p-4">let myVariable;
if (typeof myVariable !== "undefined") {
    console.log(myVariable);
}  </pre>
      <p>By using <em><strong>typeof</strong></em> we can check to see if a variable returns the string representation of
            the primitive type -<em><strong> undefined. </strong></em>By doing this check, the code will not run if the
            variable is <em><strong>undefined</strong></em>. If our variable is initialised however, then the above code
            would run without error.
      </p>
      <h4>Example</h4>
      <pre class="card p-4">let myVariable = 0;
if (typeof myVariable !== "undefined") {
    console.log(myVariable);
}  </pre>
      <p>In this example we see how initialising with a default value allows the above check to pass and the code to run.</p>
      <h3>10.1 Handling <em>undefined</em></h3>
      <p>It is important to always protect against the occurrence of <em><strong>undefined</strong></em> in our code, such
            an error can cause the entire script to freeze. We can do this by making sure we always initialise our
            definitions before using them.
      </p>
      <p>This can be done both in a method signature and within our closures/methods at the point of definition.</p>
      <h4>Problem</h4>
      <pre class="card p-4">let price;
price.toFixed(2);  </pre>
      <p>You will notice when running this code we get an error: <em><strong>
            TypeError: Cannot read property &apos;toFixed&apos; of
            undefined</strong></em>. This is because, although we have defined our variable, we have not initialised
            it with any value.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let price = 0;
price.toFixed(2);  </pre>
      <p>By assigning the variable with an initial value it is no longer <em><strong>undefined</strong></em> and when we
            want to act on it, we can, without getting an error.
      </p>
      <p>
        This can be more common in a method signature, with the assumption that something being passed in is safe to use
        straight away, when it is not:
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let myMethod = (price) => {
  return price.toFixed(2);
}
myMethod();  </pre>
      <p>This will also error with the same response as the first problem <em><strong>
            TypeError: Cannot read property
            &apos;toFixed&apos; of undefined</strong></em>.</p>
      <h4>Solution</h4>
      <pre class="card p-4">let myMethod = (price = 0) => {
  return price.toFixed(2);
}
myMethod();  </pre>
      <p>Now with a default value assigned in the method signature, the above method will not error.</p>
      <p>It is however safer to combine both a default value with an undefined <em><strong>typeof</strong></em> check in
            the same method. This will give maximum protection against an undefined value.
      </p>
      <h4>Example</h4>
      <pre class="card p-4">let myMethod = (price = 0) => {
  if (typeof price !== "undefined") {
    price = price.toFixed(2);
  }
  return price;
}
myMethod();  </pre>
      <h2>11. Performance</h2>
      <p>
        Accessing the DOM is something very common in JavaScript, due to the position it tends to sit within the stack.
        For the most part, accessing the DOM for a single element is no big deal. But if working on a large application,
        with the DOM populated with many HTML elements, it is very important to understand what is happening every time
        you get or update an element.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">document.querySelector("#elementId").innerText = "Some text";

document.getElementById("elementId").setAttribute("class", "someClass");  </pre>
      <p>
        The above will perform a search of the whole DOM as the HTML is parsed in order to find the elements that are
        being requested. For a single use, it can be argued storing the element before using it is of little benefit,
        but for multiple updates it is important to store the element first.
      </p>
      <p>
        We would not want to be calling any of the above methods thousands of times during an iteration for example. We
        would want to be using caching in order to store and access elements in memory, instead of physically accessing
        the DOM every time.
      </p>
      <p>
        To give this some context, such frameworks as React and Vue.js build up a &ldquo;virtual DOM&rdquo; cached in memory, which
        is always kept in sync with the physical DOM on screen by a process called &ldquo;Reconciliation&rdquo;, this helps a great
        deal to improve performance and is good evidence that caching DOM access is good practice and good for
        performance. See the React documentation for more detail on the &ldquo;Virtual DOM&rdquo; - <a href="https://reactjs.org/docs/faq-internals.html">https://reactjs.org/docs/faq-internals.html</a>
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let element = document.getElementById("elementId");
element.innerText = "Some text";
element.setAttribute("class", "someClass");  </pre>
      <p>
        Now we only access the physical element once, store it and then update it. Notice updating the stored element
        will also update the physical DOM due to the stored element being of <strong>reference type</strong>. This is
            because JavaScript, like other programming languages, also has <strong>reference</strong> types and<strong> value</strong> types.
      </p>
      <h3>11.1 Iteration and performance. Which to use ? (<em>for, while, forEach, map, filter, reduce</em>)</h3>
      <p>
        There are various ways we can loop in JavaScript, depending on what it is you want to do. Some methods are
        quicker than others and much more performant, again depending on the size of the iteration.
      </p>
      <h4>Big O Notation</h4>
      <p><strong>Big O</strong> is a great way to assess how expensive your program is. This may help decide which
            iteration method might fit best to maximise on performance. A great explanation of <strong>Big O</strong> in
            relation to JavaScript can be found here - <a href="https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835">https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835</a>
      </p>
      <h4><em>map(), filter(), reduce(), forEach()</em></h4>
      <p>
        These looping method are all on the Array prototype, which means we can only use them directly on an array. They
        all require a <em><strong>higher order function</strong></em>, as they all take a single method as a parameter.
      </p>
      <p>
        The method passed is performed on every iteration, so be aware of this when using such array methods. Such
        methods are slow to run when considering a large number of iterations and are not particularly performant. They
        are good to use on small arrays and can really help reduce code, but we should not be using them for all
        scenarios, especially not because they read nicely.
      </p>
      <h4><em>for</em> and <em>while</em></h4>
      <p>
        These are the more traditional looping methods, and most common in programming languages. They are far more
        adaptive than the &ldquo;ready made&rdquo; Array looping methods in JavaScript and can be far more performant with a large
        number of iterations.
      </p>
      <p><em><strong>for</strong></em> looping is great for when you know your limit and <em><strong>while</strong></em>    looping is best used when we want a loop to run until a given condition.</p>
      <p>We should be using the correct looping techniques for each given scenario.</p>
      <p>
        The code below demonstrates how certain looping techniques are not as good as others when it comes to
        performance:
      </p>
      <h4>Examples</h4>
      <pre class="card p-4">// Lets setup an example to loop against
let array = [];
let i = 0;

while(i < 2000000){
    array.push(Math.random(5));
    i++;
}

let calc = (a) => a * 1000;
let getTime = () => new Date().getTime();
let timeDifference = (start, end) => end - start;

// Now lets run the below looping methods to see which is more performant.
let mapExample = () => {
    let start = getTime();
    array.map((item) => item = calc(item));
    let end = getTime();
    console.log(`Map example took: ${timeDifference(start,end)}`);
}

let forEachExample = () => {
    let start = getTime();
    array.forEach((item) => item = calc(item));
    let end = getTime();
    console.log(`ForEach example took: ${timeDifference(start,end)}`);
}

let forwardsForExample = () => {
    let start = getTime();
    for(let i = 0; i < array.length; i++){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Forward for loop example took: ${timeDifference(start,end)}`);
}

let forwardsForCachingExample = () => {
    let start = getTime();
    let length = array.length;
    let i;
    for(i = 0; i < length; i++){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Forward for loop, w/ cached length example took: ${timeDifference(start,end)}`);
}

let backwardsForExample = () => {
    let start = getTime();
    for(let i = array.length; i--;){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Backward for loop example took: ${timeDifference(start,end)}`);
}

let backwardsForCachingExample = () => {
    let start = getTime();
    let length = array.length;
    let i = length;
    for(i; i--;){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Backward for loop example took: ${timeDifference(start,end)}`);
}

let whileExample = () => {
    let start = getTime();
    let i = 0;
    let length = array.length;
    while(i < length) {
        array[i] = calc(array[i]);
        i++;
    }
    let end = getTime();
    console.log(`While loop example took: ${timeDifference(start,end)}`);
}

mapExample();
forEachExample();
forwardsForExample();
forwardsForCachingExample();
backwardsForExample();
backwardsForCachingExample();
whileExample();  </pre>
      <p>
        We can clearly see from the resulting outputs after running this code which looping methods are more performant
        and which are better at handling a larger number of iterations.
      </p>
      <p>You will see something like:</p>
      <pre class="card p-4">Map example took: 507
ForEach example took: 137
Forward for loop example took: 5
Forward for loop, w/ cached length example took: 5
Backward for loop example took: 7
Backward for loop example took: 5
While loop example took: 4  </pre>
      <p>With the Array methods Array.<em><strong>map()</strong></em> and Array.<em><strong>forEach()</strong></em> being
            the slowest, especially Array.<em><strong>map()</strong></em>. Array.<em><strong>reduce()</strong></em> and
            Array.<em><strong>filter()</strong></em> have different uses to what we are doing here, but both are equally as
            slow as Array.<em><strong>map() </strong></em>depending on the method being passed and what <em>it</em> is doing
            of course.
      </p>
      <p>The various iterations of <em><strong>for </strong></em>looping are much alike, but there are small performance
            gains to be made with these techniques. Notice we store both the index variable and the length of the array
            before iteration. We should be storing both in memory and not declaring them for every iteration.
      </p>
      <p>Both <em><strong>for</strong></em> and <em><strong>while</strong></em> come out on top when compared to other
            looping techniques.
      </p>
      <h2>12. How can we apply the SOLID principles to JavaScript ?</h2>
      <p><strong>The S.O.L.I.D Principles</strong> are a set of principles that traditionally apply to classic object
            oriented programming languages. Whilst JavaScript is not solely an object oriented language and is very dynamic
            in nature, consisting of multiple paradigms, we can apply the <strong>SOLID principles</strong> for the most
            part.
      </p>
      <p>Arguably there are a number of ways the <strong>SOLID principles</strong> can be interpreted in JavaScript,
            especially when it comes to inheritance, but we will focus on solutions already looked at in this document. We
            have already been following the <strong>SOLID principles</strong> to some degree.
      </p>
      <h3>12.1 S - Single Responsibility Principle</h3>
      <p><strong>The Single Responsibility Principle</strong> aims to have a single concern for any given piece of code.
            We should not couple logic and responsibilities together, we should separate out the logic and responsibilities.
            Smaller, manageable methods will allow for single responsibility, which in turn will allow for effective unit
            testing.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">const doMath = (firstNumber = 0, secondNumber = 0, operator = "+") => {
    let result = 0;
    if(operator === "+") {
        result = firstNumber + secondNumber;
    } else if (operator === "-") {
        result = firstNumber - secondNumber;
    } else if (operator === "x") {
        result = firstNumber * secondNumber;
    }
    return result;
}

let result = doMath(1, 2, "+");
console.log(result);

result = doMath(2, 1, "-");
console.log(result);

result = doMath(1, 2, "x");
console.log(result);  </pre>
      <p>This example breaks a number of the <strong>SOLID principles</strong>. It is not following single responsibility
            because a single method is being used for many concerns. This method would only grow and become unmanageable
            with the more logic we give it.
      </p>
      <p>We can address this by having a dedicated method for each task:</p>
      <h4>Solution</h4>
      <pre class="card p-4">const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

let result = add(1, 2);
console.log(result);

result = subtract(2, 1);
console.log(result);

result = multiply(1, 2);
console.log(result);  </pre>
      <p>
        Instead of having a single method that has many responsibilities we can have individual methods, each with a
        single responsibility. There is no logic involved to decide which method to use and we can be clear which method
        we would like to use in each case. Now we could unit test each method individually, for example, making this
        much more manageable.
      </p>
      <h3>12.2 O - Open Closed Principle</h3>
      <p><strong>The Open Closed Principle</strong> - Open for extension, closed for modification. We need to write our
            code in such a way that we can extend it, without needing to change existing code.
      </p>
      <p>We will go back to the bad example used for <strong>The Single Responsibility Principle</strong>.</p>
      <h4>Problem</h4>
      <pre class="card p-4">const doMath = (firstNumber = 0, secondNumber = 0, operator = "+") => {
    let result = 0;
    if(operator === "+") {
        result = firstNumber + secondNumber;
    } else if (operator === "-") {
        result = firstNumber - secondNumber;
    } else if (operator === "x") {
        result = firstNumber * secondNumber;
    } else if (operator === "/") {
        result = firstNumber / secondNumber;
    }
    return result;
}

let result = doMath(1, 2, "+");
console.log(result);

result = doMath(2, 1, "-");
console.log(result);

result = doMath(1, 2, "x");
console.log(result);

result = doMath(6, 2, "/");
console.log(result);  </pre>
      <p>
        As it stands, we could not extend the functionality of our method without changing the existing code. This would
        mean all logic surrounding this method would need to be retested, even if we only changed a single character or
        line or added a new <em><strong>if </strong></em>clause. We can improve our refactor for the <strong>
          Single
          Responsibility Principle</strong> even further to now cater for <strong>The Open Closed Principle</strong>.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let math = (function() {
    
    const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    return {
        add: add,
        subtract: subtract,
        multiply: multiply
    }
})();

math.divide = (firstNumber = 0, secondNumber = 0) => firstNumber / secondNumber;

let result = math.add(1, 2);
console.log(result);

result = math.subtract(2, 1);
console.log(result);

result = math.multiply(1, 2);
console.log(result);

result = math.divide(6, 2);
console.log(result);  </pre>
      <p>It is now possible to extend this solution. Using the <strong>module pattern</strong>, we can now add additional
            methods at will, without changing any original code in the module. But we should keep in mind that adding
            methods this way will always expose them via the modules interface.
      </p>
      <p>We can achieve similar with <strong>prototypal inheritance</strong>, but with the added benefit of being able to
            pass the same behaviour to <strong>any</strong> derived object:
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">const MathFactory = function() {
    
    this.add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    this.subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    this.multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;
  }

let mathUtil = new MathFactory();

MathFactory.prototype.divide = (firstNumber = 0, secondNumber = 0) => firstNumber / secondNumber;

let result = mathUtil.add(1, 2);
console.log(result);

result = mathUtil.subtract(2, 1);
console.log(result);

result = mathUtil.multiply(1, 2);
console.log(result);

result = mathUtil.divide(6, 2);
console.log(result);  </pre>
      <p>
        Notice that we have instantiated the MathFactory and then modified the base, which has used prototypal
        inheritance to modify all derived instances. This would not break the <strong>The Open Closed Principle</strong>    and also not break the <strong>Liskov Substitution Principle</strong>, if there were multiple instances of the
            MathFactory, they would all still be interchangeable.
      </p>
      <p>A solution now using ES6 Classes:</p>
      <h4>Solution</h4>
      <pre class="card p-4">class MathFactory {
    
    add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;
}

let mathUtil = new MathFactory();

MathFactory.prototype.divide = (firstNumber = 0, secondNumber = 0) => firstNumber / secondNumber;

let result = mathUtil.add(1, 2);
console.log(result);

result = mathUtil.subtract(2, 1);
console.log(result);

result = mathUtil.multiply(1, 2);
console.log(result);

result = mathUtil.divide(6, 2);
console.log(result);  </pre>
      <h3>12.3 L - Liskov Substitution Principle</h3>
      <p><strong>The Liskov Substitution Principle </strong>states that any derived object should be substitutable for the
            base it was derived from without breaking the application.
      </p>
      <p>
        Whilst this may not seem very relevant to a simple JavaScript application, not requiring instances and
        inheritance, we should still understand it.
      </p>
      <p>
        We could apply this way of thinking to any object composition, to allow for swappable implementation, even with
        the <strong>module pattern</strong> and its object literal interface.
      </p>
      <p>
        As an example of this in JavaScript we can look to the previous. We could have added a new method without using
        prototypal inheritance by adding it directly to the instance. The problem with this is that the instances would
        now differ from the base, and therefore would not be interchangeable. This would break the <strong>
          Liskov
          Substitution Principle</strong>.
      </p>
      <p>Let&apos;s try and use another example to demonstrate the problem further.</p>
      <h4>Problem</h4>
      <pre class="card p-4">class Dog {
    walk() {
        console.log("The Dog is walking.");
    }
    sleep() {
        console.log("The Dog is sleeping.");
    }
    bark() {
        console.log("The Dog is barking.");
    }
}

class Cat extends Dog {
    walk() {
        console.log("The Cat is walking.");
    }
    sleep() {
        console.log("The Cat is sleeping.");
    }
    bark() {
        throw new Error("Cats do not bark");
    }
    meow(){
        console.log("The Cat is meowing.");
    }
}

let dog = new Dog();
let cat = new Cat();
let animals = [dog, cat];

animals.forEach((animal) => {
    animal.bark();
});  </pre>
      <p>This will cause an error: <code>Error: Cats do not bark</code> This has happened because, while both Dog and Cat
            have a lot in common (eat, sleep, walk, etc), they do not make the same noises. So in an attempt to make the Dog
            &ldquo;fit&rdquo; into the Cat type, we have amended Cat, we have been lazy and tried to extend Dog. But in doing this it
            means the subclass cannot be substituted for the superclass (base) in the existing application. It is also
            confusing to read, as Cats do not bark, neither do all animals walk.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">class Animal {
    move() {
        console.log("The Animal is moving.");
    }
    sleep() {
        console.log("The Animal is sleeping.");
    }
    communicate() {
        console.log("The Animal is communicating.");
    }
}

class Dog extends Animal {
    move() {
        console.log("The Dog is walking.");
    }
    sleep() {
        console.log("The Dog is sleeping.");
    }
    communicate() {
        console.log("The Dog is barking.")
    }
}

class Cat extends Animal {
    move() {
        console.log("The Cat is walking.");
    }
    sleep() {
        console.log("The Cat is sleeping.");
    }
    communicate() {
        console.log("The Cat is meowing.")
    }
}

let dog = new Dog();
let cat = new Cat();
let animals = [dog, cat];

animals.forEach((animal) => {
    animal.communicate();
});  </pre>
      <p>
        Now we have a higher class to inherit from - Animal, which is more generic and has attributes in common with both
        Cat and Dog. We could swap either of the Dog or Cat for the base of Animal and our code would still execute
        without error. It is important to think ahead like this when designing any object oriented application, creating
        the correct hierarchy early on will ensure there is room for extension, not only ensuring we abide by the<strong> Liskov Substitution Principle</strong>, but also the <strong>Open Closed Principle</strong> and the<strong> Single Responsibility Principle</strong> too.
      </p>
      <h3>12.4 I - Interface Segregation Principle</h3>
      <p><strong>The Interface Segregation Principle </strong>aims to separate methods into cohesive groups of methods,
            with each method being related to a specific task. We should not be grouping methods together that have very
            little relevance to each other. For example, if there is a generic, large module or class, with many unrelated
            methods, that is being injected all over our application, we should not keep adding to that same module for the
            sake of convenience. We should instead create a new module or class, who&rsquo;s <strong>
          <u>only</u></strong> concern
            is of a specific task or related tasks.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let mathFactory = (function() {
    const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    // lets add a new method because an existing method does not already do what we want
    const greetingMessage = (name) => console.log(`Hello ${name}`);

    return {
        add: add,
        subtract: subtract,
        multiply: multiply,
        greetingMessage: greetingMessage

    }
})();

mathFactory.greetingMessage("James");  </pre>
      <p>Here we would have broken a number of the <strong>SOLID principles</strong>, one of which is the<strong> Interface Segregation Principle</strong>. We have appended a method, who&rsquo;s concern has no relation to
            the other methods in the module. This module&rsquo;s concern is to work with numbers, not print greeting messages. If
            this module is already being consumed by our calling code, it might be quicker and easier to just add a method
            to the existing module, but this would be breaking the <strong>Interface Segregation Principle</strong>.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let mathFactory = (function() {
    const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    return {
        add: add,
        subtract: subtract,
        multiply: multiply,
    }
})();

// Make a new module
let greetingFactory = (function() {

    const greet = (name) => console.log(`Hello ${name}`);

    return {
        greet: greet
    }
})();

greetingFactory.greet("James");  </pre>
      <p>
        Now we have a dedicated module that will only include methods that relate to greeting messages. This provides
        good cohesion and divides concerns. This will help keep modules small and manageable. We could then inject this
        new module into the application only where it is needed.
      </p>
      <p>We can also express the same issue as a class:</p>
      <h4>Problem</h4>
      <pre class="card p-4">class MathFactory {
    add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    greetingMessage = (name) => console.log(`Hello ${name}`);
}

let mathUtil = new MathFactory();

mathUtil.greetingMessage("James");  </pre>
      <h4>Solution</h4>
      <pre class="card p-4">class MathFactory {
    add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;
}

class GreetingFactory {
    greet = (name) => console.log(`Hello ${name}`);
}

let greetingUtil = new GreetingFactory();
greetingUtil.greet("James");  </pre>
      <h3>12.5 D - Dependency Inversion Principle</h3>
      <p><strong>The Dependency Inversion Principle</strong> aims to move dependency up the chain of command. The idea is
            to loosely couple our methods, modules and classes with their dependencies.
      </p>
      <p>An obvious example of this is with server requests and nested callbacks, common in an AJAX request.</p>
      <p>One way of achieving <strong>dependency inversion</strong> in JavaScript is by thinking of our functions as<strong> higher order functions</strong> and <strong>lower order functions</strong>. We can invert dependency by
            replacing <strong>lower order functions</strong> with <strong>higher order functions</strong>.
      </p>
      <p>
        Another way of inverting dependency is to program more sequentially, instead of nesting code. Nested code can
        lead to dependencies being buried, this is what we need to look out for when identifying <strong>
          lower order
          functions</strong>. If we use <strong>promises</strong>, for example, we can &ldquo;wait&rdquo; for a task to complete
            before moving on, or while performing some other task, removing the need to nest code. Making asynchronous code
            appear synchronous. It is important to understand JavaScript can handle multiple threads, we should take
            advantage of this.
      </p>
      <p>&ldquo;<em>A promise is an object that may produce a single value some time in the future</em>&rdquo; - See here for a great
            read on promises in JavaScript - <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261</a>
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let userDataFactory = (function() {
    const get = () => {
        // this object would typically come from an API call
        let data =  {
            name: "Anna",
            colour: "Blue"
        }
        printFavouriteColour(data);
    }
    const printFavouriteColour = (data) => console.log(`Hello ${data.name}, your favourite colour is ${data.colour}`);
    return {
        get: get
    }
})();

userDataFactory.get();  </pre>
      <p>With this example we are breaking the <strong>Dependency Inversion Principle</strong>. We have dedicated methods
            to both <em><strong>get</strong></em> and <strong>printFavouriteColour</strong>, but the<em><strong> get</strong></em> method is always dependent on the <em><strong>printFavouriteColour</strong></em>    method, this is essentially the callback method. We would need an entirely new <em><strong>get</strong></em>    method, duplicating code, in order to do some other task once we have the data.
      </p>
      <p>Instead we could move the depending code up the chain and pass it down as a <strong>
          higher order
          function</strong>. We could then always call the <em><strong>get </strong></em>method<em> </em>just to get
            the data and not assume we always want to print out the favourite colour of the user.
      </p>
      <p>
        Because JavaScript is asynchronous by nature, it may be common to see nested callbacks. Similar to the above, in
        order to try and handle timing issues, we could even nest a couple of callbacks. This can get very unmanageable,
        very quickly and is referred to as &ldquo;Callback hell&rdquo; and &ldquo;dependency hell&rdquo;.
      </p>
      <p>
        For example, if we needed to make another call to the server to get more data, but we needed to first wait for
        our user data to arrive before making the second call. How could we handle that without nesting methods ?
      </p>
      <p>A possible solution is using<strong> </strong><em><strong>async await </strong></em>(a promise)<strong></strong>as a means of allowing our code to get the data first before doing anything with it. We can then
            program sequentially, instead of nesting callbacks or dependencies.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let userDataFactory = (function() {
    const get = async () => {
        // this object would typically come from an API call
        let data =  {
            name: "Anna",
            colour: "Blue"
        }
        return data;
    }
    const printFavouriteColour = (data) => console.log(`Hello ${data.name}, your favourite colour is ${data.colour}`);
    const printName = (data) => console.log(`Hello ${data.name}`);
    return {
        get: get,
        printFavouriteColour: printFavouriteColour,
        printName: printName
    }
})();

(async() => {
    let user = await userDataFactory.get();
    userDataFactory.printName(user);
    userDataFactory.printFavouriteColour(user);
})();  </pre>
      <p>Now the same <em>get</em> method can be used again and again. There is no tightly coupled dependency in our code,
            we can determine what we would like to do once we have the data, we could even make another call to a different
            service and wait for both calls to complete, while doing some other task asynchronously. This now makes the<em><strong> get</strong></em> method very flexible and reusable. It has a single responsibility and is not
            tightly coupled to a behaviour or dependency.
      </p>
      <p>A word on <em><strong>async await </strong></em>and <em><strong>promises</strong></em> - please consider browser
            compatibility before using this syntax and <strong>promises</strong> in general.
      </p>
      <p>Now another solution using <strong>higher order functions</strong> to pass down the logic to use once we have the
            data<strong>:</strong>
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let userDataFactory = (function() {
    const get = (callback) => {
        // this object would typically come from an API call
        let data =  {
            name: "Anna",
            colour: "Blue"
        }
        if(typeof callback === "function") {
            callback(data);
        }
    }
    const printFavouriteColour = (data) => console.log(`Hello ${data.name}, your favourite colour is ${data.colour}`);
    const printName = (data) => console.log(`Hello ${data.name}`);
    return {
        get: get,
        printFavouriteColour: printFavouriteColour,
        printName: printName
    }
})();

userDataFactory.get(userDataFactory.printFavouriteColour);
userDataFactory.get(userDataFactory.printName);  </pre>
      <p>With this example we are now passing down the chain a method that has come from a <strong>higher order</strong>.
            Think of this as being similar to a <strong>delegate method</strong>. The method we are passing down will
            determine what we do once we have the data. There is no assumption being made other than we want to do something
            once we have the data. Both solutions given are interpretations of dependency inversion, they move the control
            up the chain to a higher level.
      </p>
      <h2>13. How can we apply the DRY principle to JavaScript ?</h2>
      <p><strong>The DRY Principle</strong> stands for &ldquo;<em>Don&apos;t&apos; Repeat Yourself</em>&rdquo; and refers to code reuse and code
            repetition. Where we see patterns of code forming, we should either be refactoring the code to remove the
            repetition or design the code to maximise on code reuse from the beginning.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let make = "Audi";
let colour = "Red";
let isHybrid = false;
let isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
let description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Ford";
colour = "Blue";
isHybrid = true;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Honda";
colour = "Black";
isHybrid = true;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Lamborghini";
colour = "Black";
isHybrid = false;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Porsche";
colour = "Yellow";
isHybrid = false;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Dodge";
colour = "Green";
isHybrid = true;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);  </pre>
      <p>
        Here we clearly have a repetition of code. Each block of code is doing exactly the same thing. The only
        difference with each block are the properties. The logic is identical and the result of each block is of the
        same type - a string. The code would grow 6 lines with every car we add. This is not <strong>DRY</strong>!
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">class Car {
    constructor(make, colour, isHybrid) {
        this.make = make;
        this.colour = colour;
        this.isHybrid = isHybrid;
        this.isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
    }
    describe = () => `This car is an ${this.make} and it is ${this.colour}. This car ${this.isHybridText}`;
}

let describeCars = (cars = []) => {
    cars.forEach((car) => {
        console.log(car.describe());
    });
}

let cars = [
    new Car("Audi", "Red", false),
    new Car("Ford", "Blue", true),
    new Car("Honda", "Black", true),
    new Car("Lamborghini", "Black", false),
    new Car("Porsche", "Yellow", false),
    new Car("Dodge", "Green", true),
];

describeCars(cars);  </pre>
      <p>
        Now using a reusable class and a some iteration, we are able to reuse the same code again and again. Our code
        will now only grow with a single line for every car we add. This is now <strong>DRY</strong>, we should always
            be thinking of <strong>DRY</strong>.
      </p>
      <h2>14. How can we apply the KISS principle to JavaScript ?</h2>
      <p><strong>The KISS Principle</strong> stands for &ldquo;<em>Keep it simple, stupid</em>&rdquo; and relates to overly complex
            code. The smaller and simpler our methods are, the more manageable our code will be. Complex code is prone to
            bugs, so by keeping it simple we remove the likelihood of bugs and we make our code much more friendly to work
            with and read.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">let convertIntToDay = (dayNumber = 0) => {
    let result = "";
    if(dayNumber === 0) {
        result = "Monday";
    } else if(dayNumber === 1) {
        result = "Tuesday";
    } else if(dayNumber === 2) {
        result = "Wednesday";
    } else if(dayNumber === 3) {
        result = "Thursday";
    } else if(dayNumber === 4) {
        result = "Friday";
    } else if(dayNumber === 5) {
        result = "Saturday";
    } else if(dayNumber === 6) {
        result = "Sunday";
    }
    return result;
}

let day = convertIntToDay(2);
console.log(day);  </pre>
      <p>This example uses multiple <em><strong>if</strong></em> statements to handle what is essentially just an index
            lookup. There is far more logic here than there needs to be. This is the kind of code that is in breach of the<strong> KISS</strong> principle.
      </p>
      <p>
        We could use a switch to make this read a bit easier, but simpler still, we could use the index directly to find
        the matched day. Arrays in JavaScript are zero indexed, so if our case begins with a zero we could get the same
        result by using the passed in number as an index position for the array.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">let convertIntToDay = (dayNumber = 0) => {
    let days = [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday"
    ]
    if(days.length < dayNumber) {
        throw new Error("Must be in range of days");
    }
    return days[dayNumber];
}

let day = convertIntToDay(2);
console.log(day);  </pre>
      <p>
        Removing all the unnecessary logic reveals a much cleaner solution, easier to understand and read. We are relying
        instead on the index of the array in order to find the matched day. This is a clear example of the<strong> KISS</strong><strong> principle</strong> and what to look out for when considering existing code or
            designing new code.
      </p>
      <h2>15. How can we apply the YAGNI principle to JavaScript ?</h2>
      <p><strong>The YAGNI principle</strong> stands for &ldquo;<em>You ain&rsquo;t gonna need it</em>&rdquo; and aims to remove unnecessary
            code and features. We should not be adding complexity just because it might come in handy in the future. Yes we
            should always consider future proofing our code, but be careful, we should not add extra weight where it is not
            needed. For example, adding additional properties that are not being used - &ldquo;<em>you ain&rsquo;t gonna need it</em>&rdquo;.
      </p>
      <h4>Problem</h4>
      <pre class="card p-4">class Person {
    constructor(name) {
        this.name = name;
    }
    name = "";
    age = 0;
    sex = "";
    occupation = "";
}

let person = new Person("James");

console.log(person.name);  </pre>
      <p>
        In this example we see there are more properties than we need, they are not being used in the constructor and
        they are not being accessed elsewhere. They appear to be there &ldquo;just in case&rdquo;. We do not need them.
      </p>
      <h4>Solution</h4>
      <pre class="card p-4">class Person {
    constructor(name) {
        this.name = name;
    }
}

let person = new Person("James");

console.log(person.name);  </pre>
      <p>
        Now having removed the unnecessary properties we have a much cleaner solution, comprising only of the properties
        we need. This is following the <strong>YAGNI</strong> principle and we should be using this principle where
            possible.
      </p>
      <p>
        Only implement what we need for the immediate requirement and not what we think we might need in the future. This
        allows for faster development and simpler, lighter code.
        
      </p>
      <hr>
      <h2>References</h2>
      <ul>
        <li>
          <p><a href="https://google.github.io/styleguide/jsguide.html">https://google.github.io/styleguide/jsguide.html</a></p>
        </li>
        <li>
          <p><a href="https://developer.mozilla.org/en-US/docs/MDN/Contribute/Guidelines/Code_guidelines/JavaScript">https://developer.mozilla.org/en-US/docs/MDN/Contribute/Guidelines/Code_guidelines/JavaScript</a></p>
        </li>
        <li>
          <p><a href="https://www.w3.org/wiki/JavaScript_best_practices">https://www.w3.org/wiki/JavaScript_best_practices</a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/default.asp">https://www.w3schools.com/js/default.asp</a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/js_conventions.asp">https://www.w3schools.com/js/js_conventions.asp</a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/js_best_practices.asp">
              <u>https://www.w3schools.com/js/js_best_practices.asp</u></a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/js_mistakes.asp">https://www.w3schools.com/js/js_mistakes.asp</a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/js_performance.asp">https://www.w3schools.com/js/js_performance.asp</a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/js_let.asp">https://www.w3schools.com/js/js_let.asp</a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/js_const.asp">https://www.w3schools.com/js/js_const.asp</a></p>
        </li>
        <li>
          <p><a href="https://dorey.github.io/JavaScript-Equality-Table/">https://dorey.github.io/JavaScript-Equality-Table/</a></p>
        </li>
        <li>
          <p><a href="https://www.w3schools.com/js/js_arrow_function.asp">https://www.w3schools.com/js/js_arrow_function.asp</a></p>
        </li>
        <li>
          <p><a href="https://www.freecodecamp.org/news/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26/">https://www.freecodecamp.org/news/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26/</a></p>
        </li>
        <li>
          <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></p>
        </li>
        <li>
          <p><a href="https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/">https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/</a></p>
        </li>
        <li>
          <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a></p>
        </li>
        <li>
          <p><a href="https://guide.freecodecamp.org/javascript/closures/">https://guide.freecodecamp.org/javascript/closures/</a></p>
        </li>
        <li>
          <p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36</a></p>
        </li>
        <li>
          <p><a href="https://medium.com/backticks-tildes/understanding-hoisting-and-scoping-in-javascript-39ea7b41e31">https://medium.com/backticks-tildes/understanding-hoisting-and-scoping-in-javascript-39ea7b41e31</a></p>
        </li>
        <li>
          <p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9">https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9</a></p>
        </li>
        <li>
          <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof</a></p>
        </li>
        <li>
          <p><a href="http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm">http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm</a></p>
        </li>
        <li>
          <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined</a></p>
        </li>
        <li>
          <p><a href="https://levelup.gitconnected.com/sneak-peak-of-map-filter-and-reduce-in-javascript-79d38181a48">https://levelup.gitconnected.com/sneak-peak-of-map-filter-and-reduce-in-javascript-79d38181a48</a></p>
        </li>
        <li>
          <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes</a></p>
        </li>
        <li>
          <p><a href="https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835">https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835</a></p>
        </li>
        <li>
          <p><a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261</a></p>
        </li>
        <li>
          <p><a href="https://medium.com/ltunes/what-is-clean-code-naming-conventions-part-1-426d383eb85d">https://medium.com/ltunes/what-is-clean-code-naming-conventions-part-1-426d383eb85d</a></p>
        </li>
        <li>
          <p><a href="http://bensmith.io/20-tips-for-better-naming">http://bensmith.io/20-tips-for-better-naming</a></p>
        </li>
        <li>
          <p><a href="https://reactjs.org/docs/faq-internals.html">https://reactjs.org/docs/faq-internals.html</a></p>
        </li>
        <li>
          <p><a href="https://alligator.io/js/class-composition/">https://alligator.io/js/class-composition/</a></p>
        </li>
        <li>
          <p><a href="https://babeljs.io/">https://babeljs.io/</a></p>
        </li>
        <li>
          <p><a href="https://requirejs.org/docs/whyamd.html">https://requirejs.org/docs/whyamd.html</a></p>
        </li>
        <li>
          <p><a href="http://browserify.org/">http://browserify.org/</a></p>
        </li>
        <li>
          <p><a href="https://webpack.js.org/">https://webpack.js.org/</a></p>
        </li>
      </ul>
    </div>
    <footer class="bg-dark mt-5" id="footer">
      <div class="container pt-4">
        <ul class="list-unstyled list-inline text-center">
          <li class="list-inline-item"><a class="btn-floating btn-fb mx-1" href="https://github.com/fsereno" target="_blank"><i class="fa fa-github fa-2x"></i></a></li>
          <li class="list-inline-item"><a class="btn-floating btn-tw mx-1" href="https://www.linkedin.com/in/fabio-sereno-6a97b986/" target="_blank"><i class="fa fa-linkedin fa-2x"></i></a></li>
        </ul>
      </div>
      <div class="footer-copyright text-center pb-3">Copyright &copy; 2020. Fabio Sereno.
        All rights reserved.
      </div>
    </footer>
    <script src="../js/vendor.js"></script>
    <script src="js/app.js"></script>
    
  </body>
</html>