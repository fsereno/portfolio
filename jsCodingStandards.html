<!DOCTYPE html>
<html>
<head>
    <title>View Source</title>
    <link rel="canonical" href="/wiki/pages/viewpage.action?pageId=$action.page.id" />
    <script>
        window.WRM = window.WRM || {}; window.WRM._unparsedData = window.WRM._unparsedData || {}; window.WRM._unparsedErrors = window.WRM._unparsedErrors || {};
        WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-plugin:context-path.context-path"] = "\"/wiki\"";
        WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-rest:curl.cross-origin-resources"] = "false";
        if (window.WRM._dataArrived) window.WRM._dataArrived();</script>
    <link type="text/css" rel="stylesheet" href="//confluence-v1.prod.atl-paas.net/master/aui-reset.css"
        data-wrm-external data-wrm-key="com.atlassian.auiplugin:aui-reset" data-wrm-batch-type="resource" media="all">
    <link type="text/css" rel="stylesheet" href="//confluence-v1.prod.atl-paas.net/master/aui-page-typography.css"
        data-wrm-external data-wrm-key="com.atlassian.auiplugin:aui-page-typography" data-wrm-batch-type="resource"
        media="all">
    <link type="text/css" rel="stylesheet"
        href="//d1okpoprma61ms.cloudfront.net/sharecentre.atlassian.net/wiki/s/d41d8cd98f00b204e9800998ecf8427e-CDN/1553126700/h/210b8ddbcac0b05e5476c72c35ac5ade/_/download/contextbatch/css/_super/batch.css?externals=__local-default__&amp;relative-url=true"
        data-wrm-key="_super" data-wrm-batch-type="context" media="all">
    <link type="text/css" rel="stylesheet"
        href="//d1okpoprma61ms.cloudfront.net/sharecentre.atlassian.net/wiki/s/d41d8cd98f00b204e9800998ecf8427e-CDN/1553126700/h/0a755ea35227a7421e0ea53ab68cc31b/_/download/contextbatch/css/plugin.viewsource,-_super/batch.css?externals=__local-default__&amp;relative-url=true"
        data-wrm-key="plugin.viewsource,-_super" data-wrm-batch-type="context" media="all">
    <link type="text/css" rel="stylesheet"
        href="//d1okpoprma61ms.cloudfront.net/sharecentre.atlassian.net/wiki/s/d41d8cd98f00b204e9800998ecf8427e-CDN/1553126700/h/3f463fdc98ced4954b662e8251e1395d/_/download/contextbatch/css/page,-_super/batch.css?build-number=6452&amp;externals=__local-default__&amp;relative-url=true"
        data-wrm-key="page,-_super" data-wrm-batch-type="context" media="all">
    <link type="text/css" rel="stylesheet"
        href="//d1okpoprma61ms.cloudfront.net/sharecentre.atlassian.net/wiki/s/d41d8cd98f00b204e9800998ecf8427e-CDN/1553126700/h/3f463fdc98ced4954b662e8251e1395d/_/download/contextbatch/css/page,-_super/batch.css?build-number=6452&amp;externals=__local-default__&amp;media=print&amp;relative-url=true"
        media="print" data-wrm-key="page,-_super" data-wrm-batch-type="context">
    <link type="text/css" rel="stylesheet"
        href="//d1okpoprma61ms.cloudfront.net/sharecentre.atlassian.net/wiki/s/d41d8cd98f00b204e9800998ecf8427e-CDN/1553126700/h/b6824e0c1be490a2b6ae56d549e60475/_/download/contextbatch/css/editor-content,-_super/batch.css?confluence.table.resizable=true&amp;externals=__local-default__&amp;relative-url=true"
        data-wrm-key="editor-content,-_super" data-wrm-batch-type="context" media="all">
    <!--[if lte IE 9]>
<link type="text/css" rel="stylesheet" href="//d1okpoprma61ms.cloudfront.net/sharecentre.atlassian.net/wiki/s/d41d8cd98f00b204e9800998ecf8427e-CDN/1553126700/h/b6824e0c1be490a2b6ae56d549e60475/_/download/contextbatch/css/editor-content,-_super/batch.css?conditionalComment=lte+IE+9&amp;confluence.table.resizable=true&amp;externals=__local-default__&amp;relative-url=true" data-wrm-key="editor-content,-_super" data-wrm-batch-type="context" media="all">
<![endif]-->
    <link type="text/css" rel="stylesheet"
        href="//d1okpoprma61ms.cloudfront.net/sharecentre.atlassian.net/wiki/s/814565310/6452/ab3dc58619f20c766f3d2596220f9e87b7e9df0d/1/_/styles/colors.css"
        media="all">

</head>

<body class="mceContentBody aui-theme-default wiki-content fullsize">
    <p>&nbsp;</p>
    <h1>Contents</h1>
    <p /><img class="editor-inline-macro"
        src="https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro?definition=e3RvY30&amp;locale=en_US&amp;version=2"
        data-macro-name="toc" data-macro-id="8e2986af-6cc9-40f5-afc6-62a85368df14" data-macro-schema-version="1">
    <h1>Revision history</h1>
    <table data-layout="default" class="confluenceTable">
        <tbody>
            <tr>
                <th class="confluenceTh">
                    <p><strong>Date</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Version</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Change</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Author</strong></p>
                </th>
            </tr>
            <tr>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p>initial</p>
                </td>
                <td class="confluenceTd">
                    <p>initial</p>
                </td>
                <td class="confluenceTd">
                    <p>Fabio Sereno</p>
                </td>
            </tr>
            <tr>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
            </tr>
        </tbody>
    </table>
    <h1>Approvals</h1>
    <table data-layout="default" class="confluenceTable">
        <tbody>
            <tr>
                <th class="confluenceTh">
                    <p><strong>Group</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Members</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Date of issue</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Version</strong></p>
                </th>
            </tr>
            <tr>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
            </tr>
            <tr>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
            </tr>
        </tbody>
    </table>
    <h1>Distribution</h1>
    <table data-layout="default" class="confluenceTable">
        <tbody>
            <tr>
                <th class="confluenceTh">
                    <p><strong>Role</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Name</strong></p>
                </th>
                <th class="confluenceTh">
                    <p><strong>Date of issue </strong></p>
                </th>
            </tr>
            <tr>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
            </tr>
            <tr>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
                <td class="confluenceTd">
                    <p />
                </td>
            </tr>
        </tbody>
    </table>
    <h1>References</h1>
    <ul>
        <li>
            <p><a
                    href="https://google.github.io/styleguide/jsguide.html">https://google.github.io/styleguide/jsguide.html</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://developer.mozilla.org/en-US/docs/MDN/Contribute/Guidelines/Code_guidelines/JavaScript">https://developer.mozilla.org/en-US/docs/MDN/Contribute/Guidelines/Code_guidelines/JavaScript</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://www.w3.org/wiki/JavaScript_best_practices">https://www.w3.org/wiki/JavaScript_best_practices</a>
            </p>
        </li>
        <li>
            <p><a href="https://www.w3schools.com/js/default.asp">https://www.w3schools.com/js/default.asp</a></p>
        </li>
        <li>
            <p><a
                    href="https://www.w3schools.com/js/js_conventions.asp">https://www.w3schools.com/js/js_conventions.asp</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://www.w3schools.com/js/js_best_practices.asp"><u>https://www.w3schools.com/js/js_best_practices.asp</u></a>
            </p>
        </li>
        <li>
            <p><a href="https://www.w3schools.com/js/js_mistakes.asp">https://www.w3schools.com/js/js_mistakes.asp</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://www.w3schools.com/js/js_performance.asp">https://www.w3schools.com/js/js_performance.asp</a>
            </p>
        </li>
        <li>
            <p><a href="https://www.w3schools.com/js/js_let.asp">https://www.w3schools.com/js/js_let.asp</a></p>
        </li>
        <li>
            <p><a href="https://www.w3schools.com/js/js_const.asp">https://www.w3schools.com/js/js_const.asp</a></p>
        </li>
        <li>
            <p><a
                    href="https://dorey.github.io/JavaScript-Equality-Table/">https://dorey.github.io/JavaScript-Equality-Table/</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://www.w3schools.com/js/js_arrow_function.asp">https://www.w3schools.com/js/js_arrow_function.asp</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://www.freecodecamp.org/news/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26/">https://www.freecodecamp.org/news/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26/</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/">https://www.smashingmagazine.com/2016/07/how-to-use-arguments-and-parameters-in-ecmascript-6/</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://guide.freecodecamp.org/javascript/closures/">https://guide.freecodecamp.org/javascript/closures/</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://medium.com/backticks-tildes/understanding-hoisting-and-scoping-in-javascript-39ea7b41e31">https://medium.com/backticks-tildes/understanding-hoisting-and-scoping-in-javascript-39ea7b41e31</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9">https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof</a>
            </p>
        </li>
        <li>
            <p><a
                    href="http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm">http://www.c-point.com/javascript_tutorial/jsgrpComparison.htm</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://levelup.gitconnected.com/sneak-peak-of-map-filter-and-reduce-in-javascript-79d38181a48">https://levelup.gitconnected.com/sneak-peak-of-map-filter-and-reduce-in-javascript-79d38181a48</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835">https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261</a>
            </p>
        </li>
        <li>
            <p><a
                    href="https://medium.com/ltunes/what-is-clean-code-naming-conventions-part-1-426d383eb85d">https://medium.com/ltunes/what-is-clean-code-naming-conventions-part-1-426d383eb85d</a>
            </p>
        </li>
        <li>
            <p><a href="http://bensmith.io/20-tips-for-better-naming">http://bensmith.io/20-tips-for-better-naming</a>
            </p>
        </li>
        <li>
            <p><a href="https://reactjs.org/docs/faq-internals.html">https://reactjs.org/docs/faq-internals.html</a></p>
        </li>
        <li>
            <p><a href="https://alligator.io/js/class-composition/">https://alligator.io/js/class-composition/</a></p>
        </li>
        <li>
            <p><a href="https://babeljs.io/">https://babeljs.io/</a></p>
        </li>
        <li>
            <p><a href="https://requirejs.org/docs/whyamd.html">https://requirejs.org/docs/whyamd.html</a></p>
        </li>
        <li>
            <p><a href="http://browserify.org/">http://browserify.org/</a></p>
        </li>
        <li>
            <p><a href="https://webpack.js.org/">https://webpack.js.org/</a></p>
        </li>
    </ul>
    <h1>Objective </h1>
    <p>The purpose of these standards is to promote maintainable, readable and scalable JavaScript code.</p>
    <p>Whilst these standards will adhere to the behaviours, limitations and conventions of JavaScript, some of the core
        principles mentioned are proven software design principles, which may be applied across the board, such as the
        SOLID, YAGNI, KISS and DRY principles.</p>
    <p>In order to understand the reasoning for some of these standards, it is important to first understand the dynamic
        nature of JavaScript and some key characteristics, along with the available tools that are native to the
        language. With this in mind, this document will attempt to offer clear explanations to justify suggestions. </p>
    <p>This document will also include examples using the latest ES6 JavaScript standards. Apply these with caution.
        Ensure browser compatibility and use a transpiler such as <a href="https://babeljs.io/">Babel</a> if you wish to
        use ES6 syntax.</p>
    <p>There is a repository of all examples used in this document:</p>
    <p><a href="https://bitbucket.org/sharecentre/tsc.codingstandards.js/src/master/"
            data-card-appearance="inline">https://bitbucket.org/sharecentre/tsc.codingstandards.js/src/master/</a> </p>
    <h1>1. Being <em>Strict </em>in JavaScript</h1>
    <p>All JavaScript should be written in strict mode. This will highlight possible issues with the script either
        during compilation, with a tool such a Babel, or in the developer console in the browser.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="3d509792-1caf-4cf4-95a5-249773c79013"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>name = "Adam";
console.log(`Hello ${name}`);</pre>
            </td>
        </tr>
    </table>
    <p>This will not error, but there is a problem with this code. The name variable is global and it has no protection.
        Declarations such as this should not happen for a number of reasons, mainly around scoping and shadowing,
        explained later in more detail.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="c5230faa-8ea2-4aac-bd4c-70f56d969002"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>"use strict";

name = "Adam";
console.log(`Hello ${name}`);</pre>
            </td>
        </tr>
    </table>
    <p>Now in strict mode, this will error and so it should! Strict mode has highlighted for us that this is bad code
        and we should correct it. We should see strict mode as a useful tool when writing quality JavaScript and we
        should always use it.</p>
    <h1>2. Naming</h1>
    <p>Naming can be split into the following categories:</p>
    <ul>
        <li>
            <p>General naming conventions</p>
        </li>
        <li>
            <p>Variable names</p>
        </li>
        <li>
            <p>Constant names</p>
        </li>
        <li>
            <p>Function names</p>
        </li>
    </ul>
    <h2>2.1 General naming conventions</h2>
    <p><strong>Function</strong> and <strong>variable</strong> naming should be in <strong>camelCase</strong>.</p>
    <p><strong>Class</strong> and <strong>constructor functions</strong> should be in <strong>PascalCase</strong>.</p>
    <p><strong>Constants</strong> should be identified by using <strong>CAPITAL_CASE</strong>.</p>
    <h2>2.2 Variable names</h2>
    <p>Variable names should be meaningful, searchable and pronounceable. Variable names should reveal intention of use
        and avoid disinformation.</p>
    <p>Think about why the variable name exists, we should be able to tell what the variable holds in memory just by
        reading it.</p>
    <p>Comments should not be required in order to explain a variable name. The name itself should be meaningful and
        sufficient that comments are not required. </p>
    <p>We should not use mental mapping of variable names with the use of abbreviations such as “i”, or “a” or “dd” or
        “crn” etc:</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="050fc320-6802-452e-ae8f-ff0b46e6f86d"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var i = 0;</pre>
            </td>
        </tr>
    </table>
    <p>What is “i” in this context ? This is disinformation. In this case a more meaningful variable name would be
        preferred: “index”, “counter” or “position”. </p>
    <p>Depending on the scope, Variable names should also not be unnecessarily too descriptive, such as: <em><span
                class="inline-comment-marker"
                data-ref="cbb12e7d-57f8-4548-90cb-b14870099791">indexOfTheItemIamIteratingThroughInMyCollection</span></em>
        - In a local scope this can also be seen as disinformation by being overly descriptive. We are aware of the
        context in a local scope, so a shorter variable name would be preferred. </p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="6cc58c52-3016-489a-820a-ea5e9e230442"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var index = 0;</pre>
            </td>
        </tr>
    </table>
    <p>The problem of abbreviation becomes more relevant in the case of nested <em>for </em>loops when working with
        multidimensional arrays:</p>
    <h3> Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="82a323f3-7be1-4725-8d3b-60f662f53c6d"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var categories = [[0,1],[2,3]];

for(var i = 0; i &lt; categories.length; i++) {
    for(var j = 0; j &lt; categories[i].length; j++) {
        console.log(categories[i][j]);
    }
}</pre>
            </td>
        </tr>
    </table>
    <p>When there are nested <em>for </em>loops, there will be multiple index variables. Abbreviating them could cause
        ambiguity around what “i” or “j” are, you also cannot use “i” twice in the same block scope, as it already
        exists.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="988bca22-06d0-498b-80e1-def1ad6108ba"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var categories = [[0,1],[2,3]];

for(let category = 0; category &lt; categories.length; category++) {
    for(let item = 0; item &lt; categories[category].length; item++) {
        console.log(categories[category][item]);
    }
}</pre>
            </td>
        </tr>
    </table>
    <p>Here using, short but descriptive variable names allows us to clearly read what we are iterating over.</p>
    <p><strong>However</strong>, <span class="inline-comment-marker"
            data-ref="89243c9d-0fd2-46d2-8e93-bfd80286a9ab">using “i” for the index variable in the context of a single
            level </span><em><span class="inline-comment-marker" data-ref="89243c9d-0fd2-46d2-8e93-bfd80286a9ab">for
            </span></em><span class="inline-comment-marker" data-ref="89243c9d-0fd2-46d2-8e93-bfd80286a9ab">loop is a
            common approach and is acceptable :</span></p>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="c667571e-b476-4b35-a5cf-b341f197e3ab"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const items = [0, 1, 2, 3];

for(let i = 0; i &lt; items.length; i++) {
    console.log(items[i]);   
}</pre>
            </td>
        </tr>
    </table>
    <p>Variable names <strong>can </strong>however be longer, but their length should be <strong>relative </strong>to
        the scope they are in.</p>
    <p>A variable name in the outer scope (not necessarily global), might require some additional context or even a
        namespace for it to be meaningful enough, making it longer in length. This is the preferred approach, instead of
        the need to add comments in order to explain what a variable is doing, the name itself should be enough.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="37880359-6b5a-4114-981c-cca79143948b"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>//Outer scope
let entry = "index.js";
let root = "http://www.application.co.uk/";  

let getEntryUrl = function() {
  //Inner scope
  return `${root}${entry}`
}

console.log(getEntryUrl())</pre>
            </td>
        </tr>
    </table>
    <p>The problem with these variable names is that they do not reflect the scope they are in, they have no context.
        Both<em> entry </em>or <em>root</em> are being declared in a much wider scope than where they are being used.
        They are being used at the block level, so for us to know where they have come from and what they are being used
        for, we should consider a more descriptive naming convention for them.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="85231e71-2ce7-4a83-931b-108db50cb119"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>//Outer scope
let globalApplicationConfigurationSettings = {
    entry: "index.js",
    root: "http://www.application.co.uk/"  
}

let getEntryUrl = function() {
  //Inner scope
  return `${globalApplicationConfigurationSettings.root}${globalApplicationConfigurationSettings.entry}`
}

console.log(getEntryUrl())</pre>
            </td>
        </tr>
    </table>
    <p>Now our intention is clear with a much more descriptive naming convention. We are still declaring in the outer
        scope, but they are being encapsulated by an object literal, which means in order to access these properties we
        need to go via the objects namespace. This now gives <em>root </em>and <em>entry </em>a clear context and we
        know exactly where they are coming from and what they are going to be used for.</p>
    <p>We should be writing boolean variables as <strong>predicates</strong>, such as “is” or “has”. This would help
        denote state. For example, either something “is” or something “is not”.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="f213aa2e-0879-4145-b9f2-a3c3b1ab3a52"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let empty = true;
if(empty) {
  console.log("It is empty");
}</pre>
            </td>
        </tr>
    </table>
    <p>We do not know initially from looking at this variable that it returns a boolean, we can only assume it is. For
        all we know, <em>empty </em>could contain an empty string, not a state. This variable also has no context, what
        is empty ? It is ambiguous.</p>
    <h3>Solution </h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="e7619703-c935-462c-944d-ac3d2debaf8c"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let input = {
  isEmpty: true
}
if(input.isEmpty) {
  console.log("It is empty");
}</pre>
            </td>
        </tr>
    </table>
    <p>This variable now refers to something that “is” empty. We have also used an object literal to contain all of the
        properties sharing the same context. This also allows for a nice and clear <em>if</em> statement.</p>
    <h2>2.2.1 Avoiding Magic Numbers</h2>
    <p>We should avoid <strong>Magic Numbers </strong>where possible. We should always declare arbitrary numbers as
        variables with a clear, meaningful name as per our naming conventions - <a
            href="https://sharecentre.atlassian.net/wiki/spaces/GD/pages/1388118080/JavaScript+Coding+Standards#2.-Naming"
            data-card-appearance="inline">https://sharecentre.atlassian.net/wiki/spaces/GD/pages/1388118080/JavaScript+Coding+Standards#2.-Naming</a>
    </p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="d392ab4c-cddc-40ec-b11e-e414e47d3d1e"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var password = "Password1";
if (password.length > 8 &amp;&amp; password.length &lt; 31) {
  console.log("Password is valid");
}</pre>
            </td>
        </tr>
    </table>
    <p>Initially from the above code we do not know the meaning of 8 or 31 without reading through the code first. We
        should know what they are being used for without need to read through the code.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="b5a04e13-99eb-4516-8cea-72e86d3919a9"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var password = "Password1";
const MIN_PASSWORD_LENGTH = 8;
const MAX_PASSWORD_LENGTH = 31;
if (password.length > MIN_PASSWORD_LENGTH &amp;&amp; password.length &lt; MAX_PASSWORD_LENGTH) {
  console.log("Password is valid");
}</pre>
            </td>
        </tr>
    </table>
    <p>Now we have assigned these values as constants with meaningful names. We now know exactly what they are being
        used for. We can also change them without needing to amend the existing logic directly.</p>
    <h2>2.3 Constant Names</h2>
    <p>Constants should be identified as being “constant”, something that cannot be changed. We can visually do this
        with the use of <strong>CAPITAL_CASE</strong>. In JavaScript if you see a declaration using
        <strong>CAPITAL_CASE</strong>, it means the value should not be changed.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="6622bb24-2362-4459-9530-fdeaa6efbf13"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var thresholdOfUsers = 10;
var thresholdOfUsers = 30;
thresholdOfUsers = 50;</pre>
            </td>
        </tr>
    </table>
    <p>Visually there is nothing denoting the above variable should be treated as a constant. This is a problem when
        trying to ensure your code is to be used as intended by other developers.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="a0d73959-600b-4c4e-8b77-36a3753973a4"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var THRESHOLD_OF_USERS = 10;

// or, even better:

const THRESHOLD_OF_USERS = 10;</pre>
            </td>
        </tr>
    </table>
    <p>By using <strong>CAPITAL_CASE</strong> it helps identify the difference between a constant, which should not be
        changed and a variable declared using <strong>camelCase</strong> which may be changed. We can offer additional
        protection by using the <em><strong>const </strong></em>keyword. This is covered in section 5. Declarations in
        more detail <a
            href="https://sharecentre.atlassian.net/wiki/spaces/GD/pages/1388118080/JavaScript+Coding+Standards#5.-Declarations"
            data-card-appearance="inline">https://sharecentre.atlassian.net/wiki/spaces/GD/pages/1388118080/JavaScript+Coding+Standards#5.-Declarations</a>
    </p>
    <h2>2.4 Function names</h2>
    <p>With the same approach, function names should also be meaningful, searchable and pronounceable. Make them a verb,
        what is the function actually doing ? what is it returning ? is it an integer, a boolean, a string ?</p>
    <p>JavaScript by nature is a dynamic language, it is not strongly typed, which means it is very easy to return an
        unexpected data type, either intentionally or unintentionally. Making variable and function names descriptive is
        very important when making code readable and understandable, as this cannot always be denoted from a methods
        signature in JavaScript, unlike some statically types languages such as C#, Java etc.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="f1fd0274-846a-4ede-9e3b-4b86d4712585"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>function error(input) {
  return input === 0;
};</pre>
            </td>
        </tr>
    </table>
    <p>The problem here is the method name does not suggest it is doing anything, or that it is returning anything, when
        it is in fact evaluating an input and returning <em><strong>true</strong></em> or
        <em><strong>false</strong></em>.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="82dcb066-6c21-44bd-a9b3-e8c9b60077d6"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>function validateInput(input) {
  return input === 0;
};</pre>
            </td>
        </tr>
    </table>
    <p>Breaking this method name into parts. The “validate” is a verb and implies what this method is doing -
        validating. The “Input” is describing what we are actually acting on, or evaluating.</p>
    <p>Functions or members that exist inside a specific scope or class should not add unnecessary context to their
        names:</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="4fd7418c-2227-4a5f-b678-577d461c42ea"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var user = function() {
    this.getUser = function() { 

    };
    this.deleteUser = function() { 

    };
}</pre>
            </td>
        </tr>
    </table>
    <p><span class="inline-comment-marker" data-ref="82a5572d-fb9f-4397-97be-bdbe52578961">The additional context of
            “user” is not needed here:</span></p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="06d209ab-0050-4dae-a5e7-d36832219169"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var user = function () {
    this.get = function () {

    };
    this.delete = function () {

    };
}</pre>
            </td>
        </tr>
    </table>
    <h1>3. Constructor Functions, Object Literals and Classes</h1>
    <p>We should be using either <strong>Constructor functions, object literals</strong> or the <strong>class
        </strong>construct where possible for declaring patterns of variables that could be identified as objects. This
        is typically good in the sense of a more traditional object oriented approach to programming. This can really
        help with code reuse, reducing repetition and also improve reliability and readability.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="2f2b3c62-affd-4cc2-81d6-15a35aacae41"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let name = "James"
let age = 23;
console.log(`${name} ${age}`)

name = "Anna"
age = 30;
console.log(`${name} ${age}`)

name = "Tim"
age = 18;
console.log(`${name} ${age}`)</pre>
            </td>
        </tr>
    </table>
    <p>With the example above the same two variables are being declared and reassigned with every instance before being
        used, in this case to simply log out to the console, but this could well be call updating a database, for
        example. There is a clear repetition of code here and a clear pattern. We should avoid such repetition as this.
        If we see this occurring in our code, we should refactor our code.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="1ddabba2-50d3-4b20-a52d-f4513678d881"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let persons = [];

persons.push({
  name: "James",
  age: 23
});

persons.push({
  name: "Anna",
  age: 30
});

persons.push({
  name: "Tim",
  age: 18
});

persons.forEach((person) => console.log(`${person.name} ${person.age}`));</pre>
            </td>
        </tr>
    </table>
    <p>We could instead declare each instance of the repetition as an <strong>object literal</strong> representing each
        person and push them into a collection. Each person is now encapsulated by an object. We could have also
        declared each <strong>object literal</strong> directly into the array, either way would have helped create a
        more definitive pattern.</p>
    <p>We could also refactor this further to alternatively use either a <strong>constructor function</strong> or a
        <strong>class</strong>.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="56e51be0-a53a-460a-8277-8e5da72fc80c"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let persons = [];

let Person = function(name, age) {
  this.name = name;
  this.age = age;
}

persons.push(new Person("James", 23));
persons.push(new Person("Anna", 30));
persons.push(new Person("Tim", 18));

persons.forEach((person) => console.log(`${person.name} ${person.age}`));</pre>
            </td>
        </tr>
    </table>
    <p>Now we have even more reduced code repetition and we do not need to manually type the <strong>object literal
        </strong>every time, but this solution would be more performance intensive on a larger scale because we are
        creating an object by calling a function for every instance.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="ab7649c9-5138-4076-8f3c-d6b29bf17ccc"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let persons = [];

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

persons.push(new Person("James", 23));
persons.push(new Person("Anna", 30));
persons.push(new Person("Tim", 18));

persons.forEach((person) => console.log(`${person.name} ${person.age}`));</pre>
            </td>
        </tr>
    </table>
    <p>Now using a <strong>class</strong> this reads more like a traditional object oriented approach, but is
        effectively the same as the <strong>constructor function</strong> example.</p>
    <p><strong>Constructor functions</strong>, <strong>object literals</strong> and <strong>classes
        </strong>help<strong> </strong>save space, eliminate variable repetition and also have great benefits when it
        comes to inheritance and <strong>The SOLID Principles</strong>, covered later in this document.</p>
    <h1>4. Formatting, braces and spaces</h1>
    <p>The preferred pattern in JavaScript is to have the opening brace inline with the declaration, preceded with a
        space and the closing brace on the following line, unlike some languages such as C#.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8271a931-2aec-45d0-8326-f22bc7728616"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>function myFunction() 
{

}

function myFunction() {  }</pre>
            </td>
        </tr>
    </table>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="ecf1583b-5dfa-41b6-8709-5c8166491e17"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>function myFunction() {

}</pre>
            </td>
        </tr>
    </table>
    <p>This applies to all usages of braces, whether that be JSON, object literals, <em>if</em> statements, function
        declarations, etc.</p>
    <p>All control structures should use braces even though they are not necessary. This makes the intended execution
        clear:</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="25a74a6c-4afe-4156-b823-bec4f0baf0b7"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>if (valid === true)
  doThis();</pre>
            </td>
        </tr>
    </table>
    <p>An indentation is all that stands between semantic code and non-semantic code, which would not run as intended
        and also cause an error if the indentation was incorrect. </p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="52529f8c-6e7e-450d-8ff7-006ac5563353"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>if (valid === true) {
    doSomething();
}</pre>
            </td>
        </tr>
    </table>
    <p>This is considered safer and clearer to read. Not only do we have the indentation identifying the code to be
        executed, we also have the braces offering safety and encapsulation.</p>
    <h1>5. Declarations</h1>
    <p>Variable declarations in JavaScript as of this writing can be made using three different keywords,
        <em><strong>var</strong></em>, <em><strong>let</strong></em> and <em><strong>const</strong></em>.</p>
    <p>Each have different behaviours and we should use them as required. It is not a case of simply using
        <em><strong>let</strong></em> instead of <em><strong>var</strong></em>. There is good reason to use
        <em><strong>let</strong></em> instead of <em><strong>var</strong></em> as long as the scoping behaviour meets
        your needs.</p>
    <p><em><strong>let</strong></em> and <em><strong>const</strong></em> protect against re-declaration, with
        <em><strong>let</strong></em> allowing re-assignment and <em><strong>const</strong></em> not allowing
        re-assignment. This makes using <em><strong>let</strong></em> and <em><strong>const</strong></em> safer than
        always using <em><strong>var</strong></em>, which can be re-declared and re-assigned.</p>
    <p>*Please note, currently <em><strong>let </strong></em>and <em><strong>const </strong></em>require transpilation
        to work in older browsers such as IE11. This process will also catch any attempts to try and re-declare with
        <em><strong>let</strong></em> and <em><strong>const </strong></em>and re-assignment of<em><strong>
                const.</strong></em></p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="9507d4a1-5512-460f-be11-cc941002b669"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var thresholdOfUsers = 10;
var thresholdOfUsers = 30;</pre>
            </td>
        </tr>
    </table>
    <p>Drawing on a previous example. Here <em><strong>var</strong></em> is allowing us to re-declare a variable, there
        is nothing stopping this from happening, meaning context and value could be changed at any point during a
        program. Imagine a scenario where two developers are working on the same application, in the same scope but in
        separate scripts and they both declare variables with identical names in the global scope. This is a problem.
    </p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8cda608c-879e-47ca-b066-209b0d587112"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const THRESHOLD_OF_USERS = 10;</pre>
            </td>
        </tr>
    </table>
    <p>The keyword <em><strong>const</strong></em> protects against re-declaration and re-assignment.</p>
    <p>If the intention is to not re-declare, but to re-assign, we can use <em><strong>let</strong></em>. This means we
        cannot re-declare the same exact variable, but we can change its value.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="feac53b3-4561-468f-ad26-dda163f346fe"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var THRESHOLD_OF_USERS = 10;
var numberOfUsers = 11;
var isThresholdMet = false;

var THRESHOLD_OF_USERS = 11; // Within the same global scope, there is nothing stopping this from happening.

if (numberOfUsers > THRESHOLD_OF_USERS) {
  isThresholdMet = true;
  numberOfUsers--;
}</pre>
            </td>
        </tr>
    </table>
    <p>Here the re-declaration of <code>THRESHOLD_OF_USERS</code> means that our<em> if</em> statement will fail to
        catch the scenario.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="6c25bd66-e01b-43ad-8129-f2c00ced39b7"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const THRESHOLD_OF_USERS = 10;
let numberOfUsers = 11;
let isThresholdMet = false;

if (numberOfUsers > THRESHOLD_OF_USERS) {
  isThresholdMet = true;
  numberOfUsers--;
}</pre>
            </td>
        </tr>
    </table>
    <p><span class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">Here we make use of
        </span><em><strong><span class="inline-comment-marker"
                    data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">const</span></strong></em><span
            class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6"> for a value that will not
            change, and we can re-assign values where we have used </span><em><strong><span
                    class="inline-comment-marker"
                    data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">let</span></strong></em><span
            class="inline-comment-marker" data-ref="f737a2da-3109-4758-ac8e-2c708fbb06c6">. The above code will not
            exceed the threshold and demonstrates a scenario where you may want to intentionally re-assign.</span></p>
    <p>We should not be delimiting variable declarations with a comma. This can make code tricky to read and hard to
        debug.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="90b58097-4870-48bd-971b-03b779316925"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let make = "Ford",
    color = "Blue",
    isHybrid = false;</pre>
            </td>
        </tr>
    </table>
    <p>We now cannot debug these declarations per line, it is also easy to miss read these declarations as global
        declarations without the use of <em><strong>var</strong></em>, <em><strong>let </strong></em>or
        <em><strong>const</strong></em>, when they are in fact, block level declarations in a local scope. This also
        makes it hard to make use of the various different keywords <em><strong>var</strong></em>, <em><strong>let
            </strong></em>and <em><strong>const</strong></em> as necessary, they do not all behave in the same way.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="737b86a4-2169-4b0e-85cf-e89b67dd73c2"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let make = "Ford";
let color = "Blue";
let isHybrid = false;</pre>
            </td>
        </tr>
    </table>
    <p>We could now debug each of these declarations per line if needed, also it is very clear each line is being
        declared with the keyword - <em><strong>let</strong></em>.</p>
    <p>When declaring a complex string, we should be using template literals instead of using the
        <em><strong>+</strong></em> operator to concatenate multiple strings together. This will make for much clearer
        string declarations and are easier to read and code.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="720e9227-1812-496d-bd79-37a08319f1a4"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let name = "Anna";
let age = 40;
let description = name + " is " + age + " years old.";
console.log(description);</pre>
            </td>
        </tr>
    </table>
    <p>We have to open and close each string and concatenate them together using the <em><strong>+</strong></em>
        operator. This is a very manual way to code, especially at length, when considering full sentences for feedback
        in a UI, for example.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="959ede7d-7b10-44b9-921a-49342d2f6fa9"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let name = "Anna";
let age = 40;
let description = `${name} is ${age} years old.`;
console.log(description);</pre>
            </td>
        </tr>
    </table>
    <p>This now reads much clearer and is easier to code. We do not need to open and close each string, we use a single
        template literal and populate it with the declared variables above. We should use template literals where
        possible.</p>
    <h1>6. Scoping</h1>
    <p>Understanding scoping in JavaScript is incredibly important. There are two main scopes to consider:</p>
    <ul>
        <li>
            <p>The Global Scope</p>
        </li>
        <li>
            <p>The Local Scope (Block level scope)</p>
        </li>
    </ul>
    <p>In the instance of the web the <strong>Global Scope</strong> is the Window object. So if you are to declare a
        variable at <strong>Global Scope</strong> it will belong to the Window object. We should avoid setting Global
        variables at all costs. The reason for this is because in JavaScript it is very easy to re-declare a variable of
        the same name in the <strong>Global Scope</strong>, changing the context of the variable entirely. You may also
        alter a global declaration from any <strong>Local Scope</strong>. This is known as variable shadowing, we must
        protect our code against this scenario and we can do this by avoiding global declarations.</p>
    <p>The <strong>Local Scope</strong> is a more manageable scope and gives us protection against variable shadowing.
        Declarations within a <strong>Local Scope</strong> cannot be altered from outside of that scope, in effect they
        become “private”.</p>
    <p>This is similar to Access Modifiers in C#, but we achieve it in a different way with JavaScript:</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="15808996-48e2-4912-82c0-781abbd8cb27"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>function myFunction() {
    console.log("myFunction in Global Scope 1");
}
myFunction();

function myFunction() {
    console.log("myFunction in Global Scope 2");
}
myFunction();</pre>
            </td>
        </tr>
    </table>
    <p>The above code will output “<code>myFunction in Global Scope 2</code>” twice, because the method is declared
        twice within the same <strong>Global Scope</strong>. This results in “shadowing”. Imagine if these declarations
        existed in separate scripts, but are loaded onto the same <strong>Global Scope</strong>. They would clash, and
        the last declaration of the method would override the first.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8b3a6f65-be7b-4ea5-9353-2e99847876cd"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>(function() {
  function myFunction() {
    console.log("Local Scope");
  }
  myFunction();
})();

function myFunction() {
  console.log("Global Scope");
}
myFunction();</pre>
            </td>
        </tr>
    </table>
    <p>This would ensure we have two separate declarations of the method myFunction, resulting in both methods being run
        individually. The output in this case is “<code>Local Scope</code>” “<code>Global Scope</code>”.</p>
    <h1>7. Closures</h1>
    <p>A <em><strong>Closure </strong></em>is the encasing of a function together with references to its outer state,
        created at the point of definition. A closure gives you access to an outer functions scope and state (the
        Lexical environment) from the inner function.</p>
    <p><em>“A closure is the combination of a function and the lexical environment within which that function was
            declared. This environment consists of any local variables that were in-scope at the time the closure was
            created” </em><a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"><em>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures</em></a>
    </p>
    <p>You should use <em><strong>Closures </strong></em>to emulate private variables where necessary. In a scenario
        where you want to protect a state a function will run against, we should use <em><strong>Closures</strong></em>.
    </p>
    <p><em><strong>Closures </strong></em>are also key for managing the global namespace, and again we should consider
        them where possible.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="563cc86e-3151-4ef7-aa01-f32391fc6777"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var increment = function(prop) {
    return !isNaN(prop) ? prop + 1 : 0;
}

var increment = function(prop) {
    return !isNaN(prop) ? prop + 2 : 0;
}

// Imagine the above methods are declared in seperate scripts, but in the same global scope.
// The context of the add method has changed. We may not be aware of the new definition.

// Now when we use the method, we are using the latter definition. 
// Not our intention.

increment(0); // This will return 2</pre>
            </td>
        </tr>
    </table>
    <p>This will return 2, as we have been able to change the definition of the method. This highlights the need for
        <em><strong>Closures </strong></em>and why they are necessary to help us manage the global namespace.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="57511ef4-4f65-43e4-8f20-7d09543df28f"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const methodFactory = function() {
    return function(prop) {
        return !isNaN(prop) ? prop + 1 : 0;
    }
}

let increment = methodFactory();

increment(0); // This will return 1</pre>
            </td>
        </tr>
    </table>
    <p>This will return 1 as intended. We cannot, in anyway change the definition of the nested “private” method. We
        also use the <em><strong>const</strong></em> keyword to protect our namespace definition.</p>
    <h2>7.1 The Module Pattern</h2>
    <p>A common type of closure is the <em><strong>Module Pattern</strong></em>. This offers encapsulation, a closed
        scope, cohesion and the ability to expose only the methods we wish to via an interface, we do this in the form
        of an object literal. Methods which are not exposed remain private.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="092340b8-47e7-4345-8061-13254c188bde"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>var module = {

    privateMethod: function() {

    },

    publicMethod: function() {

    }

};</pre>
            </td>
        </tr>
    </table>
    <p>The above would offer a namespace, but expose all methods. We also could not capture state, as it is not a
        closure.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8d8d9445-c19b-4908-a552-58fb95b8f580"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const module = (function() {

    const privateMethod = function() {

    }

    const publicMethod = function() {

    }

    return {
        publicMethod: publicMethod
    }

})();</pre>
            </td>
        </tr>
    </table>
    <p>The same code written using the <em><strong>Module Pattern</strong></em>. The anonymous function encapsulates the
        scope of the module and returns an object literal, exposing only the methods we would like to expose.</p>
    <h2>7.2 What is an AMD Module ?</h2>
    <p>An <strong>AMD</strong> module extends the standard <em><strong>Module Pattern</strong></em>, and is wrapped
        using the <em><strong>define()</strong> </em>function in conjunction with a loader such as
        <strong>Require.js</strong>, <strong>Browserify</strong><em><strong> </strong></em>or <strong>Webpack</strong>,
        among others,<em><strong> </strong></em>in order to load the module and any dependencies. <a
            href="https://requirejs.org/docs/whyamd.html">https://requirejs.org/docs/whyamd.html</a> </p>
    <h3>Example</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="511a0fcb-b74d-467e-ad1d-f127d662dfe1"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    const base = 0;

    const myMethod = function(prop) {
        return base + prop;
    }

    return {
        myMethod: myMethod
    };
});</pre>
            </td>
        </tr>
    </table>
    <p>We can now load this module via a module loader, meaning we can utilise dependency injection, allowing us to
        manage our dependencies more economically, instead of loading them all at once. </p>
    <h1>8. What is <em>this</em> in JavaScript ?</h1>
    <p>In JavaScript when we need to refer to the current context we will use the <em><strong>this
            </strong></em>keyword. It is common in a number of programming languages to use
        <em><strong>this</strong></em> for when you would like to refer to a property or method within the current
        context. Not so straightforward in JavaScript however, because the context is always changing depending on where
        and how the code has been executed.</p>
    <p>The key thing to remember with <em><strong>this </strong></em>and JavaScript is that it is <strong>relative to
            the current scope</strong>, whether that be <strong>Local Scope</strong> or <strong>Global Scope</strong>.
        Because there are multiple scopes in JavaScript, it is important we understand which
        <em><strong>this</strong></em> we are referring to. </p>
    <p>For example in terms of the web browser environment, using <em><strong>this</strong></em> in the <strong>Global
            Scope</strong> will refer to the Window object. But if we are to use <em><strong>this</strong></em> from
        within an event callback method, <em><strong>this</strong></em> will refer to the context of the event and not
        beyond.</p>
    <h2>8.1 Arrow functions and Lexical <em>this</em></h2>
    <p><strong>Arrow functions</strong>, Introduced with ES6, allow us to write shorter and cleaner code. But beyond
        their abbreviated syntax, the real power of arrow functions lies in their handling of
        <em><strong>this</strong></em>.</p>
    <p>“Before arrow functions, every new function defined its own <code>this</code> value based on how the function was
        called” <a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>
    </p>
    <p>It is possible to have access to the defining context from within a <strong>Local Scope</strong>, the defining
        context being that which defined the method and not the context of the method itself. This is known as
        <strong>Lexical</strong> <em><strong>this</strong></em>, and can be achieved with the use of <strong>arrow
            functions</strong>.</p>
    <p>Arrow functions allow access to the defining context, because there is no binding of <em><strong>this
            </strong></em>in <strong>arrow functions</strong>, unlike regular functions, which bind
        <em><strong>this</strong></em> to the context that called the function, whether that be Window, Document, Event
        etc.</p>
    <p>See the below example taken from the Mozilla JavaScript reference:</p>
    <p><a
            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>
    </p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="bf93e2cf-b026-44f0-846f-fe4eeccb4981"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>function Person() {
    var that = this;
    that.age = 0;

    setInterval(function growUp() {
        // The callback refers to the `that` variable of which
        // the value is the expected object.
        that.age++;
    }, 1000);
}

var person = new Person();</pre>
            </td>
        </tr>
    </table>
    <p>In order to get hold of <em><strong>this</strong></em> in the defining scope from the calling scope, we need to
        first declare <em><strong>this</strong></em> as a local variable within the defining scope. We can later then
        refer to <em><strong>this </strong></em>as <em><strong>that</strong></em> and be confident we know which
        <em><strong>this </strong></em>we are referring to. But this means mapping <em><strong>this </strong></em>to a
        new variable before the context changes. Imagine if you had many nested scopes, each with their own
        <em><strong>this</strong></em>.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="a554c009-868b-46f5-ae4b-250950b3d4e1"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>function Person() {
    this.age = 0;

    setInterval(() => {
        this.age++; // |this| properly refers to the Person object
    }, 1000);
}

var person = new Person();</pre>
            </td>
        </tr>
    </table>
    <p>Now that we are using an arrow function we are able to use plain old <em><strong>this</strong></em> in order to
        refer to the defining scope. This is because the arrow function has no <em><strong>this</strong></em> bound to
        it.</p>
    <p>It is very important to only use arrow functions if you intend the use of <em><strong>this</strong></em> to be
        handled in this way. Using arrow functions may not always result in the intended outcome, it might be that the
        handling of <em><strong>this </strong></em>in a more traditional method is better for your needs. Use arrow
        functions with caution, they are great but they have their purpose and are not always necessary, despite their
        nice syntax. We should use arrow methods when we require access to the defining scope.</p>
    <h1>9. Equality</h1>
    <p>Equality is very important due to the dynamic nature of JavaScript. We need to be confident when making
        comparisons that a value is what we expect it to be.</p>
    <p>When comparing a value against another using only a <strong>Reference Equality Operator (==/!=)</strong>,
        JavaScript will attempt to match the types of two values.<strong> </strong>But in doing this the value itself
        can change, meaning you are no longer comparing the original values. The values are coerced into something they
        are not.</p>
    <p>In other words, 0 is equal to ““ in JavaScript when comparing an integer to a string and only using a
        <strong>Reference Equality Operator (==/!=) </strong>because the empty string gets converted into a number, that
        number being a 0 by best match according to JavaScript. But a zero is not equal to an empty string!</p>
    <p>For this reason, <strong>we should always</strong> be using the <strong>Identity Equality Operator</strong>
        <strong>(===/!==)</strong> when comparing values in JavaScript. When using the <strong>Identity Equality
            Operator</strong> there is no type conversion and both values must be of the same type in order to be
        considered “equal”, so we can be confident they are indeed the same.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="63b241e9-cca1-4e82-b04a-b3126ea8e5a4"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>"" == 0; // this equals true.</pre>
            </td>
        </tr>
    </table>
    <p>This returns <em>true, </em>which is a real problem when trying to compare types. Imagine if we were to now
        perform a sum on a variable that is in fact equal to “” because we assume it to be a number after the above
        equation returns true ? We would get a NaN error!</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="d0e5b24b-012b-4cba-a5f0-f798c5772417"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>"" === 0; // this equals false, and so it should!</pre>
            </td>
        </tr>
    </table>
    <p>Now using the <strong>Identity Equality Operator</strong> we are able to not only be confident that these values
        do not match, but also their types are not the same either, so this will now return false. An equation such as 0
        === 0 would return true, this is what we are checking for.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="b61ee048-d06e-4f3e-a400-f8866f6311ea"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>"" != 0; // this would return false, meaning these are equal when they are not.</pre>
            </td>
        </tr>
    </table>
    <p>We can clearly see these values are not equal but the <strong>Reference Equality Operator</strong> is distorting
        our perception of what is true or false.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="74a18c05-e9e4-49e6-bbcf-90b5323fbbd9"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>"" !== 0; // this would return true, as it should because they are not equal.</pre>
            </td>
        </tr>
    </table>
    <p>We can now be confident that these values do not match by using the <strong>Identity Equality Operator</strong>.
    </p>
    <h2>9.1 Type Checking - Checking numbers with isNaN();</h2>
    <p>JavaScript has a great tool for checking if a value is a number - <em><strong>isNaN()</strong></em>. We should
        always use <em><strong>isNaN() </strong></em>where possible before attempting number equations. This will
        prevent us from getting <em><strong>NaN</strong></em><strong> </strong>errors when dealing with numbers.</p>
    <p>This is useful for when we are not checking for a particular numerical value but specifically the type and do not
        want to perform a <strong>typeof </strong>check, which we could do in order to check a value is a “number” but
        we would need to check this specifically ( <em>=== “number”</em>), <em><strong>isNaN();</strong></em> handles
        the type checking for us in an easy to use function.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="ac659065-5dbb-41f5-a8c0-ce1716496de9"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let valueA = "abc";
let valueB = 1;
let result = 0;

// First problem
result = valueA + valueB;
console.log(result);

// Second problem
result = valueA * valueB;
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <p>There are a couple of things you will notice here. <strong>The first</strong> <strong>problem</strong> being that
        instead of attempting a sum of two values, which was our intention, we have performed a string concatenation
        instead. JavaScript has coerced <em><strong>valueB</strong> </em>into being a string. <strong>The second
            problem</strong> is when we attempt to perform a more advanced equation, in this case with multiplication.
        This causes a <em><strong>NaN</strong></em><strong> </strong>error. This is because the types do not match and,
        we could have prevented this from occurring:</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="45e788fb-f64e-4f42-a9cc-c5a52200ea34"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let valueA = "abc";
let valueB = 1;
let result = 0;
if(!isNaN(valueA) &amp;&amp; !isNaN(valueB)) {
  result = valueA * valueB;
}
console.log(result);

valueA = 2;
valueB = 2;
if(!isNaN(valueA) &amp;&amp; !isNaN(valueB)) {
  result = valueA * valueB;
}
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <p>Notice how <em><strong>result </strong></em>is still just 0 for the first output. This is because we will only
        attempt to multiply these two values if they are both numbers. </p>
    <p>With our second pass, we have re-assigned <em><strong>valueA</strong></em> and <em><strong>valueB</strong></em>
        to indeed be numbers. Now running the same code, <em><strong>result </strong></em>returns 4 because
        <em><strong>isNaN()</strong></em><strong>;</strong> returned false.</p>
    <p>There is one important thing to always remember with <strong>isNaN(); </strong>It is checking if a
        <em><strong>NaN</strong></em><strong> </strong>error is returned from type checking a value. So in the above
        snippet we are checking that a <em><strong>NaN</strong></em><strong> </strong>error has <strong><u>NOT</u>
        </strong>occurred by using the <em><strong>!</strong> </em>operator (exclamation mark) to check the result is
        false. Keep this in mind when using <em><strong>isNaN();</strong></em></p>
    <h2>9.2 Type Checking - Checking for specific types with <em><strong>typeof</strong></em></h2>
    <p>Another very important tool when it comes to checking for types is the <em><strong>typeof</strong></em><strong>
        </strong>keyword. JavaScript is not strongly typed, we need to manually check for types if we want to be sure.
    </p>
    <p>We should be using <em><strong>typeof</strong></em> even if we are sure of a type, incase the context has been
        altered for example, or a value is <em><strong>undefined</strong></em>. This way our code will only run if the
        value is of the correct type. This offers protection against incorrect use.</p>
    <p><em><strong>typeof</strong></em> is best used in conjunction with an <em><strong>if</strong></em> statement and
        an <strong>Identity Equality Operator</strong>.</p>
    <p><em><strong>typeof </strong></em>will return a string representation of the type, so when testing for a type, it
        is important to know the string definition for each type:</p>
    <p>“undefined”</p>
    <p>“object”</p>
    <p>“boolean”</p>
    <p>“bigint”</p>
    <p>“string”</p>
    <p>“symbol”</p>
    <p>“function”</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="43e8b879-47b7-4249-b780-552b56e5936d"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let callback = true;

let get = (callback) => {

    if (callback) {
        callback();
    }
}

get(callback);  </pre>
            </td>
        </tr>
    </table>
    <p>This will give an error “<em><strong>callback is not a function</strong></em>”. This is because we loosely
        checked the callback parameter and assumed that whatever is being passed in is always going to be a function and
        something that we can run. But in this case, it is not a function, so we have a problem. What we need to do, is
        check specifically if the parameter is a function before attempting to handle it as a function.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="917ccbdf-7fe9-4749-bcfd-e6dd09092f49"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let callback = true;

let get = (callback) => {

    if (typeof callback === "function") {
        callback();
    }
}

get(callback);</pre>
            </td>
        </tr>
    </table>
    <p>This will now not error, as we are checking what type the callback parameter is first. If we were to pass in a
        callback function, then the function would run. This is also known as a <strong>higher order function</strong>
        or <strong>delegate function</strong>.</p>
    <h3>Example</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="7c48b088-6494-405f-9474-0a90a4c68e0a"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let callback = () => console.log("This is our callback");

let get = (callback) => {

    if (typeof callback === "function") {
        callback();
    }
}

get(callback);</pre>
            </td>
        </tr>
    </table>
    <p>This will now run and we will also see an output in our developer console “<em>This is our callback</em>”.</p>
    <h1>10. What is <em>undefined</em> ? How to reliably test for it ?</h1>
    <p><em><strong>Undefined</strong></em> is a primitive type in JavaScript, along with Boolean, Number, String,
        Symbol, Null etc. </p>
    <p>We can think of <em><strong>undefined</strong></em> as the default return type in JavaScript for an object or
        variable that has not yet been initialised. If something is not defined, it is therefore undefined.</p>
    <p>It is common, when viewing an <em><strong>undefined</strong></em> JavaScript error in the console to see one of
        the following:</p>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="da2a51ae-caec-4e46-8a28-7c620f220297"
        data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGV9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>TypeError: 'undefined' is not a function
TypeError: Cannot read property '&lt;prop-name>' of undefined</pre>
            </td>
        </tr>
    </table>
    <p>Whilst it is best practice to always initialise a variable or object first with a default value of the correct
        type, sometimes this is out of our control. This is when we need to defend against
        <em><strong>undefined</strong></em>.</p>
    <p>We can reliably test for <em><strong>undefined</strong></em> by using <em><strong>typeof</strong></em>.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="cb931909-9dac-4338-88fb-e5873892dd1d"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let myVariable;
console.log(myVariable);</pre>
            </td>
        </tr>
    </table>
    <p>This variable is not initialised with any value. So when we try and use it, we see that it is
        <em><strong>undefined</strong></em>.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="734b4395-59c8-4f53-8003-89ada85025de"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let myVariable;
if (typeof myVariable !== "undefined") {
    console.log(myVariable);
}</pre>
            </td>
        </tr>
    </table>
    <p>By using <em><strong>typeof</strong></em> we can check to see if a variable returns the string representation of
        the primitive type -<em><strong>undefined. </strong></em>By doing this check, the code will not run if the
        variable is <em><strong>undefined</strong></em>. If our variable is initialised however, then the above code
        would run without error.</p>
    <h3>Example</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="25db8e7d-bc32-426e-bfe5-4c5b8a24ec0a"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let myVariable = 0;
if (typeof myVariable !== "undefined") {
    console.log(myVariable);
}</pre>
            </td>
        </tr>
    </table>
    <p>In this example we see how initialising with a default value allows the above check to pass and the code to run.
    </p>
    <h2>10.1 Handling <em>undefined</em></h2>
    <p>It is important to always protect against the occurrence of <em><strong>undefined</strong></em> in our code, such
        an error can cause the entire script to freeze. We can do this by making sure we always initialise our
        definitions before using them.</p>
    <p>This can be done both in a method signature and within our closures/methods at the point of definition.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="63972f7f-87c5-4cff-b009-6d16ad5c9abd"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let price;
price.toFixed(2);</pre>
            </td>
        </tr>
    </table>
    <p>You will notice when running this code we get an error: <em><strong>TypeError: Cannot read property 'toFixed' of
                undefined</strong></em>. This is because, although we have defined our variable, we have not initialised
        it with any value.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="6d4e3c0b-ffca-4d01-9aa0-8fbf65337f06"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let price = 0;
price.toFixed(2);</pre>
            </td>
        </tr>
    </table>
    <p>By assigning the variable with an initial value it is no longer <em><strong>undefined</strong></em> and when we
        want to act on it, we can, without getting an error.</p>
    <p>This can be more common in a method signature, with the assumption that something being passed in is safe to use
        straight away, when it is not:</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="712fa726-70ce-48c5-90bb-2fbd1d43e346"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let myMethod = (price) => {
  return price.toFixed(2);
}
myMethod();</pre>
            </td>
        </tr>
    </table>
    <p>This will also error with the same response as the first problem <em><strong>TypeError: Cannot read property
                'toFixed' of undefined</strong></em>.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="48b07573-4c22-4cf5-afd4-6c27833d7ade"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let myMethod = (price = 0) => {
  return price.toFixed(2);
}
myMethod();</pre>
            </td>
        </tr>
    </table>
    <p>Now with a default value assigned in the method signature, the above method will not error.</p>
    <p>It is however safer to combine both a default value with an undefined <em><strong>typeof</strong></em> check in
        the same method. This will give maximum protection against an undefined value.</p>
    <h3>Example</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="d84d90d6-f2b5-4269-9579-6ea27f964449"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let myMethod = (price = 0) => {
  if (typeof price !== "undefined") {
    price = price.toFixed(2);
  }
  return price;
}
myMethod();</pre>
            </td>
        </tr>
    </table>
    <h1>11. Performance</h1>
    <p>Accessing the DOM is something very common in JavaScript, due to the position it tends to sit within the stack.
        For the most part, accessing the DOM for a single element is no big deal. But if working on a large application,
        with the DOM populated with many HTML elements, it is very important to understand what is happening every time
        you get or update an element.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8aa2d564-ba83-49e7-878d-840b36ad8558"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>document.querySelector("#elementId").innerText = "Some text";

document.getElementById("elementId").setAttribute("class", "someClass");</pre>
            </td>
        </tr>
    </table>
    <p>The above will perform a search of the whole DOM as the HTML is parsed in order to find the elements that are
        being requested. For a single use, it can be argued storing the element before using it is of little benefit,
        but for multiple updates it is important to store the element first.</p>
    <p>We would not want to be calling any of the above methods thousands of times during an iteration for example. We
        would want to be using caching in order to store and access elements in memory, instead of physically accessing
        the DOM every time. </p>
    <p>To give this some context, such frameworks as React and Vue.js build up a “virtual DOM” cached in memory, which
        is always kept in sync with the physical DOM on screen by a process called “Reconciliation”, this helps a great
        deal to improve performance and is good evidence that caching DOM access is good practice and good for
        performance. See the React documentation for more detail on the “Virtual DOM” - <a
            href="https://reactjs.org/docs/faq-internals.html">https://reactjs.org/docs/faq-internals.html</a></p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="ed3eb478-4d35-473a-b997-6e5d28a1566c"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let element = document.getElementById("elementId");
element.innerText = "Some text";
element.setAttribute("class", "someClass");</pre>
            </td>
        </tr>
    </table>
    <p>Now we only access the physical element once, store it and then update it. Notice updating the stored element
        will also update the physical DOM due to the stored element being of <strong>reference type</strong>. This is
        because JavaScript, like other programming languages, also has <strong>reference</strong> types and
        <strong>value</strong> types.</p>
    <h2>11.1 Iteration and performance. Which to use ? (<em>for, while, forEach, map, filter, reduce</em>)</h2>
    <p>There are various ways we can loop in JavaScript, depending on what it is you want to do. Some methods are
        quicker than others and much more performant, again depending on the size of the iteration. </p>
    <h3>Big O Notation</h3>
    <p><strong>Big O</strong> is a great way to assess how expensive your program is. This may help decide which
        iteration method might fit best to maximise on performance. A great explanation of <strong>Big O</strong> in
        relation to JavaScript can be found here - <a
            href="https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835">https://medium.com/karuna-sehgal/a-simplified-explanation-of-the-big-o-notation-82523585e835</a>
    </p>
    <h3><em>map(), filter(), reduce(), forEach()</em></h3>
    <p>These looping method are all on the Array prototype, which means we can only use them directly on an array. They
        all require a <em><strong>higher order function</strong></em>, as they all take a single method as a parameter.
    </p>
    <p>The method passed is performed on every iteration, so be aware of this when using such array methods. Such
        methods are slow to run when considering a large number of iterations and are not particularly performant. They
        are good to use on small arrays and can really help reduce code, but we should not be using them for all
        scenarios, especially not because they read nicely.</p>
    <h3><em>for</em> and <em>while</em></h3>
    <p>These are the more traditional looping methods, and most common in programming languages. They are far more
        adaptive than the “ready made” Array looping methods in JavaScript and can be far more performant with a large
        number of iterations.</p>
    <p><em><strong>for</strong></em> looping is great for when you know your limit and <em><strong>while</strong></em>
        looping is best used when we want a loop to run until a given condition. </p>
    <p>We should be using the correct looping techniques for each given scenario.</p>
    <p>The code below demonstrates how certain looping techniques are not as good as others when it comes to
        performance:</p>
    <h3>Examples</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="ea4a2bd1-d70d-44fc-967e-6f1f3e1aba83"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>// Lets setup an example to loop against
let array = [];
let i = 0;

while(i &lt; 2000000){
    array.push(Math.random(5));
    i++;
}

let calc = (a) => a * 1000;
let getTime = () => new Date().getTime();
let timeDifference = (start, end) => end - start;

// Now lets run the below looping methods to see which is more performant.
let mapExample = () => {
    let start = getTime();
    array.map((item) => item = calc(item));
    let end = getTime();
    console.log(`Map example took: ${timeDifference(start,end)}`);
}

let forEachExample = () => {
    let start = getTime();
    array.forEach((item) => item = calc(item));
    let end = getTime();
    console.log(`ForEach example took: ${timeDifference(start,end)}`);
}

let forwardsForExample = () => {
    let start = getTime();
    for(let i = 0; i &lt; array.length; i++){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Forward for loop example took: ${timeDifference(start,end)}`);
}

let forwardsForCachingExample = () => {
    let start = getTime();
    let length = array.length;
    let i;
    for(i = 0; i &lt; length; i++){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Forward for loop, w/ cached length example took: ${timeDifference(start,end)}`);
}

let backwardsForExample = () => {
    let start = getTime();
    for(let i = array.length; i--;){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Backward for loop example took: ${timeDifference(start,end)}`);
}

let backwardsForCachingExample = () => {
    let start = getTime();
    let length = array.length;
    let i = length;
    for(i; i--;){
        array[i] = calc(array[i]);
    }
    let end = getTime();
    console.log(`Backward for loop example took: ${timeDifference(start,end)}`);
}

let whileExample = () => {
    let start = getTime();
    let i = 0;
    let length = array.length;
    while(i &lt; length) {
        array[i] = calc(array[i]);
        i++;
    }
    let end = getTime();
    console.log(`While loop example took: ${timeDifference(start,end)}`);
}

mapExample();
forEachExample();
forwardsForExample();
forwardsForCachingExample();
backwardsForExample();
backwardsForCachingExample();
whileExample();</pre>
            </td>
        </tr>
    </table>
    <p>We can clearly see from the resulting outputs after running this code which looping methods are more performant
        and which are better at handling a larger number of iterations. </p>
    <p>You will see something like:</p>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="5991f0c1-bd01-4e6e-9e97-acbaf2d0321f"
        data-macro-parameters="language=text" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9dGV4dH0&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>Map example took: 507
ForEach example took: 137
Forward for loop example took: 5
Forward for loop, w/ cached length example took: 5
Backward for loop example took: 7
Backward for loop example took: 5
While loop example took: 4</pre>
            </td>
        </tr>
    </table>
    <p>With the Array methods Array.<em><strong>map()</strong></em> and Array.<em><strong>forEach()</strong></em> being
        the slowest, especially Array.<em><strong>map()</strong></em>. Array.<em><strong>reduce()</strong></em> and
        Array.<em><strong>filter()</strong></em> have different uses to what we are doing here, but both are equally as
        slow as Array.<em><strong>map() </strong></em>depending on the method being passed and what <em>it</em> is doing
        of course.</p>
    <p>The various iterations of <em><strong>for </strong></em>looping are much alike, but there are small performance
        gains to be made with these techniques. Notice we store both the index variable and the length of the array
        before iteration. We should be storing both in memory and not declaring them for every iteration.</p>
    <p>Both <em><strong>for</strong></em> and <em><strong>while</strong></em> come out on top when compared to other
        looping techniques.</p>
    <h1>12. How can we apply the SOLID principles to JavaScript ?</h1>
    <p><strong>The S.O.L.I.D Principles</strong> are a set of principles that traditionally apply to classic object
        oriented programming languages. Whilst JavaScript is not solely an object oriented language and is very dynamic
        in nature, consisting of multiple paradigms, we can apply the <strong>SOLID principles</strong> for the most
        part.</p>
    <p>Arguably there are a number of ways the <strong>SOLID principles</strong> can be interpreted in JavaScript,
        especially when it comes to inheritance, but we will focus on solutions already looked at in this document. We
        have already been following the <strong>SOLID principles</strong> to some degree.</p>
    <h2>12.1 S - Single Responsibility Principle</h2>
    <p><strong>The Single Responsibility Principle</strong> aims to have a single concern for any given piece of code.
        We should not couple logic and responsibilities together, we should separate out the logic and responsibilities.
        Smaller, manageable methods will allow for single responsibility, which in turn will allow for effective unit
        testing.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="0850fd5c-dfcb-40c6-a47c-8d9b7e3962db"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const doMath = (firstNumber = 0, secondNumber = 0, operator = "+") => {
    let result = 0;
    if(operator === "+") {
        result = firstNumber + secondNumber;
    } else if (operator === "-") {
        result = firstNumber - secondNumber;
    } else if (operator === "x") {
        result = firstNumber * secondNumber;
    }
    return result;
}

let result = doMath(1, 2, "+");
console.log(result);

result = doMath(2, 1, "-");
console.log(result);

result = doMath(1, 2, "x");
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <p>This example breaks a number of the <strong>SOLID principles</strong>. It is not following single responsibility
        because a single method is being used for many concerns. This method would only grow and become unmanageable
        with the more logic we give it.</p>
    <p>We can address this by having a dedicated method for each task:</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="a2e83a63-d78e-4c96-a87d-bd3d5578ef5a"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

let result = add(1, 2);
console.log(result);

result = subtract(2, 1);
console.log(result);

result = multiply(1, 2);
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <p>Instead of having a single method that has many responsibilities we can have individual methods, each with a
        single responsibility. There is no logic involved to decide which method to use and we can be clear which method
        we would like to use in each case. Now we could unit test each method individually, for example, making this
        much more manageable.</p>
    <h2>12.2 O - Open Closed Principle</h2>
    <p><strong>The Open Closed Principle</strong> - Open for extension, closed for modification. We need to write our
        code in such a way that we can extend it, without needing to change existing code.</p>
    <p>We will go back to the bad example used for <strong>The Single Responsibility Principle</strong>.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="0dadf08e-c8fd-45f2-a361-b02a6e3e5c1b"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const doMath = (firstNumber = 0, secondNumber = 0, operator = "+") => {
    let result = 0;
    if(operator === "+") {
        result = firstNumber + secondNumber;
    } else if (operator === "-") {
        result = firstNumber - secondNumber;
    } else if (operator === "x") {
        result = firstNumber * secondNumber;
    } else if (operator === "/") {
        result = firstNumber / secondNumber;
    }
    return result;
}

let result = doMath(1, 2, "+");
console.log(result);

result = doMath(2, 1, "-");
console.log(result);

result = doMath(1, 2, "x");
console.log(result);

result = doMath(6, 2, "/");
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <p>As it stands, we could not extend the functionality of our method without changing the existing code. This would
        mean all logic surrounding this method would need to be retested, even if we only changed a single character or
        line or added a new <em><strong>if </strong></em>clause. We can improve our refactor for the <strong>Single
            Responsibility Principle</strong> even further to now cater for <strong>The Open Closed Principle</strong>.
    </p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="21d05ec0-8d7d-4721-aa51-eaeefd7c3918"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let math = (function() {
    
    const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    return {
        add: add,
        subtract: subtract,
        multiply: multiply
    }
})();

math.divide = (firstNumber = 0, secondNumber = 0) => firstNumber / secondNumber;

let result = math.add(1, 2);
console.log(result);

result = math.subtract(2, 1);
console.log(result);

result = math.multiply(1, 2);
console.log(result);

result = math.divide(6, 2);
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <p>It is now possible to extend this solution. Using the <strong>module pattern</strong>, we can now add additional
        methods at will, without changing any original code in the module. But we should keep in mind that adding
        methods this way will always expose them via the modules interface.</p>
    <p>We can achieve similar with <strong>prototypal inheritance</strong>, but with the added benefit of being able to
        pass the same behaviour to <strong>any</strong> derived object:</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="1696143a-bdd1-4148-9670-b4857bb182a7"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>const MathFactory = function() {
    
    this.add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    this.subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    this.multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;
  }

let mathUtil = new MathFactory();

MathFactory.prototype.divide = (firstNumber = 0, secondNumber = 0) => firstNumber / secondNumber;

let result = mathUtil.add(1, 2);
console.log(result);

result = mathUtil.subtract(2, 1);
console.log(result);

result = mathUtil.multiply(1, 2);
console.log(result);

result = mathUtil.divide(6, 2);
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <p>Notice that we have instantiated the MathFactory and then modified the base, which has used prototypal
        inheritance to modify all derived instances. This would not break the <strong>The Open Closed Principle</strong>
        and also not break the <strong>Liskov Substitution Principle</strong>, if there were multiple instances of the
        MathFactory, they would all still be interchangeable.</p>
    <p>A solution now using ES6 Classes:</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="64fc3349-e8b6-443f-bab9-b9b07d378757"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class MathFactory {
    
    add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;
}

let mathUtil = new MathFactory();

MathFactory.prototype.divide = (firstNumber = 0, secondNumber = 0) => firstNumber / secondNumber;

let result = mathUtil.add(1, 2);
console.log(result);

result = mathUtil.subtract(2, 1);
console.log(result);

result = mathUtil.multiply(1, 2);
console.log(result);

result = mathUtil.divide(6, 2);
console.log(result);</pre>
            </td>
        </tr>
    </table>
    <h2>12.3 L - Liskov Substitution Principle</h2>
    <p><strong>The Liskov Substitution Principle </strong>states that any derived object should be substitutable for the
        base it was derived from without breaking the application. </p>
    <p>Whilst this may not seem very relevant to a simple JavaScript application, not requiring instances and
        inheritance, we should still understand it. </p>
    <p>We could apply this way of thinking to any object composition, to allow for swappable implementation, even with
        the <strong>module pattern</strong> and its object literal interface.</p>
    <p>As an example of this in JavaScript we can look to the previous. We could have added a new method without using
        prototypal inheritance by adding it directly to the instance. The problem with this is that the instances would
        now differ from the base, and therefore would not be interchangeable. This would break the <strong>Liskov
            Substitution Principle</strong>.</p>
    <p>Let's try and use another example to demonstrate the problem further.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="7c5f7507-9a91-4e2e-bd99-369d8f938282"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class Dog {
    walk() {
        console.log("The Dog is walking.");
    }
    sleep() {
        console.log("The Dog is sleeping.");
    }
    bark() {
        console.log("The Dog is barking.");
    }
}

class Cat extends Dog {
    walk() {
        console.log("The Cat is walking.");
    }
    sleep() {
        console.log("The Cat is sleeping.");
    }
    bark() {
        throw new Error("Cats do not bark");
    }
    meow(){
        console.log("The Cat is meowing.");
    }
}

let dog = new Dog();
let cat = new Cat();
let animals = [dog, cat];

animals.forEach((animal) => {
    animal.bark();
});</pre>
            </td>
        </tr>
    </table>
    <p>This will cause an error: <code>Error: Cats do not bark</code> This has happened because, while both Dog and Cat
        have a lot in common (eat, sleep, walk, etc), they do not make the same noises. So in an attempt to make the Dog
        “fit” into the Cat type, we have amended Cat, we have been lazy and tried to extend Dog. But in doing this it
        means the subclass cannot be substituted for the superclass (base) in the existing application. It is also
        confusing to read, as Cats do not bark, neither do all animals walk.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="fe76cdaf-1f1d-48a4-a284-a7a4347c0a98"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class Animal {
    move() {
        console.log("The Animal is moving.");
    }
    sleep() {
        console.log("The Animal is sleeping.");
    }
    communicate() {
        console.log("The Animal is communicating.");
    }
}

class Dog extends Animal {
    move() {
        console.log("The Dog is walking.");
    }
    sleep() {
        console.log("The Dog is sleeping.");
    }
    communicate() {
        console.log("The Dog is barking.")
    }
}

class Cat extends Animal {
    move() {
        console.log("The Cat is walking.");
    }
    sleep() {
        console.log("The Cat is sleeping.");
    }
    communicate() {
        console.log("The Cat is meowing.")
    }
}

let dog = new Dog();
let cat = new Cat();
let animals = [dog, cat];

animals.forEach((animal) => {
    animal.communicate();
});</pre>
            </td>
        </tr>
    </table>
    <p>Now we have a higher class to inherit from - Animal, which is more generic and has attributes in common with both
        Cat and Dog. We could swap either of the Dog or Cat for the base of Animal and our code would still execute
        without error. It is important to think ahead like this when designing any object oriented application, creating
        the correct hierarchy early on will ensure there is room for extension, not only ensuring we abide by the
        <strong>Liskov Substitution Principle</strong>, but also the <strong>Open Closed Principle</strong> and the
        <strong>Single Responsibility Principle</strong> too.</p>
    <h2>12.4 I - Interface Segregation Principle</h2>
    <p><strong>The Interface Segregation Principle </strong>aims to separate methods into cohesive groups of methods,
        with each method being related to a specific task. We should not be grouping methods together that have very
        little relevance to each other. For example, if there is a generic, large module or class, with many unrelated
        methods, that is being injected all over our application, we should not keep adding to that same module for the
        sake of convenience. We should instead create a new module or class, who’s <strong><u>only</u></strong> concern
        is of a specific task or related tasks.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8deb689a-196d-464b-b70f-63a99b07a09c"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let mathFactory = (function() {
    const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    // lets add a new method because an existing method does not already do what we want
    const greetingMessage = (name) => console.log(`Hello ${name}`);

    return {
        add: add,
        subtract: subtract,
        multiply: multiply,
        greetingMessage: greetingMessage

    }
})();

mathFactory.greetingMessage("James");</pre>
            </td>
        </tr>
    </table>
    <p>Here we would have broken a number of the <strong>SOLID principles</strong>, one of which is the
        <strong>Interface Segregation Principle</strong>. We have appended a method, who’s concern has no relation to
        the other methods in the module. This module’s concern is to work with numbers, not print greeting messages. If
        this module is already being consumed by our calling code, it might be quicker and easier to just add a method
        to the existing module, but this would be breaking the <strong>Interface Segregation Principle</strong>.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8c27ca84-8726-43ec-8fd0-821e98aa9700"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let mathFactory = (function() {
    const add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    const subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    const multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    return {
        add: add,
        subtract: subtract,
        multiply: multiply,
    }
})();

// Make a new module
let greetingFactory = (function() {

    const greet = (name) => console.log(`Hello ${name}`);

    return {
        greet: greet
    }
})();

greetingFactory.greet("James");</pre>
            </td>
        </tr>
    </table>
    <p>Now we have a dedicated module that will only include methods that relate to greeting messages. This provides
        good cohesion and divides concerns. This will help keep modules small and manageable. We could then inject this
        new module into the application only where it is needed.</p>
    <p>We can also express the same issue as a class:</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="b541fcf1-ad00-4fa8-bd2d-8104dfde1585"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class MathFactory {
    add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;

    greetingMessage = (name) => console.log(`Hello ${name}`);
}

let mathUtil = new MathFactory();

mathUtil.greetingMessage("James");</pre>
            </td>
        </tr>
    </table>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="83e113cd-53e2-44ef-ba26-baac1c2401ac"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class MathFactory {
    add = (firstNumber = 0, secondNumber = 0) => firstNumber + secondNumber;

    subtract = (firstNumber = 0, secondNumber = 0) => firstNumber - secondNumber;

    multiply = (firstNumber = 0, secondNumber = 0) => firstNumber * secondNumber;
}

class GreetingFactory {
    greet = (name) => console.log(`Hello ${name}`);
}

let greetingUtil = new GreetingFactory();
greetingUtil.greet("James");</pre>
            </td>
        </tr>
    </table>
    <h2>12.5 D - Dependency Inversion Principle</h2>
    <p><strong>The Dependency Inversion Principle</strong> aims to move dependency up the chain of command. The idea is
        to loosely couple our methods, modules and classes with their dependencies.</p>
    <p>An obvious example of this is with server requests and nested callbacks, common in an AJAX request.</p>
    <p>One way of achieving <strong>dependency inversion</strong> in JavaScript is by thinking of our functions as
        <strong>higher order functions</strong> and <strong>lower order functions</strong>. We can invert dependency by
        replacing <strong>lower order functions</strong> with <strong>higher order functions</strong>.</p>
    <p>Another way of inverting dependency is to program more sequentially, instead of nesting code. Nested code can
        lead to dependencies being buried, this is what we need to look out for when identifying <strong>lower order
            functions</strong>. If we use <strong>promises</strong>, for example, we can “wait” for a task to complete
        before moving on, or while performing some other task, removing the need to nest code. Making asynchronous code
        appear synchronous. It is important to understand JavaScript can handle multiple threads, we should take
        advantage of this.</p>
    <p>“<em>A promise is an object that may produce a single value some time in the future</em>” - See here for a great
        read on promises in JavaScript - <a
            href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261</a>
    </p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="f1b90f4b-88ea-4f89-83fa-8841c66a14da"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let userDataFactory = (function() {
    const get = () => {
        // this object would typically come from an API call
        let data =  {
            name: "Anna",
            colour: "Blue"
        }
        printFavouriteColour(data);
    }
    const printFavouriteColour = (data) => console.log(`Hello ${data.name}, your favourite colour is ${data.colour}`);
    return {
        get: get
    }
})();

userDataFactory.get();</pre>
            </td>
        </tr>
    </table>
    <p>With this example we are breaking the <strong>Dependency Inversion Principle</strong>. We have dedicated methods
        to both <em><strong>get</strong></em> and <strong>printFavouriteColour</strong>, but the
        <em><strong>get</strong></em> method is always dependent on the <em><strong>printFavouriteColour</strong></em>
        method, this is essentially the callback method. We would need an entirely new <em><strong>get</strong></em>
        method, duplicating code, in order to do some other task once we have the data.</p>
    <p>Instead we could move the depending code up the chain and pass it down as a <strong>higher order
            function</strong>. We could then always call the <em><strong>get</strong> </em>method<em> </em>just to get
        the data and not assume we always want to print out the favourite colour of the user.</p>
    <p>Because JavaScript is asynchronous by nature, it may be common to see nested callbacks. Similar to the above, in
        order to try and handle timing issues, we could even nest a couple of callbacks. This can get very unmanageable,
        very quickly and is referred to as “Callback hell” and “dependency hell”.</p>
    <p>For example, if we needed to make another call to the server to get more data, but we needed to first wait for
        our user data to arrive before making the second call. How could we handle that without nesting methods ?</p>
    <p>A possible solution is using<strong> </strong><em><strong>async await </strong></em>(a promise)<strong>
        </strong>as a means of allowing our code to get the data first before doing anything with it. We can then
        program sequentially, instead of nesting callbacks or dependencies.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="13fd5da5-f4cf-4539-b286-a103de314a5a"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let userDataFactory = (function() {
    const get = async () => {
        // this object would typically come from an API call
        let data =  {
            name: "Anna",
            colour: "Blue"
        }
        return data;
    }
    const printFavouriteColour = (data) => console.log(`Hello ${data.name}, your favourite colour is ${data.colour}`);
    const printName = (data) => console.log(`Hello ${data.name}`);
    return {
        get: get,
        printFavouriteColour: printFavouriteColour,
        printName: printName
    }
})();

(async() => {
    let user = await userDataFactory.get();
    userDataFactory.printName(user);
    userDataFactory.printFavouriteColour(user);
})();</pre>
            </td>
        </tr>
    </table>
    <p>Now the same <em>get</em> method can be used again and again. There is no tightly coupled dependency in our code,
        we can determine what we would like to do once we have the data, we could even make another call to a different
        service and wait for both calls to complete, while doing some other task asynchronously. This now makes the
        <em><strong>get</strong></em> method very flexible and reusable. It has a single responsibility and is not
        tightly coupled to a behaviour or dependency.</p>
    <p>A word on <em><strong>async await </strong></em>and <em><strong>promises</strong></em> - please consider browser
        compatibility before using this syntax and <strong>promises</strong> in general.</p>
    <p>Now another solution using <strong>higher order functions</strong> to pass down the logic to use once we have the
        data<strong>:</strong></p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="9a617561-76af-4455-a89a-dd2da20c9885"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let userDataFactory = (function() {
    const get = (callback) => {
        // this object would typically come from an API call
        let data =  {
            name: "Anna",
            colour: "Blue"
        }
        if(typeof callback === "function") {
            callback(data);
        }
    }
    const printFavouriteColour = (data) => console.log(`Hello ${data.name}, your favourite colour is ${data.colour}`);
    const printName = (data) => console.log(`Hello ${data.name}`);
    return {
        get: get,
        printFavouriteColour: printFavouriteColour,
        printName: printName
    }
})();

userDataFactory.get(userDataFactory.printFavouriteColour);
userDataFactory.get(userDataFactory.printName);</pre>
            </td>
        </tr>
    </table>
    <p>With this example we are now passing down the chain a method that has come from a <strong>higher order</strong>.
        Think of this as being similar to a <strong>delegate method</strong>. The method we are passing down will
        determine what we do once we have the data. There is no assumption being made other than we want to do something
        once we have the data. Both solutions given are interpretations of dependency inversion, they move the control
        up the chain to a higher level.</p>
    <h1>13. How can we apply the DRY principle to JavaScript ?</h1>
    <p><strong>The DRY Principle</strong> stands for “<em>Don't' Repeat Yourself</em>” and refers to code reuse and code
        repetition. Where we see patterns of code forming, we should either be refactoring the code to remove the
        repetition or design the code to maximise on code reuse from the beginning.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="d9f91252-9204-4346-a8e8-3aa6fcc930ee"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let make = "Audi";
let colour = "Red";
let isHybrid = false;
let isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
let description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Ford";
colour = "Blue";
isHybrid = true;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Honda";
colour = "Black";
isHybrid = true;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Lamborghini";
colour = "Black";
isHybrid = false;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Porsche";
colour = "Yellow";
isHybrid = false;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);

make = "Dodge";
colour = "Green";
isHybrid = true;
isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
description = `This car is an ${make} and it is ${colour}. This car ${isHybridText}`;
console.log(description);</pre>
            </td>
        </tr>
    </table>
    <p>Here we clearly have a repetition of code. Each block of code is doing exactly the same thing. The only
        difference with each block are the properties. The logic is identical and the result of each block is of the
        same type - a string. The code would grow 6 lines with every car we add. This is not <strong>DRY</strong>!</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="9d53148e-20b8-472c-8ac7-513c869022db"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class Car {
    constructor(make, colour, isHybrid) {
        this.make = make;
        this.colour = colour;
        this.isHybrid = isHybrid;
        this.isHybridText = isHybrid ? "is a hybrid" : "is not a hybrid";
    }
    describe = () => `This car is an ${this.make} and it is ${this.colour}. This car ${this.isHybridText}`;
}

let describeCars = (cars = []) => {
    cars.forEach((car) => {
        console.log(car.describe());
    });
}

let cars = [
    new Car("Audi", "Red", false),
    new Car("Ford", "Blue", true),
    new Car("Honda", "Black", true),
    new Car("Lamborghini", "Black", false),
    new Car("Porsche", "Yellow", false),
    new Car("Dodge", "Green", true),
];

describeCars(cars);</pre>
            </td>
        </tr>
    </table>
    <p>Now using a reusable class and a some iteration, we are able to reuse the same code again and again. Our code
        will now only grow with a single line for every car we add. This is now <strong>DRY</strong>, we should always
        be thinking of <strong>DRY</strong>. </p>
    <h1>14. How can we apply the KISS principle to JavaScript ?</h1>
    <p><strong>The KISS Principle</strong> stands for “<em>Keep it simple, stupid</em>” and relates to overly complex
        code. The smaller and simpler our methods are, the more manageable our code will be. Complex code is prone to
        bugs, so by keeping it simple we remove the likelihood of bugs and we make our code much more friendly to work
        with and read.</p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="66e0fd60-affe-4e10-9707-9395ced2fa68"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let convertIntToDay = (dayNumber = 0) => {
    let result = "";
    if(dayNumber === 0) {
        result = "Monday";
    } else if(dayNumber === 1) {
        result = "Tuesday";
    } else if(dayNumber === 2) {
        result = "Wednesday";
    } else if(dayNumber === 3) {
        result = "Thursday";
    } else if(dayNumber === 4) {
        result = "Friday";
    } else if(dayNumber === 5) {
        result = "Saturday";
    } else if(dayNumber === 6) {
        result = "Sunday";
    }
    return result;
}

let day = convertIntToDay(2);
console.log(day);</pre>
            </td>
        </tr>
    </table>
    <p>This example uses multiple <em><strong>if</strong></em> statements to handle what is essentially just an index
        lookup. There is far more logic here than there needs to be. This is the kind of code that is in breach of the
        <strong>KISS</strong> principle. </p>
    <p>We could use a switch to make this read a bit easier, but simpler still, we could use the index directly to find
        the matched day. Arrays in JavaScript are zero indexed, so if our case begins with a zero we could get the same
        result by using the passed in number as an index position for the array.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="2c959f75-fab1-4a4e-be00-e432b34319b8"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>let convertIntToDay = (dayNumber = 0) => {
    let days = [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday"
    ]
    if(days.length &lt; dayNumber) {
        throw new Error("Must be in range of days");
    }
    return days[dayNumber];
}

let day = convertIntToDay(2);
console.log(day);</pre>
            </td>
        </tr>
    </table>
    <p>Removing all the unnecessary logic reveals a much cleaner solution, easier to understand and read. We are relying
        instead on the index of the array in order to find the matched day. This is a clear example of the
        <strong>KISS</strong> <strong>principle</strong> and what to look out for when considering existing code or
        designing new code.</p>
    <h1>15. How can we apply the YAGNI principle to JavaScript ?</h1>
    <p><strong>The YAGNI principle</strong> stands for “<em>You ain’t gonna need it</em>” and aims to remove unnecessary
        code and features. We should not be adding complexity just because it might come in handy in the future. Yes we
        should always consider future proofing our code, but be careful, we should not add extra weight where it is not
        needed. For example, adding additional properties that are not being used - “<em>you ain’t gonna need it</em>”.
    </p>
    <h3>Problem</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="15344451-a3b4-4f6a-897b-bd027ff2d3ce"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class Person {
    constructor(name) {
        this.name = name;
    }
    name = "";
    age = 0;
    sex = "";
    occupation = "";
}

let person = new Person("James");

console.log(person.name);</pre>
            </td>
        </tr>
    </table>
    <p>In this example we see there are more properties than we need, they are not being used in the constructor and
        they are not being accessed elsewhere. They appear to be there “just in case”. We do not need them.</p>
    <h3>Solution</h3>
    <table class="wysiwyg-macro" data-macro-name="code" data-macro-id="cdaa2c56-93fc-4a2b-87ed-5d4f3a1c9f72"
        data-macro-parameters="language=js" data-macro-schema-version="1"
        style="background-image: url(https://sharecentre.atlassian.net/wiki/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;"
        data-macro-body-type="PLAIN_TEXT">
        <tr>
            <td class="wysiwyg-macro-body">
                <pre>class Person {
    constructor(name) {
        this.name = name;
    }
}

let person = new Person("James");

console.log(person.name);</pre>
            </td>
        </tr>
    </table>
    <p>Now having removed the unnecessary properties we have a much cleaner solution, comprising only of the properties
        we need. This is following the <strong>YAGNI</strong> principle and we should be using this principle where
        possible. </p>
    <p>Only implement what we need for the immediate requirement and not what we think we might need in the future. This
        allows for faster development and simpler, lighter code.</p>
    <p />
    <p>&nbsp;</p>
</body>

</html>